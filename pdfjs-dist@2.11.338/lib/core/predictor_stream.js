"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PredictorStream=void 0;var _decode_stream=require("./decode_stream.js"),_util=require("../shared/util.js"),_primitives=require("./primitives.js");class PredictorStream extends _decode_stream.DecodeStream{constructor(t,e,r){if(super(e),!(0,_primitives.isDict)(r))return t;const s=this.predictor=r.get("Predictor")||1;if(s<=1)return t;if(2!==s&&(s<10||s>15))throw new _util.FormatError(`Unsupported predictor: ${s}`);this.readBlock=2===s?this.readBlockTiff:this.readBlockPng,this.str=t,this.dict=t.dict;const i=this.colors=r.get("Colors")||1,o=this.bits=r.get("BitsPerComponent")||8,c=this.columns=r.get("Columns")||1;return this.pixBytes=i*o+7>>3,this.rowBytes=c*i*o+7>>3,this}readBlockTiff(){const t=this.rowBytes,e=this.bufferLength,r=this.ensureBuffer(e+t),s=this.bits,i=this.colors,o=this.str.getBytes(t);if(this.eof=!o.length,this.eof)return;let c,f=0,h=0,n=0,a=0,l=e;if(1===s&&1===i)for(c=0;c<t;++c){let t=o[c]^f;t^=t>>1,t^=t>>2,t^=t>>4,f=(1&t)<<7,r[l++]=t}else if(8===s){for(c=0;c<i;++c)r[l++]=o[c];for(;c<t;++c)r[l]=r[l-i]+o[c],l++}else if(16===s){const e=2*i;for(c=0;c<e;++c)r[l++]=o[c];for(;c<t;c+=2){const t=((255&o[c])<<8)+(255&o[c+1])+((255&r[l-e])<<8)+(255&r[l-e+1]);r[l++]=t>>8&255,r[l++]=255&t}}else{const t=new Uint8Array(i+1),l=(1<<s)-1;let u=0,d=e;const p=this.columns;for(c=0;c<p;++c)for(let e=0;e<i;++e)n<s&&(f=f<<8|255&o[u++],n+=8),t[e]=t[e]+(f>>n-s)&l,n-=s,h=h<<s|t[e],a+=s,a>=8&&(r[d++]=h>>a-8&255,a-=8);a>0&&(r[d++]=(h<<8-a)+(f&(1<<8-a)-1))}this.bufferLength+=t}readBlockPng(){const t=this.rowBytes,e=this.pixBytes,r=this.str.getByte(),s=this.str.getBytes(t);if(this.eof=!s.length,this.eof)return;const i=this.bufferLength,o=this.ensureBuffer(i+t);let c=o.subarray(i-t,i);0===c.length&&(c=new Uint8Array(t));let f,h,n,a=i;switch(r){case 0:for(f=0;f<t;++f)o[a++]=s[f];break;case 1:for(f=0;f<e;++f)o[a++]=s[f];for(;f<t;++f)o[a]=o[a-e]+s[f]&255,a++;break;case 2:for(f=0;f<t;++f)o[a++]=c[f]+s[f]&255;break;case 3:for(f=0;f<e;++f)o[a++]=(c[f]>>1)+s[f];for(;f<t;++f)o[a]=(c[f]+o[a-e]>>1)+s[f]&255,a++;break;case 4:for(f=0;f<e;++f)h=c[f],n=s[f],o[a++]=h+n;for(;f<t;++f){h=c[f];const t=c[f-e],r=o[a-e],i=r+h-t;let l=i-r;l<0&&(l=-l);let u=i-h;u<0&&(u=-u);let d=i-t;d<0&&(d=-d),n=s[f],o[a++]=l<=u&&l<=d?r+n:u<=d?h+n:t+n}break;default:throw new _util.FormatError(`Unsupported predictor: ${r}`)}this.bufferLength+=t}}exports.PredictorStream=PredictorStream;