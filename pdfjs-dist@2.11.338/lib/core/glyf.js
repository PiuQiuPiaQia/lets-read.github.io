"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GlyfTable=void 0;const ON_CURVE_POINT=1,X_SHORT_VECTOR=2,Y_SHORT_VECTOR=4,REPEAT_FLAG=8,X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR=16,Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR=32,OVERLAP_SIMPLE=64,ARG_1_AND_2_ARE_WORDS=1,ARGS_ARE_XY_VALUES=2,WE_HAVE_A_SCALE=8,MORE_COMPONENTS=32,WE_HAVE_AN_X_AND_Y_SCALE=64,WE_HAVE_A_TWO_BY_TWO=128,WE_HAVE_INSTRUCTIONS=256;class GlyfTable{constructor({glyfTable:t,isGlyphLocationsLong:s,locaTable:e,numGlyphs:n}){this.glyphs=[];const i=new DataView(e.buffer,e.byteOffset,e.byteLength),r=new DataView(t.buffer,t.byteOffset,t.byteLength),o=s?4:2;let _=s?i.getUint32(0):2*i.getUint16(0),h=0;for(let a=0;a<n;a++){h+=o;const t=s?i.getUint32(h):2*i.getUint16(h);if(t===_){this.glyphs.push(new Glyph({}));continue}const e=Glyph.parse(_,r);this.glyphs.push(e),_=t}}getSize(){return this.glyphs.reduce(((t,s)=>{const e=s.getSize();return t+(e+3&-4)}),0)}write(){const t=this.getSize(),s=new DataView(new ArrayBuffer(t)),e=t>131070,n=e?4:2,i=new DataView(new ArrayBuffer((this.glyphs.length+1)*n));e?i.setUint32(0,0):i.setUint16(0,0);let r=0,o=0;for(const _ of this.glyphs)r+=_.write(r,s),r=r+3&-4,o+=n,e?i.setUint32(o,r):i.setUint16(o,r>>1);return{isLocationLong:e,loca:new Uint8Array(i.buffer),glyf:new Uint8Array(s.buffer)}}scale(t){for(let s=0,e=this.glyphs.length;s<e;s++)this.glyphs[s].scale(t[s])}}exports.GlyfTable=GlyfTable;class Glyph{constructor({header:t=null,simple:s=null,composites:e=null}){this.header=t,this.simple=s,this.composites=e}static parse(t,s){const[e,n]=GlyphHeader.parse(t,s);if(t+=e,n.numberOfContours<0){const e=[];while(1){const[n,i]=CompositeGlyph.parse(t,s);if(t+=n,e.push(i),!(i.flags&MORE_COMPONENTS))break}return new Glyph({header:n,composites:e})}const i=SimpleGlyph.parse(t,s,n.numberOfContours);return new Glyph({header:n,simple:i})}getSize(){if(!this.header)return 0;const t=this.simple?this.simple.getSize():this.composites.reduce(((t,s)=>t+s.getSize()),0);return this.header.getSize()+t}write(t,s){if(!this.header)return 0;const e=t;if(t+=this.header.write(t,s),this.simple)t+=this.simple.write(t,s);else for(const n of this.composites)t+=n.write(t,s);return t-e}scale(t){if(!this.header)return;const s=(this.header.xMin+this.header.xMax)/2;if(this.header.scale(s,t),this.simple)this.simple.scale(s,t);else for(const e of this.composites)e.scale(s,t)}}class GlyphHeader{constructor({numberOfContours:t,xMin:s,yMin:e,xMax:n,yMax:i}){this.numberOfContours=t,this.xMin=s,this.yMin=e,this.xMax=n,this.yMax=i}static parse(t,s){return[10,new GlyphHeader({numberOfContours:s.getInt16(t),xMin:s.getInt16(t+2),yMin:s.getInt16(t+4),xMax:s.getInt16(t+6),yMax:s.getInt16(t+8)})]}getSize(){return 10}write(t,s){return s.setInt16(t,this.numberOfContours),s.setInt16(t+2,this.xMin),s.setInt16(t+4,this.yMin),s.setInt16(t+6,this.xMax),s.setInt16(t+8,this.yMax),10}scale(t,s){this.xMin=Math.round(t+(this.xMin-t)*s),this.xMax=Math.round(t+(this.xMax-t)*s)}}class Contour{constructor({flags:t,xCoordinates:s,yCoordinates:e}){this.xCoordinates=s,this.yCoordinates=e,this.flags=t}}class SimpleGlyph{constructor({contours:t,instructions:s}){this.contours=t,this.instructions=s}static parse(t,s,e){const n=[];for(let S=0;S<e;S++){const e=s.getUint16(t);t+=2,n.push(e)}const i=n[e-1]+1,r=s.getUint16(t);t+=2;const o=new Uint8Array(s).slice(t,t+r);t+=r;const _=[];for(let S=0;S<i;t++,S++){let e=s.getUint8(t);if(_.push(e),e&REPEAT_FLAG){const n=s.getUint8(++t);e^=REPEAT_FLAG;for(let t=0;t<n;t++)_.push(e);S+=n}}const h=[];let a=[],l=[],u=[];const g=[];let c=0,O=0;for(let S=0;S<i;S++){const e=_[S];if(e&X_SHORT_VECTOR){const n=s.getUint8(t++);O+=e&X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR?n:-n,a.push(O)}else e&X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR||(O+=s.getInt16(t),t+=2),a.push(O);n[c]===S&&(c++,h.push(a),a=[])}O=0,c=0;for(let S=0;S<i;S++){const e=_[S];if(e&Y_SHORT_VECTOR){const n=s.getUint8(t++);O+=e&Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR?n:-n,l.push(O)}else e&Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR||(O+=s.getInt16(t),t+=2),l.push(O);u.push(e&ON_CURVE_POINT|e&OVERLAP_SIMPLE),n[c]===S&&(a=h[c],c++,g.push(new Contour({flags:u,xCoordinates:a,yCoordinates:l})),l=[],u=[])}return new SimpleGlyph({contours:g,instructions:o})}getSize(){let t=2*this.contours.length+2+this.instructions.length,s=0,e=0;for(const n of this.contours){t+=n.flags.length;for(let i=0,r=n.xCoordinates.length;i<r;i++){const r=n.xCoordinates[i],o=n.yCoordinates[i];let _=Math.abs(r-s);_>255?t+=2:_>0&&(t+=1),s=r,_=Math.abs(o-e),_>255?t+=2:_>0&&(t+=1),e=o}}return t}write(t,s){const e=t,n=[],i=[],r=[];let o=0,_=0;for(const h of this.contours){for(let t=0,s=h.xCoordinates.length;t<s;t++){let s=h.flags[t];const e=h.xCoordinates[t];let a=e-o;if(0===a)s|=X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR,n.push(0);else{const t=Math.abs(a);t<=255?(s|=a>=0?X_SHORT_VECTOR|X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR:X_SHORT_VECTOR,n.push(t)):n.push(a)}o=e;const l=h.yCoordinates[t];if(a=l-_,0===a)s|=Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR,i.push(0);else{const t=Math.abs(a);t<=255?(s|=a>=0?Y_SHORT_VECTOR|Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR:Y_SHORT_VECTOR,i.push(t)):i.push(a)}_=l,r.push(s)}s.setUint16(t,n.length-1),t+=2}s.setUint16(t,this.instructions.length),t+=2,this.instructions.length&&(new Uint8Array(s.buffer,0,s.buffer.byteLength).set(this.instructions,t),t+=this.instructions.length);for(const h of r)s.setUint8(t++,h);for(let h=0,a=n.length;h<a;h++){const e=n[h],i=r[h];i&X_SHORT_VECTOR?s.setUint8(t++,e):i&X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR||(s.setInt16(t,e),t+=2)}for(let h=0,a=i.length;h<a;h++){const e=i[h],n=r[h];n&Y_SHORT_VECTOR?s.setUint8(t++,e):n&Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR||(s.setInt16(t,e),t+=2)}return t-e}scale(t,s){for(const e of this.contours)if(0!==e.xCoordinates.length)for(let n=0,i=e.xCoordinates.length;n<i;n++)e.xCoordinates[n]=Math.round(t+(e.xCoordinates[n]-t)*s)}}class CompositeGlyph{constructor({flags:t,glyphIndex:s,argument1:e,argument2:n,transf:i,instructions:r}){this.flags=t,this.glyphIndex=s,this.argument1=e,this.argument2=n,this.transf=i,this.instructions=r}static parse(t,s){const e=t,n=[];let i=s.getUint16(t);const r=s.getUint16(t+2);let o,_;if(t+=4,i&ARG_1_AND_2_ARE_WORDS)i&ARGS_ARE_XY_VALUES?(o=s.getInt16(t),_=s.getInt16(t+2)):(o=s.getUint16(t),_=s.getUint16(t+2)),t+=4,i^=ARG_1_AND_2_ARE_WORDS;else{if(o=s.getUint8(t),_=s.getUint8(t+1),i&ARGS_ARE_XY_VALUES){const t=127&o;o=128&o?-t:t;const s=127&_;_=128&_?-s:s}t+=2}i&WE_HAVE_A_SCALE?(n.push(s.getUint16(t)),t+=2):i&WE_HAVE_AN_X_AND_Y_SCALE?(n.push(s.getUint16(t),s.getUint16(t+2)),t+=4):i&WE_HAVE_A_TWO_BY_TWO&&(n.push(s.getUint16(t),s.getUint16(t+2),s.getUint16(t+4),s.getUint16(t+6)),t+=8);let h=null;if(i&WE_HAVE_INSTRUCTIONS){const e=s.getUint16(t);t+=2,h=new Uint8Array(s).slice(t,t+e),t+=e}return[t-e,new CompositeGlyph({flags:i,glyphIndex:r,argument1:o,argument2:_,transf:n,instructions:h})]}getSize(){let t=4+2*this.transf.length;return this.flags&WE_HAVE_INSTRUCTIONS&&(t+=2+this.instructions.length),t+=2,2&this.flags?this.argument1>=-128&&this.argument1<=127&&this.argument2>=-128&&this.argument2<=127||(t+=2):this.argument1>=0&&this.argument1<=255&&this.argument2>=0&&this.argument2<=255||(t+=2),t}write(t,s){const e=t;return this.flags&ARGS_ARE_XY_VALUES?this.argument1>=-128&&this.argument1<=127&&this.argument2>=-128&&this.argument2<=127||(this.flags|=ARG_1_AND_2_ARE_WORDS):this.argument1>=0&&this.argument1<=255&&this.argument2>=0&&this.argument2<=255||(this.flags|=ARG_1_AND_2_ARE_WORDS),s.setUint16(t,this.flags),s.setUint16(t+2,this.glyphIndex),t+=4,this.flags&ARG_1_AND_2_ARE_WORDS?(this.flags&ARGS_ARE_XY_VALUES?(s.setInt16(t,this.argument1),s.setInt16(t+2,this.argument2)):(s.setUint16(t,this.argument1),s.setUint16(t+2,this.argument2)),t+=4):(s.setUint8(t,this.argument1),s.setUint8(t+1,this.argument2),t+=2),this.flags&WE_HAVE_INSTRUCTIONS&&(s.setUint16(t,this.instructions.length),t+=2,this.instructions.length&&(new Uint8Array(s.buffer,0,s.buffer.byteLength).set(this.instructions,t),t+=this.instructions.length)),t-e}scale(t,s){}}