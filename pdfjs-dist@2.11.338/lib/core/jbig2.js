"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Jbig2Image=void 0;var _util=require("../shared/util.js"),_core_utils=require("./core_utils.js"),_arithmetic_decoder=require("./arithmetic_decoder.js"),_ccitt=require("./ccitt.js");class Jbig2Error extends _util.BaseException{constructor(e){super(`JBIG2 error: ${e}`,"Jbig2Error")}}class ContextCache{getContexts(e){return e in this?this[e]:this[e]=new Int8Array(65536)}}class DecodingContext{constructor(e,t,n){this.data=e,this.start=t,this.end=n}get decoder(){const e=new _arithmetic_decoder.ArithmeticDecoder(this.data,this.start,this.end);return(0,_util.shadow)(this,"decoder",e)}get contextCache(){const e=new ContextCache;return(0,_util.shadow)(this,"contextCache",e)}}function decodeInteger(e,t,n){const r=e.getContexts(t);let i=1;function o(e){let t=0;for(let o=0;o<e;o++){const e=n.readBit(r,i);i=i<256?i<<1|e:511&(i<<1|e)|256,t=t<<1|e}return t>>>0}const a=o(1),s=o(1)?o(1)?o(1)?o(1)?o(1)?o(32)+4436:o(12)+340:o(8)+84:o(6)+20:o(4)+4:o(2);return 0===a?s:s>0?-s:null}function decodeIAID(e,t,n){const r=e.getContexts("IAID");let i=1;for(let o=0;o<n;o++){const e=t.readBit(r,i);i=i<<1|e}return n<31?i&(1<<n)-1:2147483647&i}const SegmentTypes=["SymbolDictionary",null,null,null,"IntermediateTextRegion",null,"ImmediateTextRegion","ImmediateLosslessTextRegion",null,null,null,null,null,null,null,null,"PatternDictionary",null,null,null,"IntermediateHalftoneRegion",null,"ImmediateHalftoneRegion","ImmediateLosslessHalftoneRegion",null,null,null,null,null,null,null,null,null,null,null,null,"IntermediateGenericRegion",null,"ImmediateGenericRegion","ImmediateLosslessGenericRegion","IntermediateGenericRefinementRegion",null,"ImmediateGenericRefinementRegion","ImmediateLosslessGenericRefinementRegion",null,null,null,null,"PageInformation","EndOfPage","EndOfStripe","EndOfFile","Profiles","Tables",null,null,null,null,null,null,null,null,"Extension"],CodingTemplates=[[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:2,y:-1},{x:-4,y:0},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}],[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:2,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:2,y:-1},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}],[{x:-1,y:-2},{x:0,y:-2},{x:1,y:-2},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-2,y:0},{x:-1,y:0}],[{x:-3,y:-1},{x:-2,y:-1},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-4,y:0},{x:-3,y:0},{x:-2,y:0},{x:-1,y:0}]],RefinementTemplates=[{coding:[{x:0,y:-1},{x:1,y:-1},{x:-1,y:0}],reference:[{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:0,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1}]},{coding:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0}],reference:[{x:0,y:-1},{x:-1,y:0},{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1}]}],ReusedContexts=[39717,1941,229,405],RefinementReusedContexts=[32,8];function decodeBitmapTemplate0(e,t,n){const r=n.decoder,i=n.contextCache.getContexts("GB"),o=[];let a,s,l,c,d,f,h;const u=31735;for(s=0;s<t;s++)for(d=o[s]=new Uint8Array(e),f=s<1?d:o[s-1],h=s<2?d:o[s-2],a=h[0]<<13|h[1]<<12|h[2]<<11|f[0]<<7|f[1]<<6|f[2]<<5|f[3]<<4,l=0;l<e;l++)d[l]=c=r.readBit(i,a),a=(a&u)<<1|(l+3<e?h[l+3]<<11:0)|(l+4<e?f[l+4]<<4:0)|c;return o}function decodeBitmap(e,t,n,r,i,o,a,s){if(e){const e=new Reader(s.data,s.start,s.end);return decodeMMRBitmap(e,t,n,!1)}if(0===r&&!o&&!i&&4===a.length&&3===a[0].x&&-1===a[0].y&&-3===a[1].x&&-1===a[1].y&&2===a[2].x&&-2===a[2].y&&-2===a[3].x&&-2===a[3].y)return decodeBitmapTemplate0(t,n,s);const l=!!o,c=CodingTemplates[r].concat(a);c.sort((function(e,t){return e.y-t.y||e.x-t.x}));const d=c.length,f=new Int8Array(d),h=new Int8Array(d),u=[];let m,g,b=0,p=0,w=0,x=0;for(g=0;g<d;g++)f[g]=c[g].x,h[g]=c[g].y,p=Math.min(p,c[g].x),w=Math.max(w,c[g].x),x=Math.min(x,c[g].y),g<d-1&&c[g].y===c[g+1].y&&c[g].x===c[g+1].x-1?b|=1<<d-1-g:u.push(g);const y=u.length,I=new Int8Array(y),_=new Int8Array(y),S=new Uint16Array(y);for(m=0;m<y;m++)g=u[m],I[m]=c[g].x,_[m]=c[g].y,S[m]=1<<d-1-g;const T=-p,R=-x,D=t-w,H=ReusedContexts[r];let C=new Uint8Array(t);const B=[],k=s.decoder,A=s.contextCache.getContexts("GB");let L,U,O,E,J,P=0,v=0;for(let N=0;N<n;N++){if(i){const e=k.readBit(A,H);if(P^=e,P){B.push(C);continue}}for(C=new Uint8Array(C),B.push(C),L=0;L<t;L++){if(l&&o[N][L]){C[L]=0;continue}if(L>=T&&L<D&&N>=R)for(v=v<<1&b,g=0;g<y;g++)U=N+_[g],O=L+I[g],E=B[U][O],E&&(E=S[g],v|=E);else for(v=0,J=d-1,g=0;g<d;g++,J--)O=L+f[g],O>=0&&O<t&&(U=N+h[g],U>=0&&(E=B[U][O],E&&(v|=E<<J)));const e=k.readBit(A,v);C[L]=e}}return B}function decodeRefinement(e,t,n,r,i,o,a,s,l){let c=RefinementTemplates[n].coding;0===n&&(c=c.concat([s[0]]));const d=c.length,f=new Int32Array(d),h=new Int32Array(d);let u;for(u=0;u<d;u++)f[u]=c[u].x,h[u]=c[u].y;let m=RefinementTemplates[n].reference;0===n&&(m=m.concat([s[1]]));const g=m.length,b=new Int32Array(g),p=new Int32Array(g);for(u=0;u<g;u++)b[u]=m[u].x,p[u]=m[u].y;const w=r[0].length,x=r.length,y=RefinementReusedContexts[n],I=[],_=l.decoder,S=l.contextCache.getContexts("GR");let T=0;for(let R=0;R<t;R++){if(a){const e=_.readBit(S,y);if(T^=e,T)throw new Jbig2Error("prediction is not supported")}const t=new Uint8Array(e);I.push(t);for(let n=0;n<e;n++){let a,s,l=0;for(u=0;u<d;u++)a=R+h[u],s=n+f[u],a<0||s<0||s>=e?l<<=1:l=l<<1|I[a][s];for(u=0;u<g;u++)a=R+p[u]-o,s=n+b[u]-i,a<0||a>=x||s<0||s>=w?l<<=1:l=l<<1|r[a][s];const c=_.readBit(S,l);t[n]=c}}return I}function decodeSymbolDictionary(e,t,n,r,i,o,a,s,l,c,d,f){if(e&&t)throw new Jbig2Error("symbol refinement with Huffman is not supported");const h=[];let u=0,m=(0,_core_utils.log2)(n.length+r);const g=d.decoder,b=d.contextCache;let p,w;e&&(p=getStandardTable(1),w=[],m=Math.max(m,1));while(h.length<r){const r=e?o.tableDeltaHeight.decode(f):decodeInteger(b,"IADH",g);u+=r;let i=0,p=0;const x=e?w.length:0;while(1){const r=e?o.tableDeltaWidth.decode(f):decodeInteger(b,"IADW",g);if(null===r)break;let x;if(i+=r,p+=i,t){const r=decodeInteger(b,"IAAI",g);if(r>1)x=decodeTextRegion(e,t,i,u,0,r,1,n.concat(h),m,0,0,1,0,o,l,c,d,0,f);else{const e=decodeIAID(b,g,m),t=decodeInteger(b,"IARDX",g),r=decodeInteger(b,"IARDY",g),o=e<n.length?n[e]:h[e-n.length];x=decodeRefinement(i,u,l,o,t,r,!1,c,d)}h.push(x)}else e?w.push(i):(x=decodeBitmap(!1,i,u,a,!1,null,s,d),h.push(x))}if(e&&!t){const e=o.tableBitmapSize.decode(f);let t;if(f.byteAlign(),0===e)t=readUncompressedBitmap(f,p,u);else{const n=f.end,r=f.position+e;f.end=r,t=decodeMMRBitmap(f,p,u,!1),f.end=n,f.position=r}const n=w.length;if(x===n-1)h.push(t);else{let e,r,i,o,a,s=0;for(e=x;e<n;e++){for(o=w[e],i=s+o,a=[],r=0;r<u;r++)a.push(t[r].subarray(s,i));h.push(a),s=i}}}}const x=[],y=[];let I,_,S=!1;const T=n.length+r;while(y.length<T){let t=e?p.decode(f):decodeInteger(b,"IAEX",g);while(t--)y.push(S);S=!S}for(I=0,_=n.length;I<_;I++)y[I]&&x.push(n[I]);for(let R=0;R<r;I++,R++)y[I]&&x.push(h[R]);return x}function decodeTextRegion(e,t,n,r,i,o,a,s,l,c,d,f,h,u,m,g,b,p,w){if(e&&t)throw new Jbig2Error("refinement with Huffman is not supported");const x=[];let y,I;for(y=0;y<r;y++){if(I=new Uint8Array(n),i)for(let e=0;e<n;e++)I[e]=i;x.push(I)}const _=b.decoder,S=b.contextCache;let T=e?-u.tableDeltaT.decode(w):-decodeInteger(S,"IADT",_),R=0;y=0;while(y<o){const r=e?u.tableDeltaT.decode(w):decodeInteger(S,"IADT",_);T+=r;const i=e?u.tableFirstS.decode(w):decodeInteger(S,"IAFS",_);R+=i;let o=R;do{let r=0;a>1&&(r=e?w.readBits(p):decodeInteger(S,"IAIT",_));const i=a*T+r,R=e?u.symbolIDTable.decode(w):decodeIAID(S,_,l),D=t&&(e?w.readBit():decodeInteger(S,"IARI",_));let H=s[R],C=H[0].length,B=H.length;if(D){const e=decodeInteger(S,"IARDW",_),t=decodeInteger(S,"IARDH",_),n=decodeInteger(S,"IARDX",_),r=decodeInteger(S,"IARDY",_);C+=e,B+=t,H=decodeRefinement(C,B,m,H,(e>>1)+n,(t>>1)+r,!1,g,b)}const k=i-(1&f?0:B-1),A=o-(2&f?C-1:0);let L,U,O;if(c){for(L=0;L<B;L++){if(I=x[A+L],!I)continue;O=H[L];const e=Math.min(n-k,C);switch(h){case 0:for(U=0;U<e;U++)I[k+U]|=O[U];break;case 2:for(U=0;U<e;U++)I[k+U]^=O[U];break;default:throw new Jbig2Error(`operator ${h} is not supported`)}}o+=B-1}else{for(U=0;U<B;U++)if(I=x[k+U],I)switch(O=H[U],h){case 0:for(L=0;L<C;L++)I[A+L]|=O[L];break;case 2:for(L=0;L<C;L++)I[A+L]^=O[L];break;default:throw new Jbig2Error(`operator ${h} is not supported`)}o+=C-1}y++;const E=e?u.tableDeltaS.decode(w):decodeInteger(S,"IADS",_);if(null===E)break;o+=E+d}while(1)}return x}function decodePatternDictionary(e,t,n,r,i,o){const a=[];e||(a.push({x:-t,y:0}),0===i&&a.push({x:-3,y:-1},{x:2,y:-2},{x:-2,y:-2}));const s=(r+1)*t,l=decodeBitmap(e,s,n,i,!1,null,a,o),c=[];for(let d=0;d<=r;d++){const e=[],r=t*d,i=r+t;for(let t=0;t<n;t++)e.push(l[t].subarray(r,i));c.push(e)}return c}function decodeHalftoneRegion(e,t,n,r,i,o,a,s,l,c,d,f,h,u,m){const g=null;if(a)throw new Jbig2Error("skip is not supported");if(0!==s)throw new Jbig2Error(`operator "${s}" is not supported in halftone region`);const b=[];let p,w,x;for(p=0;p<i;p++){if(x=new Uint8Array(r),o)for(w=0;w<r;w++)x[w]=o;b.push(x)}const y=t.length,I=t[0],_=I[0].length,S=I.length,T=(0,_core_utils.log2)(y),R=[];e||(R.push({x:n<=1?3:2,y:-1}),0===n&&R.push({x:-3,y:-1},{x:2,y:-2},{x:-2,y:-2}));const D=[];let H,C,B,k,A,L,U,O,E,J,P;for(e&&(H=new Reader(m.data,m.start,m.end)),p=T-1;p>=0;p--)C=e?decodeMMRBitmap(H,l,c,!0):decodeBitmap(!1,l,c,n,!1,g,R,m),D[p]=C;for(B=0;B<c;B++)for(k=0;k<l;k++){for(A=0,L=0,w=T-1;w>=0;w--)A^=D[w][B][k],L|=A<<w;if(U=t[L],O=d+B*u+k*h>>8,E=f+B*h-k*u>>8,O>=0&&O+_<=r&&E>=0&&E+S<=i)for(p=0;p<S;p++)for(P=b[E+p],J=U[p],w=0;w<_;w++)P[O+w]|=J[w];else{let e,t;for(p=0;p<S;p++)if(t=E+p,!(t<0||t>=i))for(P=b[t],J=U[p],w=0;w<_;w++)e=O+w,e>=0&&e<r&&(P[e]|=J[w])}}return b}function readSegmentHeader(e,t){const n={};n.number=(0,_core_utils.readUint32)(e,t);const r=e[t+4],i=63&r;if(!SegmentTypes[i])throw new Jbig2Error("invalid segment type: "+i);n.type=i,n.typeName=SegmentTypes[i],n.deferredNonRetain=!!(128&r);const o=!!(64&r),a=e[t+5];let s=a>>5&7;const l=[31&a];let c=t+6;if(7===a){s=536870911&(0,_core_utils.readUint32)(e,c-1),c+=3;let t=s+7>>3;l[0]=e[c++];while(--t>0)l.push(e[c++])}else if(5===a||6===a)throw new Jbig2Error("invalid referred-to flags");n.retainBits=l;let d=4;n.number<=256?d=1:n.number<=65536&&(d=2);const f=[];let h,u;for(h=0;h<s;h++){let t;t=1===d?e[c]:2===d?(0,_core_utils.readUint16)(e,c):(0,_core_utils.readUint32)(e,c),f.push(t),c+=d}if(n.referredTo=f,o?(n.pageAssociation=(0,_core_utils.readUint32)(e,c),c+=4):n.pageAssociation=e[c++],n.length=(0,_core_utils.readUint32)(e,c),c+=4,4294967295===n.length){if(38!==i)throw new Jbig2Error("invalid unknown segment length");{const t=readRegionSegmentInformation(e,c),r=e[c+RegionSegmentInformationFieldLength],i=!!(1&r),o=6,a=new Uint8Array(o);for(i||(a[0]=255,a[1]=172),a[2]=t.height>>>24&255,a[3]=t.height>>16&255,a[4]=t.height>>8&255,a[5]=255&t.height,h=c,u=e.length;h<u;h++){let t=0;while(t<o&&a[t]===e[h+t])t++;if(t===o){n.length=h+o;break}}if(4294967295===n.length)throw new Jbig2Error("segment end was not found")}}return n.headerEnd=c,n}function readSegments(e,t,n,r){const i=[];let o=n;while(o<r){const n=readSegmentHeader(t,o);o=n.headerEnd;const r={header:n,data:t};if(e.randomAccess||(r.start=o,o+=n.length,r.end=o),i.push(r),51===n.type)break}if(e.randomAccess)for(let a=0,s=i.length;a<s;a++)i[a].start=o,o+=i[a].header.length,i[a].end=o;return i}function readRegionSegmentInformation(e,t){return{width:(0,_core_utils.readUint32)(e,t),height:(0,_core_utils.readUint32)(e,t+4),x:(0,_core_utils.readUint32)(e,t+8),y:(0,_core_utils.readUint32)(e,t+12),combinationOperator:7&e[t+16]}}const RegionSegmentInformationFieldLength=17;function processSegment(e,t){const n=e.header,r=e.data,i=e.end;let o,a,s,l,c=e.start;switch(n.type){case 0:const e={},t=(0,_core_utils.readUint16)(r,c);if(e.huffman=!!(1&t),e.refinement=!!(2&t),e.huffmanDHSelector=t>>2&3,e.huffmanDWSelector=t>>4&3,e.bitmapSizeSelector=t>>6&1,e.aggregationInstancesSelector=t>>7&1,e.bitmapCodingContextUsed=!!(256&t),e.bitmapCodingContextRetained=!!(512&t),e.template=t>>10&3,e.refinementTemplate=t>>12&1,c+=2,!e.huffman){for(l=0===e.template?4:1,a=[],s=0;s<l;s++)a.push({x:(0,_core_utils.readInt8)(r,c),y:(0,_core_utils.readInt8)(r,c+1)}),c+=2;e.at=a}if(e.refinement&&!e.refinementTemplate){for(a=[],s=0;s<2;s++)a.push({x:(0,_core_utils.readInt8)(r,c),y:(0,_core_utils.readInt8)(r,c+1)}),c+=2;e.refinementAt=a}e.numberOfExportedSymbols=(0,_core_utils.readUint32)(r,c),c+=4,e.numberOfNewSymbols=(0,_core_utils.readUint32)(r,c),c+=4,o=[e,n.number,n.referredTo,r,c,i];break;case 6:case 7:const d={};d.info=readRegionSegmentInformation(r,c),c+=RegionSegmentInformationFieldLength;const f=(0,_core_utils.readUint16)(r,c);if(c+=2,d.huffman=!!(1&f),d.refinement=!!(2&f),d.logStripSize=f>>2&3,d.stripSize=1<<d.logStripSize,d.referenceCorner=f>>4&3,d.transposed=!!(64&f),d.combinationOperator=f>>7&3,d.defaultPixelValue=f>>9&1,d.dsOffset=f<<17>>27,d.refinementTemplate=f>>15&1,d.huffman){const e=(0,_core_utils.readUint16)(r,c);c+=2,d.huffmanFS=3&e,d.huffmanDS=e>>2&3,d.huffmanDT=e>>4&3,d.huffmanRefinementDW=e>>6&3,d.huffmanRefinementDH=e>>8&3,d.huffmanRefinementDX=e>>10&3,d.huffmanRefinementDY=e>>12&3,d.huffmanRefinementSizeSelector=!!(16384&e)}if(d.refinement&&!d.refinementTemplate){for(a=[],s=0;s<2;s++)a.push({x:(0,_core_utils.readInt8)(r,c),y:(0,_core_utils.readInt8)(r,c+1)}),c+=2;d.refinementAt=a}d.numberOfSymbolInstances=(0,_core_utils.readUint32)(r,c),c+=4,o=[d,n.referredTo,r,c,i];break;case 16:const h={},u=r[c++];h.mmr=!!(1&u),h.template=u>>1&3,h.patternWidth=r[c++],h.patternHeight=r[c++],h.maxPatternIndex=(0,_core_utils.readUint32)(r,c),c+=4,o=[h,n.number,r,c,i];break;case 22:case 23:const m={};m.info=readRegionSegmentInformation(r,c),c+=RegionSegmentInformationFieldLength;const g=r[c++];m.mmr=!!(1&g),m.template=g>>1&3,m.enableSkip=!!(8&g),m.combinationOperator=g>>4&7,m.defaultPixelValue=g>>7&1,m.gridWidth=(0,_core_utils.readUint32)(r,c),c+=4,m.gridHeight=(0,_core_utils.readUint32)(r,c),c+=4,m.gridOffsetX=4294967295&(0,_core_utils.readUint32)(r,c),c+=4,m.gridOffsetY=4294967295&(0,_core_utils.readUint32)(r,c),c+=4,m.gridVectorX=(0,_core_utils.readUint16)(r,c),c+=2,m.gridVectorY=(0,_core_utils.readUint16)(r,c),c+=2,o=[m,n.referredTo,r,c,i];break;case 38:case 39:const b={};b.info=readRegionSegmentInformation(r,c),c+=RegionSegmentInformationFieldLength;const p=r[c++];if(b.mmr=!!(1&p),b.template=p>>1&3,b.prediction=!!(8&p),!b.mmr){for(l=0===b.template?4:1,a=[],s=0;s<l;s++)a.push({x:(0,_core_utils.readInt8)(r,c),y:(0,_core_utils.readInt8)(r,c+1)}),c+=2;b.at=a}o=[b,r,c,i];break;case 48:const w={width:(0,_core_utils.readUint32)(r,c),height:(0,_core_utils.readUint32)(r,c+4),resolutionX:(0,_core_utils.readUint32)(r,c+8),resolutionY:(0,_core_utils.readUint32)(r,c+12)};4294967295===w.height&&delete w.height;const x=r[c+16];(0,_core_utils.readUint16)(r,c+17),w.lossless=!!(1&x),w.refinement=!!(2&x),w.defaultPixelValue=x>>2&1,w.combinationOperator=x>>3&3,w.requiresBuffer=!!(32&x),w.combinationOperatorOverride=!!(64&x),o=[w];break;case 49:break;case 50:break;case 51:break;case 53:o=[n.number,r,c,i];break;case 62:break;default:throw new Jbig2Error(`segment type ${n.typeName}(${n.type}) is not implemented`)}const d="on"+n.typeName;d in t&&t[d].apply(t,o)}function processSegments(e,t){for(let n=0,r=e.length;n<r;n++)processSegment(e[n],t)}function parseJbig2Chunks(e){const t=new SimpleSegmentVisitor;for(let n=0,r=e.length;n<r;n++){const r=e[n],i=readSegments({},r.data,r.start,r.end);processSegments(i,t)}return t.buffer}function parseJbig2(e){const t=e.length;let n=0;if(151!==e[n]||74!==e[n+1]||66!==e[n+2]||50!==e[n+3]||13!==e[n+4]||10!==e[n+5]||26!==e[n+6]||10!==e[n+7])throw new Jbig2Error("parseJbig2 - invalid header.");const r=Object.create(null);n+=8;const i=e[n++];r.randomAccess=!(1&i),2&i||(r.numberOfPages=(0,_core_utils.readUint32)(e,n),n+=4);const o=readSegments(r,e,n,t),a=new SimpleSegmentVisitor;processSegments(o,a);const{width:s,height:l}=a.currentPageInfo,c=a.buffer,d=new Uint8ClampedArray(s*l);let f=0,h=0;for(let u=0;u<l;u++){let e,t=0;for(let n=0;n<s;n++)t||(t=128,e=c[h++]),d[f++]=e&t?0:255,t>>=1}return{imgData:d,width:s,height:l}}class SimpleSegmentVisitor{onPageInformation(e){this.currentPageInfo=e;const t=e.width+7>>3,n=new Uint8ClampedArray(t*e.height);if(e.defaultPixelValue)for(let r=0,i=n.length;r<i;r++)n[r]=255;this.buffer=n}drawBitmap(e,t){const n=this.currentPageInfo,r=e.width,i=e.height,o=n.width+7>>3,a=n.combinationOperatorOverride?e.combinationOperator:n.combinationOperator,s=this.buffer,l=128>>(7&e.x);let c,d,f,h,u=e.y*o+(e.x>>3);switch(a){case 0:for(c=0;c<i;c++){for(f=l,h=u,d=0;d<r;d++)t[c][d]&&(s[h]|=f),f>>=1,f||(f=128,h++);u+=o}break;case 2:for(c=0;c<i;c++){for(f=l,h=u,d=0;d<r;d++)t[c][d]&&(s[h]^=f),f>>=1,f||(f=128,h++);u+=o}break;default:throw new Jbig2Error(`operator ${a} is not supported`)}}onImmediateGenericRegion(e,t,n,r){const i=e.info,o=new DecodingContext(t,n,r),a=decodeBitmap(e.mmr,i.width,i.height,e.template,e.prediction,null,e.at,o);this.drawBitmap(i,a)}onImmediateLosslessGenericRegion(){this.onImmediateGenericRegion.apply(this,arguments)}onSymbolDictionary(e,t,n,r,i,o){let a,s;e.huffman&&(a=getSymbolDictionaryHuffmanTables(e,n,this.customTables),s=new Reader(r,i,o));let l=this.symbols;l||(this.symbols=l={});let c=[];for(let f=0,h=n.length;f<h;f++){const e=l[n[f]];e&&(c=c.concat(e))}const d=new DecodingContext(r,i,o);l[t]=decodeSymbolDictionary(e.huffman,e.refinement,c,e.numberOfNewSymbols,e.numberOfExportedSymbols,a,e.template,e.at,e.refinementTemplate,e.refinementAt,d,s)}onImmediateTextRegion(e,t,n,r,i){const o=e.info;let a,s;const l=this.symbols;let c=[];for(let u=0,m=t.length;u<m;u++){const e=l[t[u]];e&&(c=c.concat(e))}const d=(0,_core_utils.log2)(c.length);e.huffman&&(s=new Reader(n,r,i),a=getTextRegionHuffmanTables(e,t,this.customTables,c.length,s));const f=new DecodingContext(n,r,i),h=decodeTextRegion(e.huffman,e.refinement,o.width,o.height,e.defaultPixelValue,e.numberOfSymbolInstances,e.stripSize,c,d,e.transposed,e.dsOffset,e.referenceCorner,e.combinationOperator,a,e.refinementTemplate,e.refinementAt,f,e.logStripSize,s);this.drawBitmap(o,h)}onImmediateLosslessTextRegion(){this.onImmediateTextRegion.apply(this,arguments)}onPatternDictionary(e,t,n,r,i){let o=this.patterns;o||(this.patterns=o={});const a=new DecodingContext(n,r,i);o[t]=decodePatternDictionary(e.mmr,e.patternWidth,e.patternHeight,e.maxPatternIndex,e.template,a)}onImmediateHalftoneRegion(e,t,n,r,i){const o=this.patterns[t[0]],a=e.info,s=new DecodingContext(n,r,i),l=decodeHalftoneRegion(e.mmr,o,e.template,a.width,a.height,e.defaultPixelValue,e.enableSkip,e.combinationOperator,e.gridWidth,e.gridHeight,e.gridOffsetX,e.gridOffsetY,e.gridVectorX,e.gridVectorY,s);this.drawBitmap(a,l)}onImmediateLosslessHalftoneRegion(){this.onImmediateHalftoneRegion.apply(this,arguments)}onTables(e,t,n,r){let i=this.customTables;i||(this.customTables=i={}),i[e]=decodeTablesSegment(t,n,r)}}class HuffmanLine{constructor(e){2===e.length?(this.isOOB=!0,this.rangeLow=0,this.prefixLength=e[0],this.rangeLength=0,this.prefixCode=e[1],this.isLowerRange=!1):(this.isOOB=!1,this.rangeLow=e[0],this.prefixLength=e[1],this.rangeLength=e[2],this.prefixCode=e[3],this.isLowerRange="lower"===e[4])}}class HuffmanTreeNode{constructor(e){this.children=[],e?(this.isLeaf=!0,this.rangeLength=e.rangeLength,this.rangeLow=e.rangeLow,this.isLowerRange=e.isLowerRange,this.isOOB=e.isOOB):this.isLeaf=!1}buildTree(e,t){const n=e.prefixCode>>t&1;if(t<=0)this.children[n]=new HuffmanTreeNode(e);else{let r=this.children[n];r||(this.children[n]=r=new HuffmanTreeNode(null)),r.buildTree(e,t-1)}}decodeNode(e){if(this.isLeaf){if(this.isOOB)return null;const t=e.readBits(this.rangeLength);return this.rangeLow+(this.isLowerRange?-t:t)}const t=this.children[e.readBit()];if(!t)throw new Jbig2Error("invalid Huffman data");return t.decodeNode(e)}}class HuffmanTable{constructor(e,t){t||this.assignPrefixCodes(e),this.rootNode=new HuffmanTreeNode(null);for(let n=0,r=e.length;n<r;n++){const t=e[n];t.prefixLength>0&&this.rootNode.buildTree(t,t.prefixLength-1)}}decode(e){return this.rootNode.decodeNode(e)}assignPrefixCodes(e){const t=e.length;let n=0;for(let c=0;c<t;c++)n=Math.max(n,e[c].prefixLength);const r=new Uint32Array(n+1);for(let c=0;c<t;c++)r[e[c].prefixLength]++;let i,o,a,s=1,l=0;r[0]=0;while(s<=n){l=l+r[s-1]<<1,i=l,o=0;while(o<t)a=e[o],a.prefixLength===s&&(a.prefixCode=i,i++),o++;s++}}}function decodeTablesSegment(e,t,n){const r=e[t],i=4294967295&(0,_core_utils.readUint32)(e,t+1),o=4294967295&(0,_core_utils.readUint32)(e,t+5),a=new Reader(e,t+9,n),s=1+(r>>1&7),l=1+(r>>4&7),c=[];let d,f,h=i;do{d=a.readBits(s),f=a.readBits(l),c.push(new HuffmanLine([h,d,f,0])),h+=1<<f}while(h<o);return d=a.readBits(s),c.push(new HuffmanLine([i-1,d,32,0,"lower"])),d=a.readBits(s),c.push(new HuffmanLine([o,d,32,0])),1&r&&(d=a.readBits(s),c.push(new HuffmanLine([d,0]))),new HuffmanTable(c,!1)}const standardTablesCache={};function getStandardTable(e){let t,n=standardTablesCache[e];if(n)return n;switch(e){case 1:t=[[0,1,4,0],[16,2,8,2],[272,3,16,6],[65808,3,32,7]];break;case 2:t=[[0,1,0,0],[1,2,0,2],[2,3,0,6],[3,4,3,14],[11,5,6,30],[75,6,32,62],[6,63]];break;case 3:t=[[-256,8,8,254],[0,1,0,0],[1,2,0,2],[2,3,0,6],[3,4,3,14],[11,5,6,30],[-257,8,32,255,"lower"],[75,7,32,126],[6,62]];break;case 4:t=[[1,1,0,0],[2,2,0,2],[3,3,0,6],[4,4,3,14],[12,5,6,30],[76,5,32,31]];break;case 5:t=[[-255,7,8,126],[1,1,0,0],[2,2,0,2],[3,3,0,6],[4,4,3,14],[12,5,6,30],[-256,7,32,127,"lower"],[76,6,32,62]];break;case 6:t=[[-2048,5,10,28],[-1024,4,9,8],[-512,4,8,9],[-256,4,7,10],[-128,5,6,29],[-64,5,5,30],[-32,4,5,11],[0,2,7,0],[128,3,7,2],[256,3,8,3],[512,4,9,12],[1024,4,10,13],[-2049,6,32,62,"lower"],[2048,6,32,63]];break;case 7:t=[[-1024,4,9,8],[-512,3,8,0],[-256,4,7,9],[-128,5,6,26],[-64,5,5,27],[-32,4,5,10],[0,4,5,11],[32,5,5,28],[64,5,6,29],[128,4,7,12],[256,3,8,1],[512,3,9,2],[1024,3,10,3],[-1025,5,32,30,"lower"],[2048,5,32,31]];break;case 8:t=[[-15,8,3,252],[-7,9,1,508],[-5,8,1,253],[-3,9,0,509],[-2,7,0,124],[-1,4,0,10],[0,2,1,0],[2,5,0,26],[3,6,0,58],[4,3,4,4],[20,6,1,59],[22,4,4,11],[38,4,5,12],[70,5,6,27],[134,5,7,28],[262,6,7,60],[390,7,8,125],[646,6,10,61],[-16,9,32,510,"lower"],[1670,9,32,511],[2,1]];break;case 9:t=[[-31,8,4,252],[-15,9,2,508],[-11,8,2,253],[-7,9,1,509],[-5,7,1,124],[-3,4,1,10],[-1,3,1,2],[1,3,1,3],[3,5,1,26],[5,6,1,58],[7,3,5,4],[39,6,2,59],[43,4,5,11],[75,4,6,12],[139,5,7,27],[267,5,8,28],[523,6,8,60],[779,7,9,125],[1291,6,11,61],[-32,9,32,510,"lower"],[3339,9,32,511],[2,0]];break;case 10:t=[[-21,7,4,122],[-5,8,0,252],[-4,7,0,123],[-3,5,0,24],[-2,2,2,0],[2,5,0,25],[3,6,0,54],[4,7,0,124],[5,8,0,253],[6,2,6,1],[70,5,5,26],[102,6,5,55],[134,6,6,56],[198,6,7,57],[326,6,8,58],[582,6,9,59],[1094,6,10,60],[2118,7,11,125],[-22,8,32,254,"lower"],[4166,8,32,255],[2,2]];break;case 11:t=[[1,1,0,0],[2,2,1,2],[4,4,0,12],[5,4,1,13],[7,5,1,28],[9,5,2,29],[13,6,2,60],[17,7,2,122],[21,7,3,123],[29,7,4,124],[45,7,5,125],[77,7,6,126],[141,7,32,127]];break;case 12:t=[[1,1,0,0],[2,2,0,2],[3,3,1,6],[5,5,0,28],[6,5,1,29],[8,6,1,60],[10,7,0,122],[11,7,1,123],[13,7,2,124],[17,7,3,125],[25,7,4,126],[41,8,5,254],[73,8,32,255]];break;case 13:t=[[1,1,0,0],[2,3,0,4],[3,4,0,12],[4,5,0,28],[5,4,1,13],[7,3,3,5],[15,6,1,58],[17,6,2,59],[21,6,3,60],[29,6,4,61],[45,6,5,62],[77,7,6,126],[141,7,32,127]];break;case 14:t=[[-2,3,0,4],[-1,3,0,5],[0,1,0,0],[1,3,0,6],[2,3,0,7]];break;case 15:t=[[-24,7,4,124],[-8,6,2,60],[-4,5,1,28],[-2,4,0,12],[-1,3,0,4],[0,1,0,0],[1,3,0,5],[2,4,0,13],[3,5,1,29],[5,6,2,61],[9,7,4,125],[-25,7,32,126,"lower"],[25,7,32,127]];break;default:throw new Jbig2Error(`standard table B.${e} does not exist`)}for(let r=0,i=t.length;r<i;r++)t[r]=new HuffmanLine(t[r]);return n=new HuffmanTable(t,!0),standardTablesCache[e]=n,n}class Reader{constructor(e,t,n){this.data=e,this.start=t,this.end=n,this.position=t,this.shift=-1,this.currentByte=0}readBit(){if(this.shift<0){if(this.position>=this.end)throw new Jbig2Error("end of data while reading bit");this.currentByte=this.data[this.position++],this.shift=7}const e=this.currentByte>>this.shift&1;return this.shift--,e}readBits(e){let t,n=0;for(t=e-1;t>=0;t--)n|=this.readBit()<<t;return n}byteAlign(){this.shift=-1}next(){return this.position>=this.end?-1:this.data[this.position++]}}function getCustomHuffmanTable(e,t,n){let r=0;for(let i=0,o=t.length;i<o;i++){const o=n[t[i]];if(o){if(e===r)return o;r++}}throw new Jbig2Error("can't find custom Huffman table")}function getTextRegionHuffmanTables(e,t,n,r,i){const o=[];for(let h=0;h<=34;h++){const e=i.readBits(4);o.push(new HuffmanLine([h,e,0,0]))}const a=new HuffmanTable(o,!1);o.length=0;for(let h=0;h<r;){const e=a.decode(i);if(e>=32){let t,n,r;switch(e){case 32:if(0===h)throw new Jbig2Error("no previous value in symbol ID table");n=i.readBits(2)+3,t=o[h-1].prefixLength;break;case 33:n=i.readBits(3)+3,t=0;break;case 34:n=i.readBits(7)+11,t=0;break;default:throw new Jbig2Error("invalid code length in symbol ID table")}for(r=0;r<n;r++)o.push(new HuffmanLine([h,t,0,0])),h++}else o.push(new HuffmanLine([h,e,0,0])),h++}i.byteAlign();const s=new HuffmanTable(o,!1);let l,c,d,f=0;switch(e.huffmanFS){case 0:case 1:l=getStandardTable(e.huffmanFS+6);break;case 3:l=getCustomHuffmanTable(f,t,n),f++;break;default:throw new Jbig2Error("invalid Huffman FS selector")}switch(e.huffmanDS){case 0:case 1:case 2:c=getStandardTable(e.huffmanDS+8);break;case 3:c=getCustomHuffmanTable(f,t,n),f++;break;default:throw new Jbig2Error("invalid Huffman DS selector")}switch(e.huffmanDT){case 0:case 1:case 2:d=getStandardTable(e.huffmanDT+11);break;case 3:d=getCustomHuffmanTable(f,t,n),f++;break;default:throw new Jbig2Error("invalid Huffman DT selector")}if(e.refinement)throw new Jbig2Error("refinement with Huffman is not supported");return{symbolIDTable:s,tableFirstS:l,tableDeltaS:c,tableDeltaT:d}}function getSymbolDictionaryHuffmanTables(e,t,n){let r,i,o,a,s=0;switch(e.huffmanDHSelector){case 0:case 1:r=getStandardTable(e.huffmanDHSelector+4);break;case 3:r=getCustomHuffmanTable(s,t,n),s++;break;default:throw new Jbig2Error("invalid Huffman DH selector")}switch(e.huffmanDWSelector){case 0:case 1:i=getStandardTable(e.huffmanDWSelector+2);break;case 3:i=getCustomHuffmanTable(s,t,n),s++;break;default:throw new Jbig2Error("invalid Huffman DW selector")}return e.bitmapSizeSelector?(o=getCustomHuffmanTable(s,t,n),s++):o=getStandardTable(1),a=e.aggregationInstancesSelector?getCustomHuffmanTable(s,t,n):getStandardTable(1),{tableDeltaHeight:r,tableDeltaWidth:i,tableBitmapSize:o,tableAggregateInstances:a}}function readUncompressedBitmap(e,t,n){const r=[];for(let i=0;i<n;i++){const n=new Uint8Array(t);r.push(n);for(let r=0;r<t;r++)n[r]=e.readBit();e.byteAlign()}return r}function decodeMMRBitmap(e,t,n,r){const i={K:-1,Columns:t,Rows:n,BlackIs1:!0,EndOfBlock:r},o=new _ccitt.CCITTFaxDecoder(e,i),a=[];let s,l=!1;for(let c=0;c<n;c++){const e=new Uint8Array(t);a.push(e);let n=-1;for(let r=0;r<t;r++)n<0&&(s=o.readNextChar(),-1===s&&(s=0,l=!0),n=7),e[r]=s>>n&1,n--}if(r&&!l){const e=5;for(let t=0;t<e;t++)if(-1===o.readNextChar())break}return a}class Jbig2Image{parseChunks(e){return parseJbig2Chunks(e)}parse(e){const{imgData:t,width:n,height:r}=parseJbig2(e);return this.width=n,this.height=r,t}}exports.Jbig2Image=Jbig2Image;