"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ChunkedStreamManager=exports.ChunkedStream=void 0;var _util=require("../shared/util.js"),_core_utils=require("./core_utils.js"),_stream=require("./stream.js");class ChunkedStream extends _stream.Stream{constructor(e,t,s){super(new Uint8Array(e),0,e,null),this.chunkSize=t,this._loadedChunks=new Set,this.numChunks=Math.ceil(e/t),this.manager=s,this.progressiveDataLength=0,this.lastSuccessfulEnsureByteChunk=-1}getMissingChunks(){const e=[];for(let t=0,s=this.numChunks;t<s;++t)this._loadedChunks.has(t)||e.push(t);return e}get numChunksLoaded(){return this._loadedChunks.size}get isDataLoaded(){return this.numChunksLoaded===this.numChunks}onReceiveData(e,t){const s=this.chunkSize;if(e%s!==0)throw new Error(`Bad begin offset: ${e}`);const n=e+t.byteLength;if(n%s!==0&&n!==this.bytes.length)throw new Error(`Bad end offset: ${n}`);this.bytes.set(new Uint8Array(t),e);const h=Math.floor(e/s),r=Math.floor((n-1)/s)+1;for(let i=h;i<r;++i)this._loadedChunks.add(i)}onReceiveProgressiveData(e){let t=this.progressiveDataLength;const s=Math.floor(t/this.chunkSize);this.bytes.set(new Uint8Array(e),t),t+=e.byteLength,this.progressiveDataLength=t;const n=t>=this.end?this.numChunks:Math.floor(t/this.chunkSize);for(let h=s;h<n;++h)this._loadedChunks.add(h)}ensureByte(e){if(e<this.progressiveDataLength)return;const t=Math.floor(e/this.chunkSize);if(t!==this.lastSuccessfulEnsureByteChunk){if(!this._loadedChunks.has(t))throw new _core_utils.MissingDataException(e,e+1);this.lastSuccessfulEnsureByteChunk=t}}ensureRange(e,t){if(e>=t)return;if(t<=this.progressiveDataLength)return;const s=this.chunkSize,n=Math.floor(e/s),h=Math.floor((t-1)/s)+1;for(let r=n;r<h;++r)if(!this._loadedChunks.has(r))throw new _core_utils.MissingDataException(e,t)}nextEmptyChunk(e){const t=this.numChunks;for(let s=0;s<t;++s){const n=(e+s)%t;if(!this._loadedChunks.has(n))return n}return null}hasChunk(e){return this._loadedChunks.has(e)}getByte(){const e=this.pos;return e>=this.end?-1:(e>=this.progressiveDataLength&&this.ensureByte(e),this.bytes[this.pos++])}getBytes(e,t=!1){const s=this.bytes,n=this.pos,h=this.end;if(!e){h>this.progressiveDataLength&&this.ensureRange(n,h);const e=s.subarray(n,h);return t?new Uint8ClampedArray(e):e}let r=n+e;r>h&&(r=h),r>this.progressiveDataLength&&this.ensureRange(n,r),this.pos=r;const i=s.subarray(n,r);return t?new Uint8ClampedArray(i):i}getByteRange(e,t){return e<0&&(e=0),t>this.end&&(t=this.end),t>this.progressiveDataLength&&this.ensureRange(e,t),this.bytes.subarray(e,t)}makeSubStream(e,t,s=null){function n(){}t?e+t>this.progressiveDataLength&&this.ensureRange(e,e+t):e>=this.progressiveDataLength&&this.ensureByte(e),n.prototype=Object.create(this),n.prototype.getMissingChunks=function(){const e=this.chunkSize,t=Math.floor(this.start/e),s=Math.floor((this.end-1)/e)+1,n=[];for(let h=t;h<s;++h)this._loadedChunks.has(h)||n.push(h);return n},Object.defineProperty(n.prototype,"isDataLoaded",{get(){return this.numChunksLoaded===this.numChunks||0===this.getMissingChunks().length},configurable:!0});const h=new n;return h.pos=h.start=e,h.end=e+t||this.end,h.dict=s,h}getBaseStreams(){return[this]}}exports.ChunkedStream=ChunkedStream;class ChunkedStreamManager{constructor(e,t){this.length=t.length,this.chunkSize=t.rangeChunkSize,this.stream=new ChunkedStream(this.length,this.chunkSize,this),this.pdfNetworkStream=e,this.disableAutoFetch=t.disableAutoFetch,this.msgHandler=t.msgHandler,this.currRequestId=0,this._chunksNeededByRequest=new Map,this._requestsByChunk=new Map,this._promisesByRequest=new Map,this.progressiveDataLength=0,this.aborted=!1,this._loadedStreamCapability=(0,_util.createPromiseCapability)()}onLoadedStream(){return this._loadedStreamCapability.promise}sendRequest(e,t){const s=this.pdfNetworkStream.getRangeReader(e,t);s.isStreamingSupported||(s.onProgress=this.onProgress.bind(this));let n=[],h=0;return new Promise(((e,t)=>{const r=i=>{try{if(!i.done){const e=i.value;return n.push(e),h+=(0,_util.arrayByteLength)(e),s.isStreamingSupported&&this.onProgress({loaded:h}),void s.read().then(r,t)}const a=(0,_util.arraysToBytes)(n);n=null,e(a)}catch(a){t(a)}};s.read().then(r,t)})).then((t=>{this.aborted||this.onReceiveData({chunk:t,begin:e})}))}requestAllChunks(){const e=this.stream.getMissingChunks();return this._requestChunks(e),this._loadedStreamCapability.promise}_requestChunks(e){const t=this.currRequestId++,s=new Set;this._chunksNeededByRequest.set(t,s);for(const r of e)this.stream.hasChunk(r)||s.add(r);if(0===s.size)return Promise.resolve();const n=(0,_util.createPromiseCapability)();this._promisesByRequest.set(t,n);const h=[];for(const r of s){let e=this._requestsByChunk.get(r);e||(e=[],this._requestsByChunk.set(r,e),h.push(r)),e.push(t)}if(h.length>0){const e=this.groupChunks(h);for(const t of e){const e=t.beginChunk*this.chunkSize,s=Math.min(t.endChunk*this.chunkSize,this.length);this.sendRequest(e,s).catch(n.reject)}}return n.promise.catch((e=>{if(!this.aborted)throw e}))}getStream(){return this.stream}requestRange(e,t){t=Math.min(t,this.length);const s=this.getBeginChunk(e),n=this.getEndChunk(t),h=[];for(let r=s;r<n;++r)h.push(r);return this._requestChunks(h)}requestRanges(e=[]){const t=[];for(const s of e){const e=this.getBeginChunk(s.begin),n=this.getEndChunk(s.end);for(let s=e;s<n;++s)t.includes(s)||t.push(s)}return t.sort((function(e,t){return e-t})),this._requestChunks(t)}groupChunks(e){const t=[];let s=-1,n=-1;for(let h=0,r=e.length;h<r;++h){const r=e[h];s<0&&(s=r),n>=0&&n+1!==r&&(t.push({beginChunk:s,endChunk:n+1}),s=r),h+1===e.length&&t.push({beginChunk:s,endChunk:r+1}),n=r}return t}onProgress(e){this.msgHandler.send("DocProgress",{loaded:this.stream.numChunksLoaded*this.chunkSize+e.loaded,total:this.length})}onReceiveData(e){const t=e.chunk,s=void 0===e.begin,n=s?this.progressiveDataLength:e.begin,h=n+t.byteLength,r=Math.floor(n/this.chunkSize),i=h<this.length?Math.floor(h/this.chunkSize):Math.ceil(h/this.chunkSize);s?(this.stream.onReceiveProgressiveData(t),this.progressiveDataLength=h):this.stream.onReceiveData(n,t),this.stream.isDataLoaded&&this._loadedStreamCapability.resolve(this.stream);const a=[];for(let o=r;o<i;++o){const e=this._requestsByChunk.get(o);if(e){this._requestsByChunk.delete(o);for(const t of e){const e=this._chunksNeededByRequest.get(t);e.has(o)&&e.delete(o),e.size>0||a.push(t)}}}if(!this.disableAutoFetch&&0===this._requestsByChunk.size){let e;if(1===this.stream.numChunksLoaded){const t=this.stream.numChunks-1;this.stream.hasChunk(t)||(e=t)}else e=this.stream.nextEmptyChunk(i);Number.isInteger(e)&&this._requestChunks([e])}for(const o of a){const e=this._promisesByRequest.get(o);this._promisesByRequest.delete(o),e.resolve()}this.msgHandler.send("DocProgress",{loaded:this.stream.numChunksLoaded*this.chunkSize,total:this.length})}onError(e){this._loadedStreamCapability.reject(e)}getBeginChunk(e){return Math.floor(e/this.chunkSize)}getEndChunk(e){return Math.floor((e-1)/this.chunkSize)+1}abort(e){this.aborted=!0,this.pdfNetworkStream&&this.pdfNetworkStream.cancelAllRequests(e);for(const t of this._promisesByRequest.values())t.reject(e)}}exports.ChunkedStreamManager=ChunkedStreamManager;