"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Parser=exports.Errors=void 0;var _formcalc_lexer=require("./formcalc_lexer.js");const Errors={assignment:"Invalid token in assignment.",block:"Invalid token in do ... end declaration.",elseif:"Invalid elseif declaration.",for:"Invalid token in for ... endfor declaration.",foreach:"Invalid token in foreach ... endfor declaration.",func:"Invalid token in func declaration.",if:"Invalid token if ... endif declaration.",index:"Invalid token in index.",params:"Invalid token in parameter list.",var:"Invalid token in var declaration.",while:"Invalid token while ... endwhile declaration."};exports.Errors=Errors;const BUILTINS=new Set(["abs","avg","ceil","count","floor","max","min","mod","round","sum","date","date2num","datefmt","isodate2num","isotime2num","localdatefmt","localtimefmt","num2date","num2gmtime","num2time","time","time2num","timefmt","apr","cterm","fv","ipmt","npv","pmt","ppmt","pv","rate","term","choose","exists","hasvalue","oneof","within","at","concat","decode","encode","format","left","len","lower","ltrim","parse","replace","right","rtrim","space","str","stuff","substr","uuid","upper","wordnum","get","post","put","eval","ref","unitvalue","unittype","acos","asin","atan","cos","deg2rad","exp","log","pi","pow","rad2deg","sin","sqrt","tan"]),LTR=!0,RTL=!1,Operators={dot:{id:0,prec:0,assoc:RTL,nargs:0,repr:"."},dotDot:{id:1,prec:0,assoc:RTL,nargs:0,repr:".."},dotHash:{id:2,prec:0,assoc:RTL,nargs:0,repr:".#"},call:{id:1,prec:1,assoc:LTR,nargs:0},minus:{id:4,nargs:1,prec:2,assoc:RTL,repr:"-",op:r=>-r},plus:{id:5,nargs:1,prec:2,assoc:RTL,repr:"+",op:r=>+r},not:{id:6,nargs:1,prec:2,assoc:RTL,repr:"!",op:r=>r?0:1},mul:{id:7,nargs:2,prec:3,assoc:LTR,repr:"*",op:(r,e)=>r*e},div:{id:8,nargs:2,prec:3,assoc:LTR,repr:"/",op:(r,e)=>r/e},add:{id:9,nargs:2,prec:4,assoc:LTR,repr:"+",op:(r,e)=>r+e},sub:{id:10,nargs:2,prec:4,assoc:LTR,repr:"-",op:(r,e)=>r-e},lt:{id:11,nargs:2,prec:5,assoc:LTR,repr:"<",op:(r,e)=>r<e?1:0},le:{id:12,nargs:2,prec:5,assoc:LTR,repr:"<=",op:(r,e)=>r<=e?1:0},gt:{id:13,nargs:2,prec:5,assoc:LTR,repr:">",op:(r,e)=>r>e?1:0},ge:{id:14,nargs:2,prec:5,assoc:LTR,repr:">=",op:(r,e)=>r>=e?1:0},eq:{id:15,nargs:2,prec:6,assoc:LTR,repr:"===",op:(r,e)=>r===e?1:0},ne:{id:16,nargs:2,prec:6,assoc:LTR,repr:"!==",op:(r,e)=>r!==e?1:0},and:{id:17,nargs:2,prec:7,assoc:LTR,repr:"&&",op:(r,e)=>r&&e?1:0},or:{id:18,nargs:2,prec:8,assoc:LTR,repr:"||",op:(r,e)=>r||e?1:0},paren:{id:19,prec:9,assoc:RTL,nargs:0},subscript:{id:20,prec:9,assoc:RTL,nargs:0}},OPERATOR=!0,OPERAND=!1;class SimpleExprParser{constructor(r){this.lexer=r,this.operands=[],this.operators=[],this.last=OPERATOR}reset(){this.operands.length=0,this.operators.length=0,this.last=OPERATOR}parse(r){r=r||this.lexer.next();while(1){switch(r.id){case _formcalc_lexer.TOKEN.and:if(this.last===OPERAND){this.pushOperator(Operators.and);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.divide:if(this.last===OPERAND){this.pushOperator(Operators.div);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.dot:if(this.last===OPERAND){this.pushOperator(Operators.dot);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.dotDot:if(this.last===OPERAND){this.pushOperator(Operators.dotDot);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.dotHash:if(this.last===OPERAND){this.pushOperator(Operators.dotHash);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.dotStar:if(this.last===OPERAND){this.pushOperator(Operators.dot),this.pushOperand(new AstEveryOccurence);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.eq:if(this.last===OPERAND){this.pushOperator(Operators.eq);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.ge:if(this.last===OPERAND){this.pushOperator(Operators.ge);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.gt:if(this.last===OPERAND){this.pushOperator(Operators.gt);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.le:if(this.last===OPERAND){this.pushOperator(Operators.le);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.leftBracket:if(this.last===OPERAND){this.flushWithOperator(Operators.subscript);const r=this.operands.pop(),e=SimpleExprParser.parseIndex(this.lexer);this.operands.push(new AstSubscript(r,e)),this.last=OPERAND;break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.leftParen:if(this.last===OPERAND){const e=this.operands[this.operands.length-1];if(!(e instanceof AstIdentifier))return[r,this.getNode()];e.toLowerCase();const t=e.id;this.flushWithOperator(Operators.call);const s=this.operands.pop(),i=SimpleExprParser.parseParams(this.lexer);s instanceof AstIdentifier&&BUILTINS.has(t)?this.operands.push(new AstBuiltinCall(t,i)):this.operands.push(new AstCall(s,i)),this.last=OPERAND}else this.operators.push(Operators.paren),this.last=OPERATOR;break;case _formcalc_lexer.TOKEN.lt:if(this.last===OPERAND){this.pushOperator(Operators.lt);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.minus:this.last===OPERATOR?this.pushOperator(Operators.minus):this.pushOperator(Operators.sub);break;case _formcalc_lexer.TOKEN.ne:if(this.last===OPERAND){this.pushOperator(Operators.ne);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.not:if(this.last===OPERAND){this.pushOperator(Operators.not);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.null:if(this.last===OPERATOR){this.pushOperand(new AstNull);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.number:if(this.last===OPERATOR){this.pushOperand(new AstNumber(r.value));break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.or:if(this.last===OPERAND){this.pushOperator(Operators.or);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.plus:this.last===OPERATOR?this.pushOperator(Operators.plus):this.pushOperator(Operators.add);break;case _formcalc_lexer.TOKEN.rightBracket:if(!this.flushUntil(Operators.subscript.id))return[r,this.getNode()];break;case _formcalc_lexer.TOKEN.rightParen:if(!this.flushUntil(Operators.paren.id))return[r,this.getNode()];break;case _formcalc_lexer.TOKEN.string:if(this.last===OPERATOR){this.pushOperand(new AstString(r.value));break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.this:if(this.last===OPERATOR){this.pushOperand(new AstThis);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.times:if(this.last===OPERAND){this.pushOperator(Operators.mul);break}return[r,this.getNode()];case _formcalc_lexer.TOKEN.identifier:if(this.last===OPERATOR){this.pushOperand(new AstIdentifier(r.value));break}return[r,this.getNode()];default:return[r,this.getNode()]}r=this.lexer.next()}}static parseParams(r){const e=new SimpleExprParser(r),t=[];while(1){const[r,s]=e.parse();if(s&&t.push(s),r.id===_formcalc_lexer.TOKEN.rightParen)return t;if(r.id!==_formcalc_lexer.TOKEN.comma)throw new Error(Errors.params);e.reset()}}static parseIndex(r){let e=r.next();if(e.id===_formcalc_lexer.TOKEN.times){if(e=r.next(),e.id!==_formcalc_lexer.TOKEN.rightBracket)throw new Error(Errors.index);return new AstEveryOccurence}const[t,s]=new SimpleExprParser(r).parse(e);if(t.id!==_formcalc_lexer.TOKEN.rightBracket)throw new Error(Errors.index);return s}pushOperator(r){this.flushWithOperator(r),this.operators.push(r),this.last=OPERATOR}pushOperand(r){this.operands.push(r),this.last=OPERAND}operate(r){if(1===r.nargs){const e=this.operands.pop();this.operands.push(AstUnaryOperator.getOperatorOrValue(r,e))}else{const e=this.operands.pop(),t=this.operands.pop();this.operands.push(AstBinaryOperator.getOperatorOrValue(r,t,e))}}flushWithOperator(r){while(1){const e=this.operators[this.operators.length-1];if(!(e&&e.id>=0&&SimpleExprParser.checkPrecedence(e,r)))return;this.operators.pop(),this.operate(e)}}flush(){while(1){const r=this.operators.pop();if(!r)return;this.operate(r)}}flushUntil(r){while(1){const e=this.operators.pop();if(!e)return!1;if(e.id===r)return!0;this.operate(e)}}getNode(){return this.flush(),this.operands.pop()}static checkPrecedence(r,e){return r.prec<e.prec||r.prec===e.prec&&r.assoc===LTR}}class Leaf{dump(){throw new Error("Not implemented method")}isSomPredicate(){return!1}isDotExpression(){return!1}isConstant(){return!1}toNumber(){return 0}toComparable(){return null}}class AstCall extends Leaf{constructor(r,e){super(),this.callee=r,this.params=e}dump(){return{callee:this.callee.dump(),params:this.params.map((r=>r.dump()))}}}class AstBuiltinCall extends Leaf{constructor(r,e){super(),this.id=r,this.params=e}dump(){return{builtin:this.id,params:this.params.map((r=>r.dump()))}}}class AstSubscript extends Leaf{constructor(r,e){super(),this.operand=r,this.index=e}dump(){return{operand:this.operand.dump(),index:this.index.dump()}}}class AstBinaryOperator extends Leaf{constructor(r,e,t,s){super(),this.id=r,this.left=e,this.right=t,this.repr=s}dump(){return{operator:this.repr,left:this.left.dump(),right:this.right.dump()}}isDotExpression(){return Operators.id.dot<=this.id&&this.id<=Operators.id.dotHash}isSomPredicate(){return this.isDotExpression()||Operators.id.lt<=this.id&&this.id<=Operators.id.or&&(this.left.isDotExpression()&&this.right.isConstant()||this.left.isConstant()&&this.right.isDotExpression()||this.left.isDotExpression()&&this.right.isDotExpression())}static getOperatorOrValue(r,e,t){return e.isConstant()&&t.isConstant()?!(Operators.lt.id<=r.id&&r.id<=Operators.ne.id)||e instanceof AstNumber||t instanceof AstNumber?new AstNumber(r.op(e.toNumber(),t.toNumber())):new AstNumber(r.op(e.toComparable(),t.toComparable())):new AstBinaryOperator(r.id,e,t,r.repr)}}class AstUnaryOperator extends Leaf{constructor(r,e,t){super(),this.id=r,this.arg=e,this.repr=t}dump(){return{operator:this.repr,arg:this.arg.dump()}}static getOperatorOrValue(r,e){return e.isConstant()?new AstNumber(r.op(e.toNumber())):new AstUnaryOperator(r.id,e,r.repr)}}class AstNumber extends Leaf{constructor(r){super(),this.number=r}dump(){return this.number}isConstant(){return!0}toNumber(){return this.number}}class AstString extends Leaf{constructor(r){super(),this.str=r}dump(){return this.str}isConstant(){return!0}toNumber(){return isNaN(this.str)?0:parseFloat(this.str)}toComparable(){return this.str}}class AstThis extends Leaf{dump(){return{special:"this"}}}class AstIdentifier extends Leaf{constructor(r){super(),this.id=r}dump(){return{id:this.id}}toLowerCase(){this.id=this.id.toLowerCase()}}class AstNull extends Leaf{dump(){return{special:null}}isConstant(){return!0}toComparable(){return null}}class AstEveryOccurence{dump(){return{special:"*"}}}class VarDecl extends Leaf{constructor(r,e){super(),this.id=r,this.expr=e}dump(){return{var:this.id,expr:this.expr.dump()}}}class Assignment extends Leaf{constructor(r,e){super(),this.id=r,this.expr=e}dump(){return{assignment:this.id,expr:this.expr.dump()}}}class FuncDecl extends Leaf{constructor(r,e,t){super(),this.id=r,this.params=e,this.body=t}dump(){return{func:this.id,params:this.params,body:this.body.dump()}}}class IfDecl extends Leaf{constructor(r,e,t,s){super(),this.condition=r,this.then=e,this.elseif=t,this.else=s}dump(){return{decl:"if",condition:this.condition.dump(),then:this.then.dump(),elseif:this.elseif?this.elseif.map((r=>r.dump())):null,else:this.else?this.else.dump():null}}}class ElseIfDecl extends Leaf{constructor(r,e){super(),this.condition=r,this.then=e}dump(){return{decl:"elseif",condition:this.condition.dump(),then:this.then.dump()}}}class WhileDecl extends Leaf{constructor(r,e){super(),this.condition=r,this.body=e}dump(){return{decl:"while",condition:this.condition.dump(),body:this.body.dump()}}}class ForDecl extends Leaf{constructor(r,e,t,s,i){super(),this.assignment=r,this.upto=e,this.end=t,this.step=s,this.body=i}dump(){return{decl:"for",assignment:this.assignment.dump(),type:this.upto?"upto":"downto",end:this.end.dump(),step:this.step?this.step.dump():null,body:this.body.dump()}}}class ForeachDecl extends Leaf{constructor(r,e,t){super(),this.id=r,this.params=e,this.body=t}dump(){return{decl:"foreach",id:this.id,params:this.params.map((r=>r.dump())),body:this.body.dump()}}}class BlockDecl extends Leaf{constructor(r){super(),this.body=r}dump(){return{decl:"block",body:this.body.dump()}}}class ExprList extends Leaf{constructor(r){super(),this.expressions=r}dump(){return this.expressions.map((r=>r.dump()))}}class BreakDecl extends Leaf{dump(){return{special:"break"}}}class ContinueDecl extends Leaf{dump(){return{special:"continue"}}}class Parser{constructor(r){this.lexer=new _formcalc_lexer.Lexer(r)}parse(){const[r,e]=this.parseExprList();if(r.id!==_formcalc_lexer.TOKEN.eof)throw new Error("Invalid token in Form code");return e}parseExprList(){const r=[];let e,t=null;while(1){if([t,e]=this.parseExpr(t),!e)return[t,new ExprList(r)];r.push(e)}}parseExpr(r){switch(r=r||this.lexer.next(),r.id){case _formcalc_lexer.TOKEN.identifier:return this.parseAssigmentOrExpr(r);case _formcalc_lexer.TOKEN.break:return[null,new BreakDecl];case _formcalc_lexer.TOKEN.continue:return[null,new ContinueDecl];case _formcalc_lexer.TOKEN.do:return this.parseBlock();case _formcalc_lexer.TOKEN.for:return this.parseFor();case _formcalc_lexer.TOKEN.foreach:return this.parseForeach();case _formcalc_lexer.TOKEN.func:return this.parseFuncDecl();case _formcalc_lexer.TOKEN.if:return this.parseIf();case _formcalc_lexer.TOKEN.var:return this.parseVarDecl();case _formcalc_lexer.TOKEN.while:return this.parseWhile();default:return this.parseSimpleExpr(r)}}parseAssigmentOrExpr(r){const e=r;if(r=this.lexer.next(),r.id===_formcalc_lexer.TOKEN.assign){const[r,t]=this.parseSimpleExpr(null);return[r,new Assignment(e.value,t)]}const t=new SimpleExprParser(this.lexer);return t.pushOperand(new AstIdentifier(e.value)),t.parse(r)}parseBlock(){const[r,e]=this.parseExprList(),t=r||this.lexer.next();if(t.id!==_formcalc_lexer.TOKEN.end)throw new Error(Errors.block);return[null,new BlockDecl(e)]}parseVarDecl(){let r=this.lexer.next();if(r.id!==_formcalc_lexer.TOKEN.identifier)throw new Error(Errors.var);const e=r.value;if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.assign)return[r,new VarDecl(e,null)];const[t,s]=this.parseSimpleExpr();return[t,new VarDecl(e,s)]}parseFuncDecl(){let r=this.lexer.next();if(r.id!==_formcalc_lexer.TOKEN.identifier)throw new Error(Errors.func);const e=r.value,t=this.parseParamList();if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.do)throw new Error(Errors.func);const[s,i]=this.parseExprList();if(r=s||this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.endfunc)throw new Error(Errors.func);return[null,new FuncDecl(e,t,i)]}parseParamList(){const r=[];let e=this.lexer.next();if(e.id!==_formcalc_lexer.TOKEN.leftParen)throw new Error(Errors.func);if(e=this.lexer.next(),e.id===_formcalc_lexer.TOKEN.rightParen)return r;while(1){if(e.id!==_formcalc_lexer.TOKEN.identifier)throw new Error(Errors.func);if(r.push(e.value),e=this.lexer.next(),e.id===_formcalc_lexer.TOKEN.rightParen)return r;if(e.id!==_formcalc_lexer.TOKEN.comma)throw new Error(Errors.func);e=this.lexer.next()}}parseSimpleExpr(r=null){return new SimpleExprParser(this.lexer).parse(r)}parseIf(){let r=[],e=this.lexer.next();if(e.id!==_formcalc_lexer.TOKEN.leftParen)throw new Error(Errors.if);const[t,s]=this.parseSimpleExpr();if(e=t||this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.rightParen)throw new Error(Errors.if);if(e=this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.then)throw new Error(Errors.if);const[i,a]=this.parseExprList();e=i||this.lexer.next();while(e.id===_formcalc_lexer.TOKEN.elseif){if(e=this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.leftParen)throw new Error(Errors.elseif);const[t,s]=this.parseSimpleExpr();if(e=t||this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.rightParen)throw new Error(Errors.elseif);if(e=this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.then)throw new Error(Errors.elseif);const[i,a]=this.parseExprList();r.push(new ElseIfDecl(s,a)),e=i||this.lexer.next()}if(0===r.length&&(r=null),e.id===_formcalc_lexer.TOKEN.endif)return[null,new IfDecl(s,a,r,null)];if(e.id!==_formcalc_lexer.TOKEN.else)throw new Error(Errors.if);const[o,n]=this.parseExprList();if(e=o||this.lexer.next(),e.id!==_formcalc_lexer.TOKEN.endif)throw new Error(Errors.if);return[null,new IfDecl(s,a,r,n)]}parseWhile(){let r=this.lexer.next();if(r.id!==_formcalc_lexer.TOKEN.leftParen)throw new Error(Errors.while);const[e,t]=this.parseSimpleExpr();if(r=e||this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.rightParen)throw new Error(Errors.while);if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.do)throw new Error(Errors.while);const[s,i]=this.parseExprList();if(r=s||this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.endwhile)throw new Error(Errors.while);return[null,new WhileDecl(t,i)]}parseAssignment(){let r=this.lexer.next(),e=!1;if(r.id===_formcalc_lexer.TOKEN.var&&(e=!0,r=this.lexer.next()),r.id!==_formcalc_lexer.TOKEN.identifier)throw new Error(Errors.assignment);const t=r.value;if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.assign)throw new Error(Errors.assignment);const[s,i]=this.parseSimpleExpr();return e?[s,new VarDecl(t,i)]:[s,new Assignment(t,i)]}parseFor(){let r,e=null,t=!1;const[s,i]=this.parseAssignment();if(r=s||this.lexer.next(),r.id===_formcalc_lexer.TOKEN.upto)t=!0;else if(r.id!==_formcalc_lexer.TOKEN.downto)throw new Error(Errors.for);const[a,o]=this.parseSimpleExpr();if(r=a||this.lexer.next(),r.id===_formcalc_lexer.TOKEN.step&&([r,e]=this.parseSimpleExpr(),r=r||this.lexer.next()),r.id!==_formcalc_lexer.TOKEN.do)throw new Error(Errors.for);const[n,l]=this.parseExprList();if(r=n||this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.endfor)throw new Error(Errors.for);return[null,new ForDecl(i,t,o,e,l)]}parseForeach(){let r=this.lexer.next();if(r.id!==_formcalc_lexer.TOKEN.identifier)throw new Error(Errors.foreach);const e=r.value;if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.in)throw new Error(Errors.foreach);if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.leftParen)throw new Error(Errors.foreach);const t=SimpleExprParser.parseParams(this.lexer);if(r=this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.do)throw new Error(Errors.foreach);const[s,i]=this.parseExprList();if(r=s||this.lexer.next(),r.id!==_formcalc_lexer.TOKEN.endfor)throw new Error(Errors.foreach);return[null,new ForeachDecl(e,t,i)]}}exports.Parser=Parser;