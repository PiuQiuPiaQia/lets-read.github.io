"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PartialEvaluator=exports.EvaluatorPreprocessor=void 0;var _util=require("../shared/util.js"),_cmap=require("./cmap.js"),_primitives=require("./primitives.js"),_fonts=require("./fonts.js"),_fonts_utils=require("./fonts_utils.js"),_encodings=require("./encodings.js"),_standard_fonts=require("./standard_fonts.js"),_unicode=require("./unicode.js"),_pattern=require("./pattern.js"),_xfa_fonts=require("./xfa_fonts.js"),_to_unicode_map=require("./to_unicode_map.js"),_function=require("./function.js"),_parser=require("./parser.js"),_image_utils=require("./image_utils.js"),_stream=require("./stream.js"),_bidi=require("./bidi.js"),_colorspace=require("./colorspace.js"),_decode_stream=require("./decode_stream.js"),_glyphlist=require("./glyphlist.js"),_core_utils=require("./core_utils.js"),_metrics=require("./metrics.js"),_murmurhash=require("./murmurhash3.js"),_operator_list=require("./operator_list.js"),_image=require("./image.js");const DefaultPartialEvaluatorOptions=Object.freeze({maxImageSize:-1,disableFontFace:!1,ignoreErrors:!1,isEvalSupported:!0,fontExtraProperties:!1,useSystemFonts:!0,cMapUrl:null,standardFontDataUrl:null}),PatternType={TILING:1,SHADING:2},TEXT_CHUNK_BATCH_SIZE=10,deferred=Promise.resolve();function normalizeBlendMode(t,e=!1){if(Array.isArray(t)){for(let e=0,i=t.length;e<i;e++){const i=normalizeBlendMode(t[e],!0);if(i)return i}return(0,_util.warn)(`Unsupported blend mode Array: ${t}`),"source-over"}if(!(0,_primitives.isName)(t))return e?null:"source-over";switch(t.name){case"Normal":case"Compatible":return"source-over";case"Multiply":return"multiply";case"Screen":return"screen";case"Overlay":return"overlay";case"Darken":return"darken";case"Lighten":return"lighten";case"ColorDodge":return"color-dodge";case"ColorBurn":return"color-burn";case"HardLight":return"hard-light";case"SoftLight":return"soft-light";case"Difference":return"difference";case"Exclusion":return"exclusion";case"Hue":return"hue";case"Saturation":return"saturation";case"Color":return"color";case"Luminosity":return"luminosity"}return e?null:((0,_util.warn)(`Unsupported blend mode: ${t.name}`),"source-over")}class TimeSlotManager{static get TIME_SLOT_DURATION_MS(){return(0,_util.shadow)(this,"TIME_SLOT_DURATION_MS",20)}static get CHECK_TIME_EVERY(){return(0,_util.shadow)(this,"CHECK_TIME_EVERY",100)}constructor(){this.reset()}check(){return!(++this.checked<TimeSlotManager.CHECK_TIME_EVERY)&&(this.checked=0,this.endTime<=Date.now())}reset(){this.endTime=Date.now()+TimeSlotManager.TIME_SLOT_DURATION_MS,this.checked=0}}class PartialEvaluator{constructor({xref:t,handler:e,pageIndex:i,idFactory:r,fontCache:a,builtInCMapCache:n,standardFontDataCache:s,globalImageCache:o,options:l=null}){this.xref=t,this.handler=e,this.pageIndex=i,this.idFactory=r,this.fontCache=a,this.builtInCMapCache=n,this.standardFontDataCache=s,this.globalImageCache=o,this.options=l||DefaultPartialEvaluatorOptions,this.parsingType3Font=!1,this._fetchBuiltInCMapBound=this.fetchBuiltInCMap.bind(this)}get _pdfFunctionFactory(){const t=new _function.PDFFunctionFactory({xref:this.xref,isEvalSupported:this.options.isEvalSupported});return(0,_util.shadow)(this,"_pdfFunctionFactory",t)}clone(t=null){const e=Object.create(this);return e.options=Object.assign(Object.create(null),this.options,t),e}hasBlendModes(t,e){if(!(t instanceof _primitives.Dict))return!1;if(t.objId&&e.has(t.objId))return!1;const i=new _primitives.RefSet(e);t.objId&&i.put(t.objId);const r=[t],a=this.xref;while(r.length){const t=r.shift(),e=t.get("ExtGState");if(e instanceof _primitives.Dict)for(let r of e.getRawValues()){if(r instanceof _primitives.Ref){if(i.has(r))continue;try{r=a.fetch(r)}catch(n){i.put(r),(0,_util.info)(`hasBlendModes - ignoring ExtGState: "${n}".`);continue}}if(!(r instanceof _primitives.Dict))continue;r.objId&&i.put(r.objId);const t=r.get("BM");if(t instanceof _primitives.Name){if("Normal"!==t.name)return!0}else if(void 0!==t&&Array.isArray(t))for(const e of t)if(e instanceof _primitives.Name&&"Normal"!==e.name)return!0}const s=t.get("XObject");if(s instanceof _primitives.Dict)for(let o of s.getRawValues()){if(o instanceof _primitives.Ref){if(i.has(o))continue;try{o=a.fetch(o)}catch(n){i.put(o),(0,_util.info)(`hasBlendModes - ignoring XObject: "${n}".`);continue}}if(!(0,_primitives.isStream)(o))continue;o.dict.objId&&i.put(o.dict.objId);const t=o.dict.get("Resources");t instanceof _primitives.Dict&&(t.objId&&i.has(t.objId)||(r.push(t),t.objId&&i.put(t.objId)))}}return i.forEach((t=>{e.put(t)})),!1}async fetchBuiltInCMap(t){const e=this.builtInCMapCache.get(t);if(e)return e;let i;if(null!==this.options.cMapUrl){const e=`${this.options.cMapUrl}${t}.bcmap`,r=await fetch(e);if(!r.ok)throw new Error(`fetchBuiltInCMap: failed to fetch file "${e}" with "${r.statusText}".`);i={cMapData:new Uint8Array(await r.arrayBuffer()),compressionType:_util.CMapCompressionType.BINARY}}else i=await this.handler.sendWithPromise("FetchBuiltInCMap",{name:t});return i.compressionType!==_util.CMapCompressionType.NONE&&this.builtInCMapCache.set(t,i),i}async fetchStandardFontData(t){const e=this.standardFontDataCache.get(t);if(e)return new _stream.Stream(e);if(this.options.useSystemFonts&&"Symbol"!==t&&"ZapfDingbats"!==t)return null;const i=(0,_standard_fonts.getFontNameToFileMap)(),r=i[t];let a;if(null!==this.options.standardFontDataUrl){const t=`${this.options.standardFontDataUrl}${r}`,e=await fetch(t);e.ok?a=await e.arrayBuffer():(0,_util.warn)(`fetchStandardFontData: failed to fetch file "${t}" with "${e.statusText}".`)}else try{a=await this.handler.sendWithPromise("FetchStandardFontData",{filename:r})}catch(n){(0,_util.warn)(`fetchStandardFontData: failed to fetch file "${r}" with "${n}".`)}return a?(this.standardFontDataCache.set(t,a),new _stream.Stream(a)):null}async buildFormXObject(t,e,i,r,a,n,s){const o=e.dict,l=o.getArray("Matrix");let c,u,d=o.getArray("BBox");d=Array.isArray(d)&&4===d.length?_util.Util.normalizeRect(d):null,o.has("OC")&&(c=await this.parseMarkedContentProps(o.get("OC"),t)),void 0!==c&&r.addOp(_util.OPS.beginMarkedContentProps,["OC",c]);const h=o.get("Group");if(h){u={matrix:l,bbox:d,smask:i,isolated:!1,knockout:!1};const e=h.get("S");let a=null;if((0,_primitives.isName)(e,"Transparency")&&(u.isolated=h.get("I")||!1,u.knockout=h.get("K")||!1,h.has("CS"))){const e=h.getRaw("CS"),i=_colorspace.ColorSpace.getCached(e,this.xref,s);a=i||await this.parseColorSpace({cs:e,resources:t,localColorSpaceCache:s})}i&&i.backdrop&&(a=a||_colorspace.ColorSpace.singletons.rgb,i.backdrop=a.getRgb(i.backdrop,0)),r.addOp(_util.OPS.beginGroup,[u])}return r.addOp(_util.OPS.paintFormXObjectBegin,[l,d]),this.getOperatorList({stream:e,task:a,resources:o.get("Resources")||t,operatorList:r,initialState:n}).then((function(){r.addOp(_util.OPS.paintFormXObjectEnd,[]),h&&r.addOp(_util.OPS.endGroup,[u]),void 0!==c&&r.addOp(_util.OPS.endMarkedContent,[])}))}_sendImgData(t,e,i=!1){const r=e?[e.data.buffer]:null;return this.parsingType3Font||i?this.handler.send("commonobj",[t,"Image",e],r):this.handler.send("obj",[t,this.pageIndex,"Image",e],r)}async buildPaintImageXObject({resources:t,image:e,isInline:i=!1,operatorList:r,cacheKey:a,localImageCache:n,localColorSpaceCache:s}){const o=e.dict,l=o.objId,c=o.get("Width","W"),u=o.get("Height","H");if(!c||!(0,_util.isNum)(c)||!u||!(0,_util.isNum)(u))return void(0,_util.warn)("Image dimensions are missing, or not numbers.");const d=this.options.maxImageSize;if(-1!==d&&c*u>d)return void(0,_util.warn)("Image exceeded maximum allowed size and was removed.");let h;o.has("OC")&&(h=await this.parseMarkedContentProps(o.get("OC"),t)),void 0!==h&&r.addOp(_util.OPS.beginMarkedContentProps,["OC",h]);const g=o.get("ImageMask","IM")||!1,f=o.get("Interpolate","I");let p,m;if(g){const t=o.get("Width","W"),i=o.get("Height","H"),s=t+7>>3,c=e.getBytes(s*i,!0),u=o.getArray("Decode","D");return p=_image.PDFImage.createMask({imgArray:c,width:t,height:i,imageIsFromDecodeStream:e instanceof _decode_stream.DecodeStream,inverseDecode:!!u&&u[0]>0,interpolate:f}),p.cached=!!a,m=[p],r.addOp(_util.OPS.paintImageMaskXObject,m),a&&n.set(a,l,{fn:_util.OPS.paintImageMaskXObject,args:m}),void(void 0!==h&&r.addOp(_util.OPS.endMarkedContent,[]))}const _=o.get("SMask","SM")||!1,S=o.get("Mask")||!1,b=200;if(i&&!_&&!S&&c+u<b){const a=new _image.PDFImage({xref:this.xref,res:t,image:e,isInline:i,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:s});return p=a.createImageData(!0),r.addOp(_util.OPS.paintInlineImageXObject,[p]),void(void 0!==h&&r.addOp(_util.OPS.endMarkedContent,[]))}let v=`img_${this.idFactory.createObjId()}`,C=!1;this.parsingType3Font?v=`${this.idFactory.getDocId()}_type3_${v}`:l&&(C=this.globalImageCache.shouldCache(l,this.pageIndex),C&&(v=`${this.idFactory.getDocId()}_${v}`)),r.addDependency(v),m=[v,c,u],_image.PDFImage.buildImage({xref:this.xref,res:t,image:e,isInline:i,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:s}).then((t=>(p=t.createImageData(!1),a&&l&&C&&this.globalImageCache.addByteSize(l,p.data.length),this._sendImgData(v,p,C)))).catch((t=>((0,_util.warn)(`Unable to decode image "${v}": "${t}".`),this._sendImgData(v,null,C)))),r.addOp(_util.OPS.paintImageXObject,m),a&&(n.set(a,l,{fn:_util.OPS.paintImageXObject,args:m}),l&&((0,_util.assert)(!i,"Cannot cache an inline image globally."),this.globalImageCache.addPageIndex(l,this.pageIndex),C&&this.globalImageCache.setData(l,{objId:v,fn:_util.OPS.paintImageXObject,args:m,byteSize:0}))),void 0!==h&&r.addOp(_util.OPS.endMarkedContent,[])}handleSMask(t,e,i,r,a,n){const s=t.get("G"),o={subtype:t.get("S").name,backdrop:t.get("BC")},l=t.get("TR");if((0,_function.isPDFFunction)(l)){const t=this._pdfFunctionFactory.create(l),e=new Uint8Array(256),i=new Float32Array(1);for(let r=0;r<256;r++)i[0]=r/255,t(i,0,i,0),e[r]=255*i[0]|0;o.transferMap=e}return this.buildFormXObject(e,s,o,i,r,a.state.clone(),n)}handleTransferFunction(t){let e;if(Array.isArray(t))e=t;else{if(!(0,_function.isPDFFunction)(t))return null;e=[t]}const i=[];let r=0,a=0;for(const n of e){const t=this.xref.fetchIfRef(n);if(r++,(0,_primitives.isName)(t,"Identity")){i.push(null);continue}if(!(0,_function.isPDFFunction)(t))return null;const e=this._pdfFunctionFactory.create(t),s=new Uint8Array(256),o=new Float32Array(1);for(let i=0;i<256;i++)o[0]=i/255,e(o,0,o,0),s[i]=255*o[0]|0;i.push(s),a++}return 1!==r&&4!==r||0===a?null:i}handleTilingType(t,e,i,r,a,n,s,o){const l=new _operator_list.OperatorList,c=_primitives.Dict.merge({xref:this.xref,dictArray:[a.get("Resources"),i]});return this.getOperatorList({stream:r,task:s,resources:c,operatorList:l}).then((function(){const i=l.getIR(),r=(0,_pattern.getTilingPatternIR)(i,a,e);n.addDependencies(l.dependencies),n.addOp(t,r),a.objId&&o.set(null,a.objId,{operatorListIR:i,dict:a})})).catch((t=>{if(!(t instanceof _util.AbortException)){if(this.options.ignoreErrors)return this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorTilingPattern}),void(0,_util.warn)(`handleTilingType - ignoring pattern: "${t}".`);throw t}}))}handleSetFont(t,e,i,r,a,n,s=null,o=null){const l=e&&e[0]instanceof _primitives.Name?e[0].name:null;return this.loadFont(l,i,t,s,o).then((e=>e.font.isType3Font?e.loadType3Data(this,t,a).then((function(){return r.addDependencies(e.type3Dependencies),e})).catch((t=>(this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontLoadType3}),new TranslatedFont({loadedName:"g_font_error",font:new _fonts.ErrorFont(`Type3 font load error: ${t}`),dict:e.font,evaluatorOptions:this.options})))):e)).then((t=>(n.font=t.font,t.send(this.handler),t.loadedName)))}handleText(t,e){const i=e.font,r=i.charsToGlyphs(t);if(i.data){const t=!!(e.textRenderingMode&_util.TextRenderingMode.ADD_TO_PATH_FLAG);(t||"Pattern"===e.fillColorSpace.name||i.disableFontFace||this.options.disableFontFace)&&PartialEvaluator.buildFontPaths(i,r,this.handler,this.options)}return r}ensureStateFont(t){if(t.font)return;const e=new _util.FormatError("Missing setFont (Tf) operator before text rendering operator.");if(this.options.ignoreErrors)return this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontState}),void(0,_util.warn)(`ensureStateFont: "${e}".`);throw e}async setGState({resources:t,gState:e,operatorList:i,cacheKey:r,task:a,stateManager:n,localGStateCache:s,localColorSpaceCache:o}){const l=e.objId;let c=!0;const u=[],d=e.getKeys();let h=Promise.resolve();for(let g=0,f=d.length;g<f;g++){const r=d[g],s=e.get(r);switch(r){case"Type":break;case"LW":case"LC":case"LJ":case"ML":case"D":case"RI":case"FL":case"CA":case"ca":u.push([r,s]);break;case"Font":c=!1,h=h.then((()=>this.handleSetFont(t,null,s[0],i,a,n.state).then((function(t){i.addDependency(t),u.push([r,[t,s[1]]])}))));break;case"BM":u.push([r,normalizeBlendMode(s)]);break;case"SMask":if((0,_primitives.isName)(s,"None")){u.push([r,!1]);break}(0,_primitives.isDict)(s)?(c=!1,h=h.then((()=>this.handleSMask(s,t,i,a,n,o))),u.push([r,!0])):(0,_util.warn)("Unsupported SMask type");break;case"TR":const e=this.handleTransferFunction(s);u.push([r,e]);break;case"OP":case"op":case"OPM":case"BG":case"BG2":case"UCR":case"UCR2":case"TR2":case"HT":case"SM":case"SA":case"AIS":case"TK":(0,_util.info)("graphic state operator "+r);break;default:(0,_util.info)("Unknown graphic state operator "+r);break}}return h.then((function(){u.length>0&&i.addOp(_util.OPS.setGState,[u]),c&&s.set(r,l,u)}))}loadFont(t,e,i,r=null,a=null){const n=async()=>new TranslatedFont({loadedName:"g_font_error",font:new _fonts.ErrorFont(`Font "${t}" is not available.`),dict:e,evaluatorOptions:this.options}),s=this.xref;let o;if(e){if(!(0,_primitives.isRef)(e))throw new _util.FormatError('The "font" object should be a reference.');o=e}else{const e=i.get("Font");e&&(o=e.getRaw(t))}if(!o){const i=`Font "${t||e&&e.toString()}" is not available`;if(!this.options.ignoreErrors&&!this.parsingType3Font)return(0,_util.warn)(`${i}.`),n();this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontMissing}),(0,_util.warn)(`${i} -- attempting to fallback to a default font.`),o=r||PartialEvaluator.fallbackFontDict}if(this.fontCache.has(o))return this.fontCache.get(o);if(e=s.fetchIfRef(o),!(0,_primitives.isDict)(e))return n();if(e.cacheKey&&this.fontCache.has(e.cacheKey))return this.fontCache.get(e.cacheKey);const l=(0,_util.createPromiseCapability)();let c;try{c=this.preEvaluateFont(e),c.cssFontInfo=a}catch(f){return(0,_util.warn)(`loadFont - preEvaluateFont failed: "${f}".`),n()}const{descriptor:u,hash:d}=c,h=(0,_primitives.isRef)(o);let g;if(h&&(g=`f${o.toString()}`),d&&(0,_primitives.isDict)(u)){u.fontAliases||(u.fontAliases=Object.create(null));const t=u.fontAliases;if(t[d]){const e=t[d].aliasRef;if(h&&e&&this.fontCache.has(e))return this.fontCache.putAlias(o,e),this.fontCache.get(o)}else t[d]={fontID:this.idFactory.createFontId()};h&&(t[d].aliasRef=o),g=t[d].fontID}return h?this.fontCache.put(o,l.promise):(g||(g=this.idFactory.createFontId()),e.cacheKey=`cacheKey_${g}`,this.fontCache.put(e.cacheKey,l.promise)),(0,_util.assert)(g&&g.startsWith("f"),'The "fontID" must be (correctly) defined.'),e.loadedName=`${this.idFactory.getDocId()}_${g}`,this.translateFont(c).then((t=>{if(void 0!==t.fontType){const e=s.stats.fontTypes;e[t.fontType]=!0}l.resolve(new TranslatedFont({loadedName:e.loadedName,font:t,dict:e,evaluatorOptions:this.options}))})).catch((t=>{this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontTranslate}),(0,_util.warn)(`loadFont - translateFont failed: "${t}".`);try{const t=u&&u.get("FontFile3"),e=t&&t.get("Subtype"),i=(0,_fonts_utils.getFontType)(c.type,e&&e.name),r=s.stats.fontTypes;r[i]=!0}catch(i){}l.resolve(new TranslatedFont({loadedName:e.loadedName,font:new _fonts.ErrorFont(t instanceof Error?t.message:t),dict:e,evaluatorOptions:this.options}))})),l.promise}buildPath(t,e,i,r=!1){const a=t.length-1;if(i||(i=[]),a<0||t.fnArray[a]!==_util.OPS.constructPath)r&&((0,_util.warn)(`Encountered path operator "${e}" inside of a text object.`),t.addOp(_util.OPS.save,null)),t.addOp(_util.OPS.constructPath,[[e],i]),r&&t.addOp(_util.OPS.restore,null);else{const r=t.argsArray[a];r[0].push(e),Array.prototype.push.apply(r[1],i)}}parseColorSpace({cs:t,resources:e,localColorSpaceCache:i}){return _colorspace.ColorSpace.parseAsync({cs:t,xref:this.xref,resources:e,pdfFunctionFactory:this._pdfFunctionFactory,localColorSpaceCache:i}).catch((t=>{if(t instanceof _util.AbortException)return null;if(this.options.ignoreErrors)return this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorColorSpace}),(0,_util.warn)(`parseColorSpace - ignoring ColorSpace: "${t}".`),null;throw t}))}parseShading({shading:t,resources:e,localColorSpaceCache:i,localShadingPatternCache:r}){let a=r.get(t);if(!a){var n=_pattern.Pattern.parseShading(t,this.xref,e,this.handler,this._pdfFunctionFactory,i);const s=n.getIR();a=`pattern_${this.idFactory.createObjId()}`,r.set(t,a),this.handler.send("obj",[a,this.pageIndex,"Pattern",s])}return a}handleColorN(t,e,i,r,a,n,s,o,l,c){const u=i.pop();if(u instanceof _primitives.Name){const h=a.getRaw(u.name),g=h instanceof _primitives.Ref&&l.getByRef(h);if(g)try{const a=r.base?r.base.getRgb(i,0):null,n=(0,_pattern.getTilingPatternIR)(g.operatorListIR,g.dict,a);return void t.addOp(e,n)}catch(d){}const f=this.xref.fetchIfRef(h);if(f){const a=(0,_primitives.isStream)(f)?f.dict:f,u=a.get("PatternType");if(u===PatternType.TILING){const o=r.base?r.base.getRgb(i,0):null;return this.handleTilingType(e,o,n,f,a,t,s,l)}if(u===PatternType.SHADING){const i=a.get("Shading"),r=a.getArray("Matrix"),s=this.parseShading({shading:i,resources:n,localColorSpaceCache:o,localShadingPatternCache:c});return void t.addOp(e,["Shading",s,r])}throw new _util.FormatError(`Unknown PatternType: ${u}`)}}throw new _util.FormatError(`Unknown PatternName: ${u}`)}_parseVisibilityExpression(t,e,i){const r=10;if(++e>r)return void(0,_util.warn)("Visibility expression is too deeply nested");const a=t.length,n=this.xref.fetchIfRef(t[0]);if(a<2||!(0,_primitives.isName)(n))(0,_util.warn)("Invalid visibility expression");else{switch(n.name){case"And":case"Or":case"Not":i.push(n.name);break;default:return void(0,_util.warn)(`Invalid operator ${n.name} in visibility expression`)}for(let r=1;r<a;r++){const a=t[r],n=this.xref.fetchIfRef(a);if(Array.isArray(n)){const t=[];i.push(t),this._parseVisibilityExpression(n,e,t)}else(0,_primitives.isRef)(a)&&i.push(a.toString())}}}async parseMarkedContentProps(t,e){let i;if((0,_primitives.isName)(t)){const r=e.get("Properties");i=r.get(t.name)}else{if(!(0,_primitives.isDict)(t))throw new _util.FormatError("Optional content properties malformed.");i=t}const r=i.get("Type").name;if("OCG"===r)return{type:r,id:i.objId};if("OCMD"===r){const t=i.get("VE");if(Array.isArray(t)){const e=[];if(this._parseVisibilityExpression(t,0,e),e.length>0)return{type:"OCMD",expression:e}}const e=i.get("OCGs");if(Array.isArray(e)||(0,_primitives.isDict)(e)){const t=[];if(Array.isArray(e))for(const i of e)t.push(i.toString());else t.push(e.objId);return{type:r,ids:t,policy:(0,_primitives.isName)(i.get("P"))?i.get("P").name:null,expression:null}}if((0,_primitives.isRef)(e))return{type:r,id:e.toString()}}return null}getOperatorList({stream:t,task:e,resources:i,operatorList:r,initialState:a=null,fallbackFontDict:n=null}){if(i=i||_primitives.Dict.empty,a=a||new EvalState,!r)throw new Error('getOperatorList: missing "operatorList" parameter');const s=this,o=this.xref;let l=!1;const c=new _image_utils.LocalImageCache,u=new _image_utils.LocalColorSpaceCache,d=new _image_utils.LocalGStateCache,h=new _image_utils.LocalTilingPatternCache,g=new Map,f=i.get("XObject")||_primitives.Dict.empty,p=i.get("Pattern")||_primitives.Dict.empty,m=new StateManager(a),_=new EvaluatorPreprocessor(t,o,m),S=new TimeSlotManager;function b(t){for(let e=0,i=_.savedStatesDepth;e<i;e++)r.addOp(_util.OPS.restore,[])}return new Promise((function t(a,v){const C=function(e){Promise.all([e,r.ready]).then((function(){try{t(a,v)}catch(e){v(e)}}),v)};e.ensureNotTerminated(),S.reset();const O={};let F,P,y,x,A,T;while(!(F=S.check())){if(O.args=null,!_.read(O))break;let t=O.args,a=O.fn;switch(0|a){case _util.OPS.paintXObject:if(T=t[0]instanceof _primitives.Name,A=t[0].name,T){const e=c.getByName(A);if(e){r.addOp(e.fn,e.args),t=null;continue}}return void C(new Promise((function(t,a){if(!T)throw new _util.FormatError("XObject must be referred to by name.");let n=f.getRaw(A);if(n instanceof _primitives.Ref){const e=c.getByRef(n);if(e)return r.addOp(e.fn,e.args),void t();const i=s.globalImageCache.getData(n,s.pageIndex);if(i)return r.addDependency(i.objId),r.addOp(i.fn,i.args),void t();n=o.fetch(n)}if(!(0,_primitives.isStream)(n))throw new _util.FormatError("XObject should be a stream");const l=n.dict.get("Subtype");if(!(0,_primitives.isName)(l))throw new _util.FormatError("XObject should have a Name subtype");if("Form"===l.name)return m.save(),void s.buildFormXObject(i,n,null,r,e,m.state.clone(),u).then((function(){m.restore(),t()}),a);if("Image"!==l.name){if("PS"!==l.name)throw new _util.FormatError(`Unhandled XObject subtype ${l.name}`);(0,_util.info)("Ignored XObject subtype PS"),t()}else s.buildPaintImageXObject({resources:i,image:n,operatorList:r,cacheKey:A,localImageCache:c,localColorSpaceCache:u}).then(t,a)})).catch((function(t){if(!(t instanceof _util.AbortException)){if(s.options.ignoreErrors)return s.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorXObject}),void(0,_util.warn)(`getOperatorList - ignoring XObject: "${t}".`);throw t}})));case _util.OPS.setFont:var w=t[1];return void C(s.handleSetFont(i,t,null,r,e,m.state,n).then((function(t){r.addDependency(t),r.addOp(_util.OPS.setFont,[t,w])})));case _util.OPS.beginText:l=!0;break;case _util.OPS.endText:l=!1;break;case _util.OPS.endInlineImage:var I=t[0].cacheKey;if(I){const e=c.getByName(I);if(e){r.addOp(e.fn,e.args),t=null;continue}}return void C(s.buildPaintImageXObject({resources:i,image:t[0],isInline:!0,operatorList:r,cacheKey:I,localImageCache:c,localColorSpaceCache:u}));case _util.OPS.showText:if(!m.state.font){s.ensureStateFont(m.state);continue}t[0]=s.handleText(t[0],m.state);break;case _util.OPS.showSpacedText:if(!m.state.font){s.ensureStateFont(m.state);continue}var M=t[0],E=[],k=M.length,N=m.state;for(P=0;P<k;++P){const t=M[P];(0,_util.isString)(t)?Array.prototype.push.apply(E,s.handleText(t,N)):(0,_util.isNum)(t)&&E.push(t)}t[0]=E,a=_util.OPS.showText;break;case _util.OPS.nextLineShowText:if(!m.state.font){s.ensureStateFont(m.state);continue}r.addOp(_util.OPS.nextLine),t[0]=s.handleText(t[0],m.state),a=_util.OPS.showText;break;case _util.OPS.nextLineSetSpacingShowText:if(!m.state.font){s.ensureStateFont(m.state);continue}r.addOp(_util.OPS.nextLine),r.addOp(_util.OPS.setWordSpacing,[t.shift()]),r.addOp(_util.OPS.setCharSpacing,[t.shift()]),t[0]=s.handleText(t[0],m.state),a=_util.OPS.showText;break;case _util.OPS.setTextRenderingMode:m.state.textRenderingMode=t[0];break;case _util.OPS.setFillColorSpace:{const e=_colorspace.ColorSpace.getCached(t[0],o,u);if(e){m.state.fillColorSpace=e;continue}return void C(s.parseColorSpace({cs:t[0],resources:i,localColorSpaceCache:u}).then((function(t){t&&(m.state.fillColorSpace=t)})))}case _util.OPS.setStrokeColorSpace:{const e=_colorspace.ColorSpace.getCached(t[0],o,u);if(e){m.state.strokeColorSpace=e;continue}return void C(s.parseColorSpace({cs:t[0],resources:i,localColorSpaceCache:u}).then((function(t){t&&(m.state.strokeColorSpace=t)})))}case _util.OPS.setFillColor:x=m.state.fillColorSpace,t=x.getRgb(t,0),a=_util.OPS.setFillRGBColor;break;case _util.OPS.setStrokeColor:x=m.state.strokeColorSpace,t=x.getRgb(t,0),a=_util.OPS.setStrokeRGBColor;break;case _util.OPS.setFillGray:m.state.fillColorSpace=_colorspace.ColorSpace.singletons.gray,t=_colorspace.ColorSpace.singletons.gray.getRgb(t,0),a=_util.OPS.setFillRGBColor;break;case _util.OPS.setStrokeGray:m.state.strokeColorSpace=_colorspace.ColorSpace.singletons.gray,t=_colorspace.ColorSpace.singletons.gray.getRgb(t,0),a=_util.OPS.setStrokeRGBColor;break;case _util.OPS.setFillCMYKColor:m.state.fillColorSpace=_colorspace.ColorSpace.singletons.cmyk,t=_colorspace.ColorSpace.singletons.cmyk.getRgb(t,0),a=_util.OPS.setFillRGBColor;break;case _util.OPS.setStrokeCMYKColor:m.state.strokeColorSpace=_colorspace.ColorSpace.singletons.cmyk,t=_colorspace.ColorSpace.singletons.cmyk.getRgb(t,0),a=_util.OPS.setStrokeRGBColor;break;case _util.OPS.setFillRGBColor:m.state.fillColorSpace=_colorspace.ColorSpace.singletons.rgb,t=_colorspace.ColorSpace.singletons.rgb.getRgb(t,0);break;case _util.OPS.setStrokeRGBColor:m.state.strokeColorSpace=_colorspace.ColorSpace.singletons.rgb,t=_colorspace.ColorSpace.singletons.rgb.getRgb(t,0);break;case _util.OPS.setFillColorN:if(x=m.state.fillColorSpace,"Pattern"===x.name)return void C(s.handleColorN(r,_util.OPS.setFillColorN,t,x,p,i,e,u,h,g));t=x.getRgb(t,0),a=_util.OPS.setFillRGBColor;break;case _util.OPS.setStrokeColorN:if(x=m.state.strokeColorSpace,"Pattern"===x.name)return void C(s.handleColorN(r,_util.OPS.setStrokeColorN,t,x,p,i,e,u,h,g));t=x.getRgb(t,0),a=_util.OPS.setStrokeRGBColor;break;case _util.OPS.shadingFill:var D=i.get("Shading");if(!D)throw new _util.FormatError("No shading resource found");var R=D.get(t[0].name);if(!R)throw new _util.FormatError("No shading object found");const _=s.parseShading({shading:R,resources:i,localColorSpaceCache:u,localShadingPatternCache:g});t=[_],a=_util.OPS.shadingFill;break;case _util.OPS.setGState:if(T=t[0]instanceof _primitives.Name,A=t[0].name,T){const e=d.getByName(A);if(e){e.length>0&&r.addOp(_util.OPS.setGState,[e]),t=null;continue}}return void C(new Promise((function(t,a){if(!T)throw new _util.FormatError("GState must be referred to by name.");const n=i.get("ExtGState");if(!(n instanceof _primitives.Dict))throw new _util.FormatError("ExtGState should be a dictionary.");const o=n.get(A);if(!(o instanceof _primitives.Dict))throw new _util.FormatError("GState should be a dictionary.");s.setGState({resources:i,gState:o,operatorList:r,cacheKey:A,task:e,stateManager:m,localGStateCache:d,localColorSpaceCache:u}).then(t,a)})).catch((function(t){if(!(t instanceof _util.AbortException)){if(s.options.ignoreErrors)return s.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorExtGState}),void(0,_util.warn)(`getOperatorList - ignoring ExtGState: "${t}".`);throw t}})));case _util.OPS.moveTo:case _util.OPS.lineTo:case _util.OPS.curveTo:case _util.OPS.curveTo2:case _util.OPS.curveTo3:case _util.OPS.closePath:case _util.OPS.rectangle:s.buildPath(r,a,t,l);continue;case _util.OPS.markPoint:case _util.OPS.markPointProps:case _util.OPS.beginCompat:case _util.OPS.endCompat:continue;case _util.OPS.beginMarkedContentProps:if(!(0,_primitives.isName)(t[0])){(0,_util.warn)(`Expected name for beginMarkedContentProps arg0=${t[0]}`);continue}if("OC"===t[0].name)return void C(s.parseMarkedContentProps(t[1],i).then((t=>{r.addOp(_util.OPS.beginMarkedContentProps,["OC",t])})).catch((t=>{if(!(t instanceof _util.AbortException)){if(s.options.ignoreErrors)return s.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorMarkedContent}),void(0,_util.warn)(`getOperatorList - ignoring beginMarkedContentProps: "${t}".`);throw t}})));t=[t[0].name,t[1]instanceof _primitives.Dict?t[1].get("MCID"):null];break;case _util.OPS.beginMarkedContent:case _util.OPS.endMarkedContent:default:if(null!==t){for(P=0,y=t.length;P<y;P++)if(t[P]instanceof _primitives.Dict)break;if(P<y){(0,_util.warn)("getOperatorList - ignoring operator: "+a);continue}}}r.addOp(a,t)}F?C(deferred):(b(),a())})).catch((t=>{if(!(t instanceof _util.AbortException)){if(this.options.ignoreErrors)return this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorOperatorList}),(0,_util.warn)(`getOperatorList - ignoring errors during "${e.name}" task: "${t}".`),void b();throw t}}))}getTextContent({stream:t,task:e,resources:i,stateManager:r=null,normalizeWhitespace:a=!1,combineTextItems:n=!1,includeMarkedContent:s=!1,sink:o,seenStyles:l=new Set}){i=i||_primitives.Dict.empty,r=r||new StateManager(new TextState);const c=/\s/g,u={items:[],styles:Object.create(null)},d={initialized:!1,str:[],totalWidth:0,totalHeight:0,width:0,height:0,vertical:!1,lastCharSize:0,prevTransform:null,textAdvanceScale:0,spaceWidth:0,spaceInFlowMin:0,spaceInFlowMax:0,trackingSpaceMin:1/0,transform:null,fontName:null,hasEOL:!1,isLastCharWhiteSpace:!1},h=.3,g=.3,f=1.3,p=this,m=this.xref,_=[];let S=null;const b=new _image_utils.LocalImageCache,v=new _image_utils.LocalGStateCache,C=new EvaluatorPreprocessor(t,m,r);let O;function F(){const t=O.font,e=[O.fontSize*O.textHScale,0,0,O.fontSize,0,O.textRise];if(t.isType3Font&&(O.fontSize<=1||t.isCharBBox)&&!(0,_util.isArrayEqual)(O.fontMatrix,_util.FONT_IDENTITY_MATRIX)){const i=t.bbox[3]-t.bbox[1];i>0&&(e[3]*=i*O.fontMatrix[3])}return _util.Util.transform(O.ctm,_util.Util.transform(O.textMatrix,e))}function P(){if(d.initialized)return d;const t=O.font,e=t.loadedName;l.has(e)||(l.add(e),u.styles[e]={fontFamily:t.fallbackName,ascent:t.ascent,descent:t.descent,vertical:t.vertical}),d.fontName=e;const i=d.transform=F();t.vertical?(d.width=d.totalWidth=Math.hypot(i[0],i[1]),d.height=d.totalHeight=0,d.vertical=!0):(d.width=d.totalWidth=0,d.height=d.totalHeight=Math.hypot(i[2],i[3]),d.vertical=!1);const r=Math.hypot(O.textLineMatrix[0],O.textLineMatrix[1]),a=Math.hypot(O.ctm[0],O.ctm[1]);d.textAdvanceScale=a*r,d.lastCharSize=d.lastCharSize||0;const n=t.spaceWidth/1e3*O.fontSize;return n?(d.spaceWidth=n,d.trackingSpaceMin=n*h,d.spaceInFlowMin=n*g,d.spaceInFlowMax=n*f):(d.spaceWidth=0,d.trackingSpaceMin=1/0),d.hasEOL=!1,d.initialized=!0,d}function y(){if(!d.initialized)return;const t=Math.hypot(O.textLineMatrix[0],O.textLineMatrix[1]),e=Math.hypot(O.ctm[0],O.ctm[1]),i=e*t;i!==d.textAdvanceScale&&(d.vertical?(d.totalHeight+=d.height*d.textAdvanceScale,d.height=0):(d.totalWidth+=d.width*d.textAdvanceScale,d.width=0),d.textAdvanceScale=i)}function x(t){const e=t.length;let i,r=0;while(r<e&&(i=t.charCodeAt(r))>=32&&i<=127)r++;return r<e?t.replace(c," "):t}function A(t){const e=t.str.join(""),i=(0,_bidi.bidi)(e,-1,t.vertical),r=a?x(i.str):i.str;return{str:r,dir:i.dir,width:t.totalWidth,height:t.totalHeight,transform:t.transform,fontName:t.fontName,hasEOL:t.hasEOL}}function T(t,r){return p.loadFont(t,r,i).then((function(t){return t.font.isType3Font?t.loadType3Data(p,i,e).catch((function(){})).then((function(){return t})):t})).then((function(t){O.font=t.font,O.fontMatrix=t.font.fontMatrix||_util.FONT_IDENTITY_MATRIX}))}function w(t){if(!n||!O.font||!d.prevTransform)return;const e=F(),i=e[4],r=e[5],a=d.prevTransform[4],s=d.prevTransform[5];if(a===i&&s===r)return;const o=(i-a)/d.textAdvanceScale,l=(r-s)/d.textAdvanceScale,c=-.5*d.lastCharSize;if(O.font.vertical){if(Math.abs(o)>d.width/d.textAdvanceScale)return void M();if(c>l)return;l>d.trackingSpaceMin?d.height+=l:E(l,0,d.prevTransform)||(0===d.str.length?(u.items.push({str:" ",dir:"ltr",width:0,height:l,transform:d.prevTransform,fontName:d.fontName,hasEOL:!1}),d.isLastCharWhiteSpace=!0):d.height+=l)}else Math.abs(l)>d.height/d.textAdvanceScale?M():c>o||(o<=d.trackingSpaceMin?d.width+=o:E(o,0,d.prevTransform)||(0===d.str.length?(u.items.push({str:" ",dir:"ltr",width:o,height:0,transform:d.prevTransform,fontName:d.fontName,hasEOL:!1}),d.isLastCharWhiteSpace=!0):d.width+=o))}function I({chars:t,extraSpacing:e,isFirstChunk:i}){const r=O.font;if(!t){const t=O.charSpacing+e;return void(t&&(r.vertical?O.translateTextMatrix(0,t):O.translateTextMatrix(t*O.textHScale,0)))}const a=(0,_unicode.getNormalizedUnicodes)(),n=r.charsToGlyphs(t),s=O.fontMatrix[0]*O.fontSize;i&&w(s);let o=P(),l=0,c=0;for(let u=0,h=n.length;u<h;u++){const t=n[u];let i=O.charSpacing+(u===h-1?e:0),g=t.unicode;t.isSpace?(i+=O.wordSpacing,o.isLastCharWhiteSpace=!0):(g=a[g]||g,g=(0,_unicode.reverseIfRtl)(g),o.isLastCharWhiteSpace=!1),o.str.push(g);const f=r.vertical&&t.vmetric?t.vmetric[0]:t.width;let p=f*s;if(r.vertical?(O.translateTextMatrix(0,p),p=Math.abs(p)):(p*=O.textHScale,O.translateTextMatrix(p,0)),l+=p,i){r.vertical||(i*=O.textHScale),p+=i;const t=i>d.trackingSpaceMin&&E(i,l);r.vertical?O.translateTextMatrix(0,i):O.translateTextMatrix(i,0),t?(o=P(),l=0):l+=i}c=p}o.lastCharSize=c,r.vertical?o.height+=l:o.width+=l,o.prevTransform=F()}function M(){d.initialized?(d.hasEOL=!0,k()):u.items.push({str:"",dir:"ltr",width:0,height:0,transform:F(),fontName:O.font.loadedName,hasEOL:!0}),d.isLastCharWhiteSpace=!1,d.lastCharSize=0}function E(t,e,i=null){if(d.spaceInFlowMin<=t&&t<=d.spaceInFlowMax)return d.initialized&&(d.str.push(" "),d.isLastCharWhiteSpace=!0),!1;const r=d.fontName;let a=0;return t*=d.textAdvanceScale,d.vertical?(d.height+=e,a=t,t=0):d.width+=e,k(),d.isLastCharWhiteSpace||(d.isLastCharWhiteSpace=!0,u.items.push({str:" ",dir:"ltr",width:t,height:a,transform:i||F(),fontName:r,hasEOL:!1})),!0}function k(){d.initialized&&d.str&&(d.vertical?d.totalHeight+=d.height*d.textAdvanceScale:d.totalWidth+=d.width*d.textAdvanceScale,u.items.push(A(d)),d.initialized=!1,d.str.length=0)}function N(t=!1){const e=u.items.length;0!==e&&(t&&e<TEXT_CHUNK_BATCH_SIZE||(o.enqueue(u,e),u.items=[],u.styles=Object.create(null)))}const D=new TimeSlotManager;return new Promise((function t(c,h){const g=function(e){N(!0),Promise.all([e,o.ready]).then((function(){try{t(c,h)}catch(e){h(e)}}),h)};e.ensureNotTerminated(),D.reset();const f={};let F,P=[];while(!(F=D.check())){if(P.length=0,f.args=P,!C.read(f))break;O=r.state;const t=f.fn;switch(P=f.args,0|t){case _util.OPS.setFont:var x=P[0].name,A=P[1];if(O.font&&x===O.fontName&&A===O.fontSize)break;return k(),O.fontName=x,O.fontSize=A,void g(T(x,null));case _util.OPS.setTextRise:k(),O.textRise=P[0];break;case _util.OPS.setHScale:k(),O.textHScale=P[0]/100;break;case _util.OPS.setLeading:k(),O.leading=P[0];break;case _util.OPS.moveText:O.translateTextLineMatrix(P[0],P[1]),O.textMatrix=O.textLineMatrix.slice();break;case _util.OPS.setLeadingMoveText:k(),O.leading=-P[1],O.translateTextLineMatrix(P[0],P[1]),O.textMatrix=O.textLineMatrix.slice();break;case _util.OPS.nextLine:M(),O.carriageReturn();break;case _util.OPS.setTextMatrix:O.setTextMatrix(P[0],P[1],P[2],P[3],P[4],P[5]),O.setTextLineMatrix(P[0],P[1],P[2],P[3],P[4],P[5]),y();break;case _util.OPS.setCharSpacing:O.charSpacing=P[0];break;case _util.OPS.setWordSpacing:O.wordSpacing=P[0];break;case _util.OPS.beginText:k(),O.textMatrix=_util.IDENTITY_MATRIX.slice(),O.textLineMatrix=_util.IDENTITY_MATRIX.slice();break;case _util.OPS.showSpacedText:if(!r.state.font){p.ensureStateFont(r.state);continue}const t=(O.font.vertical?1:-1)*O.fontSize/1e3,c=P[0];let h=!0;for(let e=0,i=c.length;e<i-1;e++){const i=c[e];if("string"===typeof i)_.push(i);else if("number"===typeof i&&0!==i){const e=_.join("");_.length=0,I({chars:e,extraSpacing:i*t,isFirstChunk:h}),e&&h&&(h=!1)}}const f=c[c.length-1];if("string"===typeof f&&_.push(f),_.length>0){const t=_.join("");_.length=0,I({chars:t,extraSpacing:0,isFirstChunk:h})}break;case _util.OPS.showText:if(!r.state.font){p.ensureStateFont(r.state);continue}I({chars:P[0],extraSpacing:0,isFirstChunk:!0});break;case _util.OPS.nextLineShowText:if(!r.state.font){p.ensureStateFont(r.state);continue}d.hasEOL=!0,k(),O.carriageReturn(),I({chars:P[0],extraSpacing:0,isFirstChunk:!0});break;case _util.OPS.nextLineSetSpacingShowText:if(!r.state.font){p.ensureStateFont(r.state);continue}d.hasEOL=!0,k(),O.wordSpacing=P[0],O.charSpacing=P[1],O.carriageReturn(),I({chars:P[2],extraSpacing:0,isFirstChunk:!0});break;case _util.OPS.paintXObject:k(),S||(S=i.get("XObject")||_primitives.Dict.empty);var w=P[0]instanceof _primitives.Name,E=P[0].name;if(w&&b.getByName(E))break;return void g(new Promise((function(t,c){if(!w)throw new _util.FormatError("XObject must be referred to by name.");let u=S.getRaw(E);if(u instanceof _primitives.Ref){if(b.getByRef(u))return void t();const e=p.globalImageCache.getData(u,p.pageIndex);if(e)return void t();u=m.fetch(u)}if(!(0,_primitives.isStream)(u))throw new _util.FormatError("XObject should be a stream");const d=u.dict.get("Subtype");if(!(0,_primitives.isName)(d))throw new _util.FormatError("XObject should have a Name subtype");if("Form"!==d.name)return b.set(E,u.dict.objId,!0),void t();const h=r.state.clone(),g=new StateManager(h),f=u.dict.getArray("Matrix");Array.isArray(f)&&6===f.length&&g.transform(f),N();const _={enqueueInvoked:!1,enqueue(t,e){this.enqueueInvoked=!0,o.enqueue(t,e)},get desiredSize(){return o.desiredSize},get ready(){return o.ready}};p.getTextContent({stream:u,task:e,resources:u.dict.get("Resources")||i,stateManager:g,normalizeWhitespace:a,combineTextItems:n,includeMarkedContent:s,sink:_,seenStyles:l}).then((function(){_.enqueueInvoked||b.set(E,u.dict.objId,!0),t()}),c)})).catch((function(t){if(!(t instanceof _util.AbortException)){if(!p.options.ignoreErrors)throw t;(0,_util.warn)(`getTextContent - ignoring XObject: "${t}".`)}})));case _util.OPS.setGState:if(w=P[0]instanceof _primitives.Name,E=P[0].name,w&&v.getByName(E))break;return void g(new Promise((function(t,e){if(!w)throw new _util.FormatError("GState must be referred to by name.");const r=i.get("ExtGState");if(!(r instanceof _primitives.Dict))throw new _util.FormatError("ExtGState should be a dictionary.");const a=r.get(E);if(!(a instanceof _primitives.Dict))throw new _util.FormatError("GState should be a dictionary.");const n=a.get("Font");if(!n)return v.set(E,a.objId,!0),void t();k(),O.fontName=null,O.fontSize=n[1],T(null,n[0]).then(t,e)})).catch((function(t){if(!(t instanceof _util.AbortException)){if(!p.options.ignoreErrors)throw t;(0,_util.warn)(`getTextContent - ignoring ExtGState: "${t}".`)}})));case _util.OPS.beginMarkedContent:s&&u.items.push({type:"beginMarkedContent",tag:(0,_primitives.isName)(P[0])?P[0].name:null});break;case _util.OPS.beginMarkedContentProps:if(s){k();let t=null;(0,_primitives.isDict)(P[1])&&(t=P[1].get("MCID")),u.items.push({type:"beginMarkedContentProps",id:Number.isInteger(t)?`${p.idFactory.getPageObjId()}_mcid${t}`:null,tag:(0,_primitives.isName)(P[0])?P[0].name:null})}break;case _util.OPS.endMarkedContent:s&&(k(),u.items.push({type:"endMarkedContent"}));break}if(u.items.length>=o.desiredSize){F=!0;break}}F?g(deferred):(k(),N(),c())})).catch((t=>{if(!(t instanceof _util.AbortException)){if(this.options.ignoreErrors)return(0,_util.warn)(`getTextContent - ignoring errors during "${e.name}" task: "${t}".`),k(),void N();throw t}}))}extractDataStructures(t,e,i){const r=this.xref;let a;const n=this.readToUnicode(i.toUnicode||t.get("ToUnicode")||e.get("ToUnicode"));if(i.composite){const e=t.get("CIDSystemInfo");(0,_primitives.isDict)(e)&&(i.cidSystemInfo={registry:(0,_util.stringToPDFString)(e.get("Registry")),ordering:(0,_util.stringToPDFString)(e.get("Ordering")),supplement:e.get("Supplement")});const r=t.get("CIDToGIDMap");(0,_primitives.isStream)(r)&&(a=r.getBytes())}const s=[];let o,l=null;if(t.has("Encoding")){if(o=t.get("Encoding"),(0,_primitives.isDict)(o)){if(l=o.get("BaseEncoding"),l=(0,_primitives.isName)(l)?l.name:null,o.has("Differences")){const t=o.get("Differences");let e=0;for(let i=0,a=t.length;i<a;i++){const a=r.fetchIfRef(t[i]);if((0,_util.isNum)(a))e=a;else{if(!(0,_primitives.isName)(a))throw new _util.FormatError(`Invalid entry in 'Differences' array: ${a}`);s[e++]=a.name}}}}else{if(!(0,_primitives.isName)(o))throw new _util.FormatError("Encoding is not a Name nor a Dict");l=o.name}"MacRomanEncoding"!==l&&"MacExpertEncoding"!==l&&"WinAnsiEncoding"!==l&&(l=null)}if(l)i.defaultEncoding=(0,_encodings.getEncoding)(l);else{const t=!!(i.flags&_fonts_utils.FontFlags.Symbolic),e=!!(i.flags&_fonts_utils.FontFlags.Nonsymbolic);o=_encodings.StandardEncoding,"TrueType"!==i.type||e||(o=_encodings.WinAnsiEncoding),t&&(o=_encodings.MacRomanEncoding,i.file&&!i.isInternalFont||(/Symbol/i.test(i.name)?o=_encodings.SymbolSetEncoding:/Dingbats|Wingdings/i.test(i.name)&&(o=_encodings.ZapfDingbatsEncoding))),i.defaultEncoding=o}return i.differences=s,i.baseEncodingName=l,i.hasEncoding=!!l||s.length>0,i.dict=t,n.then((t=>(i.toUnicode=t,this.buildToUnicode(i)))).then((t=>(i.toUnicode=t,a&&(i.cidToGidMap=this.readCidToGidMap(a,t)),i)))}_simpleFontToUnicode(t,e=!1){(0,_util.assert)(!t.composite,"Must be a simple font.");const i=[],r=t.defaultEncoding.slice(),a=t.baseEncodingName,n=t.differences;for(const o in n){const t=n[o];".notdef"!==t&&(r[o]=t)}const s=(0,_glyphlist.getGlyphsUnicode)();for(const o in r){let n=r[o];if(""!==n)if(void 0!==s[n])i[o]=String.fromCharCode(s[n]);else{let r=0;switch(n[0]){case"G":3===n.length&&(r=parseInt(n.substring(1),16));break;case"g":5===n.length&&(r=parseInt(n.substring(1),16));break;case"C":case"c":if(n.length>=3&&n.length<=4){const i=n.substring(1);if(e){r=parseInt(i,16);break}if(r=+i,Number.isNaN(r)&&Number.isInteger(parseInt(i,16)))return this._simpleFontToUnicode(t,!0)}break;default:const i=(0,_unicode.getUnicodeForGlyph)(n,s);-1!==i&&(r=i)}if(r>0&&r<=1114111&&Number.isInteger(r)){if(a&&r===+o){const t=(0,_encodings.getEncoding)(a);if(t&&(n=t[o])){i[o]=String.fromCharCode(s[n]);continue}}i[o]=String.fromCodePoint(r)}}}return i}async buildToUnicode(t){if(t.hasIncludedToUnicodeMap=!!t.toUnicode&&t.toUnicode.length>0,t.hasIncludedToUnicodeMap)return!t.composite&&t.hasEncoding&&(t.fallbackToUnicode=this._simpleFontToUnicode(t)),t.toUnicode;if(!t.composite)return new _to_unicode_map.ToUnicodeMap(this._simpleFontToUnicode(t));if(t.composite&&(t.cMap.builtInCMap&&!(t.cMap instanceof _cmap.IdentityCMap)||"Adobe"===t.cidSystemInfo.registry&&("GB1"===t.cidSystemInfo.ordering||"CNS1"===t.cidSystemInfo.ordering||"Japan1"===t.cidSystemInfo.ordering||"Korea1"===t.cidSystemInfo.ordering))){const{registry:e,ordering:i}=t.cidSystemInfo,r=_primitives.Name.get(`${e}-${i}-UCS2`),a=await _cmap.CMapFactory.create({encoding:r,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null}),n=[];return t.cMap.forEach((function(t,e){if(e>65535)throw new _util.FormatError("Max size of CID is 65,535");const i=a.lookup(e);i&&(n[t]=String.fromCharCode((i.charCodeAt(0)<<8)+i.charCodeAt(1)))})),new _to_unicode_map.ToUnicodeMap(n)}return new _to_unicode_map.IdentityToUnicodeMap(t.firstChar,t.lastChar)}readToUnicode(t){return t?(0,_primitives.isName)(t)?_cmap.CMapFactory.create({encoding:t,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null}).then((function(t){return t instanceof _cmap.IdentityCMap?new _to_unicode_map.IdentityToUnicodeMap(0,65535):new _to_unicode_map.ToUnicodeMap(t.getMap())})):(0,_primitives.isStream)(t)?_cmap.CMapFactory.create({encoding:t,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null}).then((function(t){if(t instanceof _cmap.IdentityCMap)return new _to_unicode_map.IdentityToUnicodeMap(0,65535);const e=new Array(t.length);return t.forEach((function(t,i){if("number"===typeof i)return void(e[t]=String.fromCodePoint(i));const r=[];for(let e=0;e<i.length;e+=2){const t=i.charCodeAt(e)<<8|i.charCodeAt(e+1);if(55296!==(63488&t)){r.push(t);continue}e+=2;const a=i.charCodeAt(e)<<8|i.charCodeAt(e+1);r.push(((1023&t)<<10)+(1023&a)+65536)}e[t]=String.fromCodePoint.apply(String,r)})),new _to_unicode_map.ToUnicodeMap(e)}),(t=>{if(t instanceof _util.AbortException)return null;if(this.options.ignoreErrors)return this.handler.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontToUnicode}),(0,_util.warn)(`readToUnicode - ignoring ToUnicode data: "${t}".`),null;throw t})):Promise.resolve(null):Promise.resolve(null)}readCidToGidMap(t,e){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r++]<<8|t[r],n=r>>1;(0!==a||e.has(n))&&(i[n]=a)}return i}extractWidths(t,e,i){const r=this.xref;let a=[],n=0;const s=[];let o,l,c,u,d,h,g,f;if(i.composite){if(n=t.has("DW")?t.get("DW"):1e3,f=t.get("W"),f)for(l=0,c=f.length;l<c;l++)if(h=r.fetchIfRef(f[l++]),g=r.fetchIfRef(f[l]),Array.isArray(g))for(u=0,d=g.length;u<d;u++)a[h++]=r.fetchIfRef(g[u]);else{const t=r.fetchIfRef(f[++l]);for(u=h;u<=g;u++)a[u]=t}if(i.vertical){let e=t.getArray("DW2")||[880,-1e3];if(o=[e[1],.5*n,e[0]],e=t.get("W2"),e)for(l=0,c=e.length;l<c;l++)if(h=r.fetchIfRef(e[l++]),g=r.fetchIfRef(e[l]),Array.isArray(g))for(u=0,d=g.length;u<d;u++)s[h++]=[r.fetchIfRef(g[u++]),r.fetchIfRef(g[u++]),r.fetchIfRef(g[u])];else{const t=[r.fetchIfRef(e[++l]),r.fetchIfRef(e[++l]),r.fetchIfRef(e[++l])];for(u=h;u<=g;u++)s[u]=t}}}else{const s=i.firstChar;if(f=t.get("Widths"),f){for(u=s,l=0,c=f.length;l<c;l++)a[u++]=r.fetchIfRef(f[l]);n=parseFloat(e.get("MissingWidth"))||0}else{const e=t.get("BaseFont");if((0,_primitives.isName)(e)){const t=this.getBaseFontMetrics(e.name);a=this.buildCharCodeToWidth(t.widths,i),n=t.defaultWidth}}}let p=!0,m=n;for(const _ in a){const t=a[_];if(t)if(m){if(m!==t){p=!1;break}}else m=t}p&&(i.flags|=_fonts_utils.FontFlags.FixedPitch),i.defaultWidth=n,i.widths=a,i.defaultVMetrics=o,i.vmetrics=s}isSerifFont(t){const e=t.split("-")[0];return e in(0,_standard_fonts.getSerifFonts)()||-1!==e.search(/serif/gi)}getBaseFontMetrics(t){let e=0,i=Object.create(null),r=!1;const a=(0,_standard_fonts.getStdFontMap)();let n=a[t]||t;const s=(0,_metrics.getMetrics)();n in s||(n=this.isSerifFont(t)?"Times-Roman":"Helvetica");const o=s[n];return(0,_util.isNum)(o)?(e=o,r=!0):i=o(),{defaultWidth:e,monospace:r,widths:i}}buildCharCodeToWidth(t,e){const i=Object.create(null),r=e.differences,a=e.defaultEncoding;for(let n=0;n<256;n++)n in r&&t[r[n]]?i[n]=t[r[n]]:n in a&&t[a[n]]&&(i[n]=t[a[n]]);return i}preEvaluateFont(t){const e=t;let i=t.get("Subtype");if(!(0,_primitives.isName)(i))throw new _util.FormatError("invalid font Subtype");let r,a,n=!1;if("Type0"===i.name){const e=t.get("DescendantFonts");if(!e)throw new _util.FormatError("Descendant fonts are not specified");if(t=Array.isArray(e)?this.xref.fetchIfRef(e[0]):e,!(t instanceof _primitives.Dict))throw new _util.FormatError("Descendant font is not a dictionary.");if(i=t.get("Subtype"),!(0,_primitives.isName)(i))throw new _util.FormatError("invalid font Subtype");n=!0}const s=t.get("FirstChar")||0,o=t.get("LastChar")||(n?65535:255),l=t.get("FontDescriptor");if(l){r=new _murmurhash.MurmurHash3_64;const i=e.getRaw("Encoding");if((0,_primitives.isName)(i))r.update(i.name);else if((0,_primitives.isRef)(i))r.update(i.toString());else if((0,_primitives.isDict)(i))for(const t of i.getRawValues())if((0,_primitives.isName)(t))r.update(t.name);else if((0,_primitives.isRef)(t))r.update(t.toString());else if(Array.isArray(t)){const e=t.length,i=new Array(e);for(let r=0;r<e;r++){const e=t[r];(0,_primitives.isName)(e)?i[r]=e.name:((0,_util.isNum)(e)||(0,_primitives.isRef)(e))&&(i[r]=e.toString())}r.update(i.join())}if(r.update(`${s}-${o}`),a=t.get("ToUnicode")||e.get("ToUnicode"),(0,_primitives.isStream)(a)){const t=a.str||a,e=t.buffer?new Uint8Array(t.buffer.buffer,0,t.bufferLength):new Uint8Array(t.bytes.buffer,t.start,t.end-t.start);r.update(e)}else(0,_primitives.isName)(a)&&r.update(a.name);const l=t.get("Widths")||e.get("Widths");if(Array.isArray(l)){const t=[];for(const e of l)((0,_util.isNum)(e)||(0,_primitives.isRef)(e))&&t.push(e.toString());r.update(t.join())}if(n){r.update("compositeFont");const i=t.get("W")||e.get("W");if(Array.isArray(i)){const t=[];for(const e of i)if((0,_util.isNum)(e)||(0,_primitives.isRef)(e))t.push(e.toString());else if(Array.isArray(e)){const i=[];for(const t of e)((0,_util.isNum)(t)||(0,_primitives.isRef)(t))&&i.push(t.toString());t.push(`[${i.join()}]`)}r.update(t.join())}}}return{descriptor:l,dict:t,baseDict:e,composite:n,type:i.name,firstChar:s,lastChar:o,toUnicode:a,hash:r?r.hexdigest():""}}async translateFont({descriptor:t,dict:e,baseDict:i,composite:r,type:a,firstChar:n,lastChar:s,toUnicode:o,cssFontInfo:l}){const c="Type3"===a;let u;if(!t){if(!c){let t=e.get("BaseFont");if(!(0,_primitives.isName)(t))throw new _util.FormatError("Base font is not specified");t=t.name.replace(/[,_]/g,"-");const r=this.getBaseFontMetrics(t),l=t.split("-")[0],d=(this.isSerifFont(l)?_fonts_utils.FontFlags.Serif:0)|(r.monospace?_fonts_utils.FontFlags.FixedPitch:0)|((0,_standard_fonts.getSymbolsFonts)()[l]?_fonts_utils.FontFlags.Symbolic:_fonts_utils.FontFlags.Nonsymbolic);u={type:a,name:t,loadedName:i.loadedName,widths:r.widths,defaultWidth:r.defaultWidth,isSimulatedFlags:!0,flags:d,firstChar:n,lastChar:s,toUnicode:o,xHeight:0,capHeight:0,italicAngle:0,isType3Font:c};const h=e.get("Widths"),g=(0,_standard_fonts.getStandardFontName)(t);let f=null;return g&&(u.isStandardFont=!0,f=await this.fetchStandardFontData(g),u.isInternalFont=!!f),this.extractDataStructures(e,e,u).then((e=>{if(h){const t=[];let i=n;for(let e=0,r=h.length;e<r;e++)t[i++]=this.xref.fetchIfRef(h[e]);e.widths=t}else e.widths=this.buildCharCodeToWidth(r.widths,e);return new _fonts.Font(t,f,e)}))}t=new _primitives.Dict(null),t.set("FontName",_primitives.Name.get(a)),t.set("FontBBox",e.getArray("FontBBox")||[0,0,0,0])}let d,h,g,f,p,m=t.get("FontName"),_=e.get("BaseFont");if((0,_util.isString)(m)&&(m=_primitives.Name.get(m)),(0,_util.isString)(_)&&(_=_primitives.Name.get(_)),!c){const t=m&&m.name,e=_&&_.name;t!==e&&((0,_util.info)(`The FontDescriptor's FontName is "${t}" but should be the same as the Font's BaseFont "${e}".`),t&&e&&e.startsWith(t)&&(m=_))}if(m=m||_,!(0,_primitives.isName)(m))throw new _util.FormatError("invalid font name");try{d=t.get("FontFile","FontFile2","FontFile3")}catch(C){if(!this.options.ignoreErrors)throw C;(0,_util.warn)(`translateFont - fetching "${m.name}" font file: "${C}".`),d=new _stream.NullStream}let S=!1,b=!1,v=null;if(d){if(d.dict){const t=d.dict.get("Subtype");t instanceof _primitives.Name&&(h=t.name),g=d.dict.get("Length1"),f=d.dict.get("Length2"),p=d.dict.get("Length3")}}else if(l){const t=(0,_xfa_fonts.getXfaFontName)(m.name);t&&(l.fontFamily=`${l.fontFamily}-PdfJS-XFA`,l.metrics=t.metrics||null,v=t.factors||null,d=await this.fetchStandardFontData(t.name),b=!!d,i=e=(0,_xfa_fonts.getXfaFontDict)(m.name),r=!0)}else if(!c){const t=(0,_standard_fonts.getStandardFontName)(m.name);t&&(S=!0,d=await this.fetchStandardFontData(t),b=!!d)}if(u={type:a,name:m.name,subtype:h,file:d,length1:g,length2:f,length3:p,isStandardFont:S,isInternalFont:b,loadedName:i.loadedName,composite:r,fixedPitch:!1,fontMatrix:e.getArray("FontMatrix")||_util.FONT_IDENTITY_MATRIX,firstChar:n,lastChar:s,toUnicode:o,bbox:t.getArray("FontBBox")||e.getArray("FontBBox"),ascent:t.get("Ascent"),descent:t.get("Descent"),xHeight:t.get("XHeight")||0,capHeight:t.get("CapHeight")||0,flags:t.get("Flags"),italicAngle:t.get("ItalicAngle")||0,isType3Font:c,cssFontInfo:l,scaleFactors:v},r){const t=i.get("Encoding");(0,_primitives.isName)(t)&&(u.cidEncoding=t.name);const e=await _cmap.CMapFactory.create({encoding:t,fetchBuiltInCMap:this._fetchBuiltInCMapBound,useCMap:null});u.cMap=e,u.vertical=u.cMap.vertical}return this.extractDataStructures(e,i,u).then((i=>(this.extractWidths(e,t,i),new _fonts.Font(m.name,d,i))))}static buildFontPaths(t,e,i,r){function a(e){const a=`${t.loadedName}_path_${e}`;try{if(t.renderer.hasBuiltPath(e))return;i.send("commonobj",[a,"FontPath",t.renderer.getPathJs(e)])}catch(n){if(r.ignoreErrors)return i.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.errorFontBuildPath}),void(0,_util.warn)(`buildFontPaths - ignoring ${a} glyph: "${n}".`);throw n}}for(const n of e){a(n.fontChar);const t=n.accent;t&&t.fontChar&&a(t.fontChar)}}static get fallbackFontDict(){const t=new _primitives.Dict;return t.set("BaseFont",_primitives.Name.get("PDFJS-FallbackFont")),t.set("Type",_primitives.Name.get("FallbackType")),t.set("Subtype",_primitives.Name.get("FallbackType")),t.set("Encoding",_primitives.Name.get("WinAnsiEncoding")),(0,_util.shadow)(this,"fallbackFontDict",t)}}exports.PartialEvaluator=PartialEvaluator;class TranslatedFont{constructor({loadedName:t,font:e,dict:i,evaluatorOptions:r}){this.loadedName=t,this.font=e,this.dict=i,this._evaluatorOptions=r||DefaultPartialEvaluatorOptions,this.type3Loaded=null,this.type3Dependencies=e.isType3Font?new Set:null,this.sent=!1}send(t){this.sent||(this.sent=!0,t.send("commonobj",[this.loadedName,"Font",this.font.exportData(this._evaluatorOptions.fontExtraProperties)]))}fallback(t){this.font.data&&(this.font.disableFontFace=!0,PartialEvaluator.buildFontPaths(this.font,this.font.glyphCacheValues,t,this._evaluatorOptions))}loadType3Data(t,e,i){if(this.type3Loaded)return this.type3Loaded;if(!this.font.isType3Font)throw new Error("Must be a Type3 font.");const r=t.clone({ignoreErrors:!1});r.parsingType3Font=!0;const a=this.font,n=this.type3Dependencies;let s=Promise.resolve();const o=this.dict.get("CharProcs"),l=this.dict.get("Resources")||e,c=Object.create(null),u=!a.bbox||(0,_util.isArrayEqual)(a.bbox,[0,0,0,0]);for(const d of o.getKeys())s=s.then((()=>{const t=o.get(d),e=new _operator_list.OperatorList;return r.getOperatorList({stream:t,task:i,resources:l,operatorList:e}).then((()=>{e.fnArray[0]===_util.OPS.setCharWidthAndBounds&&this._removeType3ColorOperators(e,u),c[d]=e.getIR();for(const t of e.dependencies)n.add(t)})).catch((function(t){(0,_util.warn)(`Type3 font resource "${d}" is not available.`);const e=new _operator_list.OperatorList;c[d]=e.getIR()}))}));return this.type3Loaded=s.then((()=>{a.charProcOperatorList=c,this._bbox&&(a.isCharBBox=!0,a.bbox=this._bbox)})),this.type3Loaded}_removeType3ColorOperators(t,e=!1){if(e){this._bbox||(this._bbox=[1/0,1/0,-1/0,-1/0]);const e=_util.Util.normalizeRect(t.argsArray[0].slice(2));this._bbox[0]=Math.min(this._bbox[0],e[0]),this._bbox[1]=Math.min(this._bbox[1],e[1]),this._bbox[2]=Math.max(this._bbox[2],e[2]),this._bbox[3]=Math.max(this._bbox[3],e[3])}let i=1,r=t.length;while(i<r){switch(t.fnArray[i]){case _util.OPS.setStrokeColorSpace:case _util.OPS.setFillColorSpace:case _util.OPS.setStrokeColor:case _util.OPS.setStrokeColorN:case _util.OPS.setFillColor:case _util.OPS.setFillColorN:case _util.OPS.setStrokeGray:case _util.OPS.setFillGray:case _util.OPS.setStrokeRGBColor:case _util.OPS.setFillRGBColor:case _util.OPS.setStrokeCMYKColor:case _util.OPS.setFillCMYKColor:case _util.OPS.shadingFill:case _util.OPS.setRenderingIntent:t.fnArray.splice(i,1),t.argsArray.splice(i,1),r--;continue;case _util.OPS.setGState:const[e]=t.argsArray[i];let a=0,n=e.length;while(a<n){const[t]=e[a];switch(t){case"TR":case"TR2":case"HT":case"BG":case"BG2":case"UCR":case"UCR2":e.splice(a,1),n--;continue}a++}break}i++}}}class StateManager{constructor(t=new EvalState){this.state=t,this.stateStack=[]}save(){const t=this.state;this.stateStack.push(this.state),this.state=t.clone()}restore(){const t=this.stateStack.pop();t&&(this.state=t)}transform(t){this.state.ctm=_util.Util.transform(this.state.ctm,t)}}class TextState{constructor(){this.ctm=new Float32Array(_util.IDENTITY_MATRIX),this.fontName=null,this.fontSize=0,this.font=null,this.fontMatrix=_util.FONT_IDENTITY_MATRIX,this.textMatrix=_util.IDENTITY_MATRIX.slice(),this.textLineMatrix=_util.IDENTITY_MATRIX.slice(),this.charSpacing=0,this.wordSpacing=0,this.leading=0,this.textHScale=1,this.textRise=0}setTextMatrix(t,e,i,r,a,n){const s=this.textMatrix;s[0]=t,s[1]=e,s[2]=i,s[3]=r,s[4]=a,s[5]=n}setTextLineMatrix(t,e,i,r,a,n){const s=this.textLineMatrix;s[0]=t,s[1]=e,s[2]=i,s[3]=r,s[4]=a,s[5]=n}translateTextMatrix(t,e){const i=this.textMatrix;i[4]=i[0]*t+i[2]*e+i[4],i[5]=i[1]*t+i[3]*e+i[5]}translateTextLineMatrix(t,e){const i=this.textLineMatrix;i[4]=i[0]*t+i[2]*e+i[4],i[5]=i[1]*t+i[3]*e+i[5]}carriageReturn(){this.translateTextLineMatrix(0,-this.leading),this.textMatrix=this.textLineMatrix.slice()}clone(){const t=Object.create(this);return t.textMatrix=this.textMatrix.slice(),t.textLineMatrix=this.textLineMatrix.slice(),t.fontMatrix=this.fontMatrix.slice(),t}}class EvalState{constructor(){this.ctm=new Float32Array(_util.IDENTITY_MATRIX),this.font=null,this.textRenderingMode=_util.TextRenderingMode.FILL,this.fillColorSpace=_colorspace.ColorSpace.singletons.gray,this.strokeColorSpace=_colorspace.ColorSpace.singletons.gray}clone(){return Object.create(this)}}class EvaluatorPreprocessor{static get opMap(){const t=(0,_core_utils.getLookupTableFactory)((function(t){t.w={id:_util.OPS.setLineWidth,numArgs:1,variableArgs:!1},t.J={id:_util.OPS.setLineCap,numArgs:1,variableArgs:!1},t.j={id:_util.OPS.setLineJoin,numArgs:1,variableArgs:!1},t.M={id:_util.OPS.setMiterLimit,numArgs:1,variableArgs:!1},t.d={id:_util.OPS.setDash,numArgs:2,variableArgs:!1},t.ri={id:_util.OPS.setRenderingIntent,numArgs:1,variableArgs:!1},t.i={id:_util.OPS.setFlatness,numArgs:1,variableArgs:!1},t.gs={id:_util.OPS.setGState,numArgs:1,variableArgs:!1},t.q={id:_util.OPS.save,numArgs:0,variableArgs:!1},t.Q={id:_util.OPS.restore,numArgs:0,variableArgs:!1},t.cm={id:_util.OPS.transform,numArgs:6,variableArgs:!1},t.m={id:_util.OPS.moveTo,numArgs:2,variableArgs:!1},t.l={id:_util.OPS.lineTo,numArgs:2,variableArgs:!1},t.c={id:_util.OPS.curveTo,numArgs:6,variableArgs:!1},t.v={id:_util.OPS.curveTo2,numArgs:4,variableArgs:!1},t.y={id:_util.OPS.curveTo3,numArgs:4,variableArgs:!1},t.h={id:_util.OPS.closePath,numArgs:0,variableArgs:!1},t.re={id:_util.OPS.rectangle,numArgs:4,variableArgs:!1},t.S={id:_util.OPS.stroke,numArgs:0,variableArgs:!1},t.s={id:_util.OPS.closeStroke,numArgs:0,variableArgs:!1},t.f={id:_util.OPS.fill,numArgs:0,variableArgs:!1},t.F={id:_util.OPS.fill,numArgs:0,variableArgs:!1},t["f*"]={id:_util.OPS.eoFill,numArgs:0,variableArgs:!1},t.B={id:_util.OPS.fillStroke,numArgs:0,variableArgs:!1},t["B*"]={id:_util.OPS.eoFillStroke,numArgs:0,variableArgs:!1},t.b={id:_util.OPS.closeFillStroke,numArgs:0,variableArgs:!1},t["b*"]={id:_util.OPS.closeEOFillStroke,numArgs:0,variableArgs:!1},t.n={id:_util.OPS.endPath,numArgs:0,variableArgs:!1},t.W={id:_util.OPS.clip,numArgs:0,variableArgs:!1},t["W*"]={id:_util.OPS.eoClip,numArgs:0,variableArgs:!1},t.BT={id:_util.OPS.beginText,numArgs:0,variableArgs:!1},t.ET={id:_util.OPS.endText,numArgs:0,variableArgs:!1},t.Tc={id:_util.OPS.setCharSpacing,numArgs:1,variableArgs:!1},t.Tw={id:_util.OPS.setWordSpacing,numArgs:1,variableArgs:!1},t.Tz={id:_util.OPS.setHScale,numArgs:1,variableArgs:!1},t.TL={id:_util.OPS.setLeading,numArgs:1,variableArgs:!1},t.Tf={id:_util.OPS.setFont,numArgs:2,variableArgs:!1},t.Tr={id:_util.OPS.setTextRenderingMode,numArgs:1,variableArgs:!1},t.Ts={id:_util.OPS.setTextRise,numArgs:1,variableArgs:!1},t.Td={id:_util.OPS.moveText,numArgs:2,variableArgs:!1},t.TD={id:_util.OPS.setLeadingMoveText,numArgs:2,variableArgs:!1},t.Tm={id:_util.OPS.setTextMatrix,numArgs:6,variableArgs:!1},t["T*"]={id:_util.OPS.nextLine,numArgs:0,variableArgs:!1},t.Tj={id:_util.OPS.showText,numArgs:1,variableArgs:!1},t.TJ={id:_util.OPS.showSpacedText,numArgs:1,variableArgs:!1},t["'"]={id:_util.OPS.nextLineShowText,numArgs:1,variableArgs:!1},t['"']={id:_util.OPS.nextLineSetSpacingShowText,numArgs:3,variableArgs:!1},t.d0={id:_util.OPS.setCharWidth,numArgs:2,variableArgs:!1},t.d1={id:_util.OPS.setCharWidthAndBounds,numArgs:6,variableArgs:!1},t.CS={id:_util.OPS.setStrokeColorSpace,numArgs:1,variableArgs:!1},t.cs={id:_util.OPS.setFillColorSpace,numArgs:1,variableArgs:!1},t.SC={id:_util.OPS.setStrokeColor,numArgs:4,variableArgs:!0},t.SCN={id:_util.OPS.setStrokeColorN,numArgs:33,variableArgs:!0},t.sc={id:_util.OPS.setFillColor,numArgs:4,variableArgs:!0},t.scn={id:_util.OPS.setFillColorN,numArgs:33,variableArgs:!0},t.G={id:_util.OPS.setStrokeGray,numArgs:1,variableArgs:!1},t.g={id:_util.OPS.setFillGray,numArgs:1,variableArgs:!1},t.RG={id:_util.OPS.setStrokeRGBColor,numArgs:3,variableArgs:!1},t.rg={id:_util.OPS.setFillRGBColor,numArgs:3,variableArgs:!1},t.K={id:_util.OPS.setStrokeCMYKColor,numArgs:4,variableArgs:!1},t.k={id:_util.OPS.setFillCMYKColor,numArgs:4,variableArgs:!1},t.sh={id:_util.OPS.shadingFill,numArgs:1,variableArgs:!1},t.BI={id:_util.OPS.beginInlineImage,numArgs:0,variableArgs:!1},t.ID={id:_util.OPS.beginImageData,numArgs:0,variableArgs:!1},t.EI={id:_util.OPS.endInlineImage,numArgs:1,variableArgs:!1},t.Do={id:_util.OPS.paintXObject,numArgs:1,variableArgs:!1},t.MP={id:_util.OPS.markPoint,numArgs:1,variableArgs:!1},t.DP={id:_util.OPS.markPointProps,numArgs:2,variableArgs:!1},t.BMC={id:_util.OPS.beginMarkedContent,numArgs:1,variableArgs:!1},t.BDC={id:_util.OPS.beginMarkedContentProps,numArgs:2,variableArgs:!1},t.EMC={id:_util.OPS.endMarkedContent,numArgs:0,variableArgs:!1},t.BX={id:_util.OPS.beginCompat,numArgs:0,variableArgs:!1},t.EX={id:_util.OPS.endCompat,numArgs:0,variableArgs:!1},t.BM=null,t.BD=null,t.true=null,t.fa=null,t.fal=null,t.fals=null,t.false=null,t.nu=null,t.nul=null,t.null=null}));return(0,_util.shadow)(this,"opMap",t())}static get MAX_INVALID_PATH_OPS(){return(0,_util.shadow)(this,"MAX_INVALID_PATH_OPS",20)}constructor(t,e,i=new StateManager){this.parser=new _parser.Parser({lexer:new _parser.Lexer(t,EvaluatorPreprocessor.opMap),xref:e}),this.stateManager=i,this.nonProcessedArgs=[],this._numInvalidPathOPS=0}get savedStatesDepth(){return this.stateManager.stateStack.length}read(t){let e=t.args;while(1){const i=this.parser.getObj();if(i instanceof _primitives.Cmd){const r=i.cmd,a=EvaluatorPreprocessor.opMap[r];if(!a){(0,_util.warn)(`Unknown command "${r}".`);continue}const n=a.id,s=a.numArgs;let o=null!==e?e.length:0;if(a.variableArgs)o>s&&(0,_util.info)(`Command ${r}: expected [0, ${s}] args, but received ${o} args.`);else{if(o!==s){const t=this.nonProcessedArgs;while(o>s)t.push(e.shift()),o--;while(o<s&&0!==t.length)null===e&&(e=[]),e.unshift(t.pop()),o++}if(o<s){const t=`command ${r}: expected ${s} args, but received ${o} args.`;if(n>=_util.OPS.moveTo&&n<=_util.OPS.endPath&&++this._numInvalidPathOPS>EvaluatorPreprocessor.MAX_INVALID_PATH_OPS)throw new _util.FormatError(`Invalid ${t}`);(0,_util.warn)(`Skipping ${t}`),null!==e&&(e.length=0);continue}}return this.preprocessCommand(n,e),t.fn=n,t.args=e,!0}if(i===_primitives.EOF)return!1;if(null!==i&&(null===e&&(e=[]),e.push(i),e.length>33))throw new _util.FormatError("Too many arguments")}}preprocessCommand(t,e){switch(0|t){case _util.OPS.save:this.stateManager.save();break;case _util.OPS.restore:this.stateManager.restore();break;case _util.OPS.transform:this.stateManager.transform(e);break}}}exports.EvaluatorPreprocessor=EvaluatorPreprocessor;