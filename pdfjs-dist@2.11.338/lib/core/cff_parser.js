"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CFFTopDict=exports.CFFStrings=exports.CFFStandardStrings=exports.CFFPrivateDict=exports.CFFParser=exports.CFFIndex=exports.CFFHeader=exports.CFFFDSelect=exports.CFFCompiler=exports.CFFCharset=exports.CFF=void 0;var _util=require("../shared/util.js"),_charsets=require("./charsets.js"),_encodings=require("./encodings.js");const MAX_SUBR_NESTING=10,CFFStandardStrings=[".notdef","space","exclam","quotedbl","numbersign","dollar","percent","ampersand","quoteright","parenleft","parenright","asterisk","plus","comma","hyphen","period","slash","zero","one","two","three","four","five","six","seven","eight","nine","colon","semicolon","less","equal","greater","question","at","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","bracketleft","backslash","bracketright","asciicircum","underscore","quoteleft","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","braceleft","bar","braceright","asciitilde","exclamdown","cent","sterling","fraction","yen","florin","section","currency","quotesingle","quotedblleft","guillemotleft","guilsinglleft","guilsinglright","fi","fl","endash","dagger","daggerdbl","periodcentered","paragraph","bullet","quotesinglbase","quotedblbase","quotedblright","guillemotright","ellipsis","perthousand","questiondown","grave","acute","circumflex","tilde","macron","breve","dotaccent","dieresis","ring","cedilla","hungarumlaut","ogonek","caron","emdash","AE","ordfeminine","Lslash","Oslash","OE","ordmasculine","ae","dotlessi","lslash","oslash","oe","germandbls","onesuperior","logicalnot","mu","trademark","Eth","onehalf","plusminus","Thorn","onequarter","divide","brokenbar","degree","thorn","threequarters","twosuperior","registered","minus","eth","multiply","threesuperior","copyright","Aacute","Acircumflex","Adieresis","Agrave","Aring","Atilde","Ccedilla","Eacute","Ecircumflex","Edieresis","Egrave","Iacute","Icircumflex","Idieresis","Igrave","Ntilde","Oacute","Ocircumflex","Odieresis","Ograve","Otilde","Scaron","Uacute","Ucircumflex","Udieresis","Ugrave","Yacute","Ydieresis","Zcaron","aacute","acircumflex","adieresis","agrave","aring","atilde","ccedilla","eacute","ecircumflex","edieresis","egrave","iacute","icircumflex","idieresis","igrave","ntilde","oacute","ocircumflex","odieresis","ograve","otilde","scaron","uacute","ucircumflex","udieresis","ugrave","yacute","ydieresis","zcaron","exclamsmall","Hungarumlautsmall","dollaroldstyle","dollarsuperior","ampersandsmall","Acutesmall","parenleftsuperior","parenrightsuperior","twodotenleader","onedotenleader","zerooldstyle","oneoldstyle","twooldstyle","threeoldstyle","fouroldstyle","fiveoldstyle","sixoldstyle","sevenoldstyle","eightoldstyle","nineoldstyle","commasuperior","threequartersemdash","periodsuperior","questionsmall","asuperior","bsuperior","centsuperior","dsuperior","esuperior","isuperior","lsuperior","msuperior","nsuperior","osuperior","rsuperior","ssuperior","tsuperior","ff","ffi","ffl","parenleftinferior","parenrightinferior","Circumflexsmall","hyphensuperior","Gravesmall","Asmall","Bsmall","Csmall","Dsmall","Esmall","Fsmall","Gsmall","Hsmall","Ismall","Jsmall","Ksmall","Lsmall","Msmall","Nsmall","Osmall","Psmall","Qsmall","Rsmall","Ssmall","Tsmall","Usmall","Vsmall","Wsmall","Xsmall","Ysmall","Zsmall","colonmonetary","onefitted","rupiah","Tildesmall","exclamdownsmall","centoldstyle","Lslashsmall","Scaronsmall","Zcaronsmall","Dieresissmall","Brevesmall","Caronsmall","Dotaccentsmall","Macronsmall","figuredash","hypheninferior","Ogoneksmall","Ringsmall","Cedillasmall","questiondownsmall","oneeighth","threeeighths","fiveeighths","seveneighths","onethird","twothirds","zerosuperior","foursuperior","fivesuperior","sixsuperior","sevensuperior","eightsuperior","ninesuperior","zeroinferior","oneinferior","twoinferior","threeinferior","fourinferior","fiveinferior","sixinferior","seveninferior","eightinferior","nineinferior","centinferior","dollarinferior","periodinferior","commainferior","Agravesmall","Aacutesmall","Acircumflexsmall","Atildesmall","Adieresissmall","Aringsmall","AEsmall","Ccedillasmall","Egravesmall","Eacutesmall","Ecircumflexsmall","Edieresissmall","Igravesmall","Iacutesmall","Icircumflexsmall","Idieresissmall","Ethsmall","Ntildesmall","Ogravesmall","Oacutesmall","Ocircumflexsmall","Otildesmall","Odieresissmall","OEsmall","Oslashsmall","Ugravesmall","Uacutesmall","Ucircumflexsmall","Udieresissmall","Yacutesmall","Thornsmall","Ydieresissmall","001.000","001.001","001.002","001.003","Black","Bold","Book","Light","Medium","Regular","Roman","Semibold"];exports.CFFStandardStrings=CFFStandardStrings;const NUM_STANDARD_CFF_STRINGS=391,CFFParser=function(){const e=[null,{id:"hstem",min:2,stackClearing:!0,stem:!0},null,{id:"vstem",min:2,stackClearing:!0,stem:!0},{id:"vmoveto",min:1,stackClearing:!0},{id:"rlineto",min:2,resetStack:!0},{id:"hlineto",min:1,resetStack:!0},{id:"vlineto",min:1,resetStack:!0},{id:"rrcurveto",min:6,resetStack:!0},null,{id:"callsubr",min:1,undefStack:!0},{id:"return",min:0,undefStack:!0},null,null,{id:"endchar",min:0,stackClearing:!0},null,null,null,{id:"hstemhm",min:2,stackClearing:!0,stem:!0},{id:"hintmask",min:0,stackClearing:!0},{id:"cntrmask",min:0,stackClearing:!0},{id:"rmoveto",min:2,stackClearing:!0},{id:"hmoveto",min:1,stackClearing:!0},{id:"vstemhm",min:2,stackClearing:!0,stem:!0},{id:"rcurveline",min:8,resetStack:!0},{id:"rlinecurve",min:8,resetStack:!0},{id:"vvcurveto",min:4,resetStack:!0},{id:"hhcurveto",min:4,resetStack:!0},null,{id:"callgsubr",min:1,undefStack:!0},{id:"vhcurveto",min:4,resetStack:!0},{id:"hvcurveto",min:4,resetStack:!0}],t=[null,null,null,{id:"and",min:2,stackDelta:-1},{id:"or",min:2,stackDelta:-1},{id:"not",min:1,stackDelta:0},null,null,null,{id:"abs",min:1,stackDelta:0},{id:"add",min:2,stackDelta:-1,stackFn:function(e,t){e[t-2]=e[t-2]+e[t-1]}},{id:"sub",min:2,stackDelta:-1,stackFn:function(e,t){e[t-2]=e[t-2]-e[t-1]}},{id:"div",min:2,stackDelta:-1,stackFn:function(e,t){e[t-2]=e[t-2]/e[t-1]}},null,{id:"neg",min:1,stackDelta:0,stackFn:function(e,t){e[t-1]=-e[t-1]}},{id:"eq",min:2,stackDelta:-1},null,null,{id:"drop",min:1,stackDelta:-1},null,{id:"put",min:2,stackDelta:-2},{id:"get",min:1,stackDelta:0},{id:"ifelse",min:4,stackDelta:-3},{id:"random",min:0,stackDelta:1},{id:"mul",min:2,stackDelta:-1,stackFn:function(e,t){e[t-2]=e[t-2]*e[t-1]}},null,{id:"sqrt",min:1,stackDelta:0},{id:"dup",min:1,stackDelta:1},{id:"exch",min:2,stackDelta:0},{id:"index",min:2,stackDelta:0},{id:"roll",min:3,stackDelta:-2},null,null,null,{id:"hflex",min:7,resetStack:!0},{id:"flex",min:13,resetStack:!0},{id:"hflex1",min:9,resetStack:!0},{id:"flex1",min:11,resetStack:!0}];class s{constructor(e,t,s){this.bytes=e.getBytes(),this.properties=t,this.seacAnalysisEnabled=!!s}parse(){const e=this.properties,t=new CFF;this.cff=t;const s=this.parseHeader(),r=this.parseIndex(s.endPos),n=this.parseIndex(r.endPos),i=this.parseIndex(n.endPos),a=this.parseIndex(i.endPos),l=this.parseDict(n.obj.get(0)),o=this.createDict(CFFTopDict,l,t.strings);t.header=s.obj,t.names=this.parseNameIndex(r.obj),t.strings=this.parseStringIndex(i.obj),t.topDict=o,t.globalSubrIndex=a.obj,this.parsePrivateDict(t.topDict),t.isCIDFont=o.hasName("ROS");const c=o.getByName("CharStrings"),u=this.parseIndex(c).obj,d=o.getByName("FontMatrix");d&&(e.fontMatrix=d);const h=o.getByName("FontBBox");let m,f;if(h&&(e.ascent=Math.max(h[3],h[1]),e.descent=Math.min(h[1],h[3]),e.ascentScaled=!0),t.isCIDFont){const e=this.parseIndex(o.getByName("FDArray")).obj;for(let s=0,r=e.count;s<r;++s){const r=e.get(s),n=this.createDict(CFFTopDict,this.parseDict(r),t.strings);this.parsePrivateDict(n),t.fdArray.push(n)}f=null,m=this.parseCharsets(o.getByName("charset"),u.count,t.strings,!0),t.fdSelect=this.parseFDSelect(o.getByName("FDSelect"),u.count)}else m=this.parseCharsets(o.getByName("charset"),u.count,t.strings,!1),f=this.parseEncoding(o.getByName("Encoding"),e,t.strings,m.charset);t.charset=m,t.encoding=f;const g=this.parseCharStrings({charStrings:u,localSubrIndex:o.privateDict.subrsIndex,globalSubrIndex:a.obj,fdSelect:t.fdSelect,fdArray:t.fdArray,privateDict:o.privateDict});return t.charStrings=g.charStrings,t.seacs=g.seacs,t.widths=g.widths,t}parseHeader(){let e=this.bytes;const t=e.length;let s=0;while(s<t&&1!==e[s])++s;if(s>=t)throw new _util.FormatError("Invalid CFF header");0!==s&&((0,_util.info)("cff data is shifted"),e=e.subarray(s),this.bytes=e);const r=e[0],n=e[1],i=e[2],a=e[3],l=new CFFHeader(r,n,i,a);return{obj:l,endPos:i}}parseDict(e){let t=0;function s(){let s=e[t++];return 30===s?r():28===s?(s=e[t++],s=(s<<24|e[t++]<<16)>>16,s):29===s?(s=e[t++],s=s<<8|e[t++],s=s<<8|e[t++],s=s<<8|e[t++],s):s>=32&&s<=246?s-139:s>=247&&s<=250?256*(s-247)+e[t++]+108:s>=251&&s<=254?-256*(s-251)-e[t++]-108:((0,_util.warn)('CFFParser_parseDict: "'+s+'" is a reserved command.'),NaN)}function r(){let s="";const r=15,n=["0","1","2","3","4","5","6","7","8","9",".","E","E-",null,"-"],i=e.length;while(t<i){const i=e[t++],a=i>>4,l=15&i;if(a===r)break;if(s+=n[a],l===r)break;s+=n[l]}return parseFloat(s)}let n=[];const i=[];t=0;const a=e.length;while(t<a){let r=e[t];r<=21?(12===r&&(r=r<<8|e[++t]),i.push([r,n]),n=[],++t):n.push(s())}return i}parseIndex(e){const t=new CFFIndex,s=this.bytes,r=s[e++]<<8|s[e++],n=[];let i,a,l=e;if(0!==r){const t=s[e++],o=e+(r+1)*t-1;for(i=0,a=r+1;i<a;++i){let r=0;for(let n=0;n<t;++n)r<<=8,r+=s[e++];n.push(o+r)}l=n[r]}for(i=0,a=n.length-1;i<a;++i){const e=n[i],r=n[i+1];t.add(s.subarray(e,r))}return{obj:t,endPos:l}}parseNameIndex(e){const t=[];for(let s=0,r=e.count;s<r;++s){const r=e.get(s);t.push((0,_util.bytesToString)(r))}return t}parseStringIndex(e){const t=new CFFStrings;for(let s=0,r=e.count;s<r;++s){const r=e.get(s);t.add((0,_util.bytesToString)(r))}return t}createDict(e,t,s){const r=new e(s);for(let n=0,i=t.length;n<i;++n){const e=t[n],s=e[0],i=e[1];r.setByKey(s,i)}return r}parseCharString(s,r,n,i){if(!r||s.callDepth>MAX_SUBR_NESTING)return!1;let a=s.stackSize;const l=s.stack,o=r.length;for(let c=0;c<o;){const o=r[c++];let u=null;if(12===o){const e=r[c++];0===e?(r[c-2]=139,r[c-1]=22,a=0):u=t[e]}else if(28===o)l[a]=(r[c]<<24|r[c+1]<<16)>>16,c+=2,a++;else if(14===o){if(a>=4&&(a-=4,this.seacAnalysisEnabled))return s.seac=l.slice(a,a+4),!1;u=e[o]}else if(o>=32&&o<=246)l[a]=o-139,a++;else if(o>=247&&o<=254)l[a]=o<251?(o-247<<8)+r[c]+108:-(o-251<<8)-r[c]-108,c++,a++;else if(255===o)l[a]=(r[c]<<24|r[c+1]<<16|r[c+2]<<8|r[c+3])/65536,c+=4,a++;else if(19===o||20===o)s.hints+=a>>1,c+=s.hints+7>>3,a%=2,u=e[o];else{if(10===o||29===o){let t;if(t=10===o?n:i,!t)return u=e[o],(0,_util.warn)("Missing subrsIndex for "+u.id),!1;let r=32768;t.count<1240?r=107:t.count<33900&&(r=1131);const c=l[--a]+r;if(c<0||c>=t.count||isNaN(c))return u=e[o],(0,_util.warn)("Out of bounds subrIndex for "+u.id),!1;s.stackSize=a,s.callDepth++;const d=this.parseCharString(s,t.get(c),n,i);if(!d)return!1;s.callDepth--,a=s.stackSize;continue}if(11===o)return s.stackSize=a,!0;0===o&&c===r.length?(r[c-1]=14,u=e[14]):u=e[o]}if(u){if(u.stem&&(s.hints+=a>>1,3===o||23===o?s.hasVStems=!0:!s.hasVStems||1!==o&&18!==o||((0,_util.warn)("CFF stem hints are in wrong order"),r[c-1]=1===o?3:23)),"min"in u&&!s.undefStack&&a<u.min)return(0,_util.warn)("Not enough parameters for "+u.id+"; actual: "+a+", expected: "+u.min),0===a&&(r[c-1]=14,!0);s.firstStackClearing&&u.stackClearing&&(s.firstStackClearing=!1,a-=u.min,a>=2&&u.stem?a%=2:a>1&&(0,_util.warn)("Found too many parameters for stack-clearing command"),a>0&&(s.width=l[a-1])),"stackDelta"in u?("stackFn"in u&&u.stackFn(l,a),a+=u.stackDelta):u.stackClearing?a=0:u.resetStack?(a=0,s.undefStack=!1):u.undefStack&&(a=0,s.undefStack=!0,s.firstStackClearing=!1)}}return s.stackSize=a,!0}parseCharStrings({charStrings:e,localSubrIndex:t,globalSubrIndex:s,fdSelect:r,fdArray:n,privateDict:i}){const a=[],l=[],o=e.count;for(let c=0;c<o;c++){const o=e.get(c),u={callDepth:0,stackSize:0,stack:[],undefStack:!0,hints:0,firstStackClearing:!0,seac:null,width:null,hasVStems:!1};let d=!0,h=null,m=i;if(r&&n.length){const e=r.getFDIndex(c);-1===e&&((0,_util.warn)("Glyph index is not in fd select."),d=!1),e>=n.length&&((0,_util.warn)("Invalid fd index for glyph index."),d=!1),d&&(m=n[e].privateDict,h=m.subrsIndex)}else t&&(h=t);if(d&&(d=this.parseCharString(u,o,h,s)),null!==u.width){const e=m.getByName("nominalWidthX");l[c]=e+u.width}else{const e=m.getByName("defaultWidthX");l[c]=e}null!==u.seac&&(a[c]=u.seac),d||e.set(c,new Uint8Array([14]))}return{charStrings:e,seacs:a,widths:l}}emptyPrivateDictionary(e){const t=this.createDict(CFFPrivateDict,[],e.strings);e.setByKey(18,[0,0]),e.privateDict=t}parsePrivateDict(e){if(!e.hasName("Private"))return void this.emptyPrivateDictionary(e);const t=e.getByName("Private");if(!Array.isArray(t)||2!==t.length)return void e.removeByName("Private");const s=t[0],r=t[1];if(0===s||r>=this.bytes.length)return void this.emptyPrivateDictionary(e);const n=r+s,i=this.bytes.subarray(r,n),a=this.parseDict(i),l=this.createDict(CFFPrivateDict,a,e.strings);if(e.privateDict=l,!l.getByName("Subrs"))return;const o=l.getByName("Subrs"),c=r+o;if(0===o||c>=this.bytes.length)return void this.emptyPrivateDictionary(e);const u=this.parseIndex(c);l.subrsIndex=u.obj}parseCharsets(e,t,s,r){if(0===e)return new CFFCharset(!0,CFFCharsetPredefinedTypes.ISO_ADOBE,_charsets.ISOAdobeCharset);if(1===e)return new CFFCharset(!0,CFFCharsetPredefinedTypes.EXPERT,_charsets.ExpertCharset);if(2===e)return new CFFCharset(!0,CFFCharsetPredefinedTypes.EXPERT_SUBSET,_charsets.ExpertSubsetCharset);const n=this.bytes,i=e,a=n[e++],l=[r?0:".notdef"];let o,c,u;switch(t-=1,a){case 0:for(u=0;u<t;u++)o=n[e++]<<8|n[e++],l.push(r?o:s.get(o));break;case 1:while(l.length<=t)for(o=n[e++]<<8|n[e++],c=n[e++],u=0;u<=c;u++)l.push(r?o++:s.get(o++));break;case 2:while(l.length<=t)for(o=n[e++]<<8|n[e++],c=n[e++]<<8|n[e++],u=0;u<=c;u++)l.push(r?o++:s.get(o++));break;default:throw new _util.FormatError("Unknown charset format")}const d=e,h=n.subarray(i,d);return new CFFCharset(!1,a,l,h)}parseEncoding(e,t,s,r){const n=Object.create(null),i=this.bytes;let a,l,o,c=!1,u=null;function d(){const t=i[e++];for(l=0;l<t;l++){const t=i[e++],a=(i[e++]<<8)+(255&i[e++]);n[t]=r.indexOf(s.get(a))}}if(0===e||1===e){c=!0,a=e;const t=e?_encodings.ExpertEncoding:_encodings.StandardEncoding;for(l=0,o=r.length;l<o;l++){const e=t.indexOf(r[l]);-1!==e&&(n[e]=l)}}else{const t=e;switch(a=i[e++],127&a){case 0:const t=i[e++];for(l=1;l<=t;l++)n[i[e++]]=l;break;case 1:const s=i[e++];let r=1;for(l=0;l<s;l++){const t=i[e++],s=i[e++];for(let e=t;e<=t+s;e++)n[e]=r++}break;default:throw new _util.FormatError(`Unknown encoding format: ${a} in CFF`)}const s=e;128&a&&(i[t]&=127,d()),u=i.subarray(t,s)}return a&=127,new CFFEncoding(c,a,n,u)}parseFDSelect(e,t){const s=this.bytes,r=s[e++],n=[];let i;switch(r){case 0:for(i=0;i<t;++i){const t=s[e++];n.push(t)}break;case 3:const a=s[e++]<<8|s[e++];for(i=0;i<a;++i){let t=s[e++]<<8|s[e++];0===i&&0!==t&&((0,_util.warn)("parseFDSelect: The first range must have a first GID of 0 -- trying to recover."),t=0);const r=s[e++],a=s[e]<<8|s[e+1];for(let e=t;e<a;++e)n.push(r)}e+=2;break;default:throw new _util.FormatError(`parseFDSelect: Unknown format "${r}".`)}if(n.length!==t)throw new _util.FormatError("parseFDSelect: Invalid font data.");return new CFFFDSelect(r,n)}}return s}();exports.CFFParser=CFFParser;class CFF{constructor(){this.header=null,this.names=[],this.topDict=null,this.strings=new CFFStrings,this.globalSubrIndex=null,this.encoding=null,this.charset=null,this.charStrings=null,this.fdArray=[],this.fdSelect=null,this.isCIDFont=!1}duplicateFirstGlyph(){if(this.charStrings.count>=65535)return void(0,_util.warn)("Not enough space in charstrings to duplicate first glyph.");const e=this.charStrings.get(0);this.charStrings.add(e),this.isCIDFont&&this.fdSelect.fdSelect.push(this.fdSelect.fdSelect[0])}hasGlyphId(e){if(e<0||e>=this.charStrings.count)return!1;const t=this.charStrings.get(e);return t.length>0}}exports.CFF=CFF;class CFFHeader{constructor(e,t,s,r){this.major=e,this.minor=t,this.hdrSize=s,this.offSize=r}}exports.CFFHeader=CFFHeader;class CFFStrings{constructor(){this.strings=[]}get(e){return e>=0&&e<=NUM_STANDARD_CFF_STRINGS-1?CFFStandardStrings[e]:e-NUM_STANDARD_CFF_STRINGS<=this.strings.length?this.strings[e-NUM_STANDARD_CFF_STRINGS]:CFFStandardStrings[0]}getSID(e){let t=CFFStandardStrings.indexOf(e);return-1!==t?t:(t=this.strings.indexOf(e),-1!==t?t+NUM_STANDARD_CFF_STRINGS:-1)}add(e){this.strings.push(e)}get count(){return this.strings.length}}exports.CFFStrings=CFFStrings;class CFFIndex{constructor(){this.objects=[],this.length=0}add(e){this.length+=e.length,this.objects.push(e)}set(e,t){this.length+=t.length-this.objects[e].length,this.objects[e]=t}get(e){return this.objects[e]}get count(){return this.objects.length}}exports.CFFIndex=CFFIndex;class CFFDict{constructor(e,t){this.keyToNameMap=e.keyToNameMap,this.nameToKeyMap=e.nameToKeyMap,this.defaults=e.defaults,this.types=e.types,this.opcodes=e.opcodes,this.order=e.order,this.strings=t,this.values=Object.create(null)}setByKey(e,t){if(!(e in this.keyToNameMap))return!1;const s=t.length;if(0===s)return!0;for(let n=0;n<s;n++)if(isNaN(t[n]))return(0,_util.warn)('Invalid CFFDict value: "'+t+'" for key "'+e+'".'),!0;const r=this.types[e];return"num"!==r&&"sid"!==r&&"offset"!==r||(t=t[0]),this.values[e]=t,!0}setByName(e,t){if(!(e in this.nameToKeyMap))throw new _util.FormatError(`Invalid dictionary name "${e}"`);this.values[this.nameToKeyMap[e]]=t}hasName(e){return this.nameToKeyMap[e]in this.values}getByName(e){if(!(e in this.nameToKeyMap))throw new _util.FormatError(`Invalid dictionary name ${e}"`);const t=this.nameToKeyMap[e];return t in this.values?this.values[t]:this.defaults[t]}removeByName(e){delete this.values[this.nameToKeyMap[e]]}static createTables(e){const t={keyToNameMap:{},nameToKeyMap:{},defaults:{},types:{},opcodes:{},order:[]};for(let s=0,r=e.length;s<r;++s){const r=e[s],n=Array.isArray(r[0])?(r[0][0]<<8)+r[0][1]:r[0];t.keyToNameMap[n]=r[1],t.nameToKeyMap[r[1]]=n,t.types[n]=r[2],t.defaults[n]=r[3],t.opcodes[n]=Array.isArray(r[0])?r[0]:[r[0]],t.order.push(n)}return t}}const CFFTopDict=function(){const e=[[[12,30],"ROS",["sid","sid","num"],null],[[12,20],"SyntheticBase","num",null],[0,"version","sid",null],[1,"Notice","sid",null],[[12,0],"Copyright","sid",null],[2,"FullName","sid",null],[3,"FamilyName","sid",null],[4,"Weight","sid",null],[[12,1],"isFixedPitch","num",0],[[12,2],"ItalicAngle","num",0],[[12,3],"UnderlinePosition","num",-100],[[12,4],"UnderlineThickness","num",50],[[12,5],"PaintType","num",0],[[12,6],"CharstringType","num",2],[[12,7],"FontMatrix",["num","num","num","num","num","num"],[.001,0,0,.001,0,0]],[13,"UniqueID","num",null],[5,"FontBBox",["num","num","num","num"],[0,0,0,0]],[[12,8],"StrokeWidth","num",0],[14,"XUID","array",null],[15,"charset","offset",0],[16,"Encoding","offset",0],[17,"CharStrings","offset",0],[18,"Private",["offset","offset"],null],[[12,21],"PostScript","sid",null],[[12,22],"BaseFontName","sid",null],[[12,23],"BaseFontBlend","delta",null],[[12,31],"CIDFontVersion","num",0],[[12,32],"CIDFontRevision","num",0],[[12,33],"CIDFontType","num",0],[[12,34],"CIDCount","num",8720],[[12,35],"UIDBase","num",null],[[12,37],"FDSelect","offset",null],[[12,36],"FDArray","offset",null],[[12,38],"FontName","sid",null]];let t=null;class s extends CFFDict{constructor(s){null===t&&(t=CFFDict.createTables(e)),super(t,s),this.privateDict=null}}return s}();exports.CFFTopDict=CFFTopDict;const CFFPrivateDict=function(){const e=[[6,"BlueValues","delta",null],[7,"OtherBlues","delta",null],[8,"FamilyBlues","delta",null],[9,"FamilyOtherBlues","delta",null],[[12,9],"BlueScale","num",.039625],[[12,10],"BlueShift","num",7],[[12,11],"BlueFuzz","num",1],[10,"StdHW","num",null],[11,"StdVW","num",null],[[12,12],"StemSnapH","delta",null],[[12,13],"StemSnapV","delta",null],[[12,14],"ForceBold","num",0],[[12,17],"LanguageGroup","num",0],[[12,18],"ExpansionFactor","num",.06],[[12,19],"initialRandomSeed","num",0],[20,"defaultWidthX","num",0],[21,"nominalWidthX","num",0],[19,"Subrs","offset",null]];let t=null;class s extends CFFDict{constructor(s){null===t&&(t=CFFDict.createTables(e)),super(t,s),this.subrsIndex=null}}return s}();exports.CFFPrivateDict=CFFPrivateDict;const CFFCharsetPredefinedTypes={ISO_ADOBE:0,EXPERT:1,EXPERT_SUBSET:2};class CFFCharset{constructor(e,t,s,r){this.predefined=e,this.format=t,this.charset=s,this.raw=r}}exports.CFFCharset=CFFCharset;class CFFEncoding{constructor(e,t,s,r){this.predefined=e,this.format=t,this.encoding=s,this.raw=r}}class CFFFDSelect{constructor(e,t){this.format=e,this.fdSelect=t}getFDIndex(e){return e<0||e>=this.fdSelect.length?-1:this.fdSelect[e]}}exports.CFFFDSelect=CFFFDSelect;class CFFOffsetTracker{constructor(){this.offsets=Object.create(null)}isTracking(e){return e in this.offsets}track(e,t){if(e in this.offsets)throw new _util.FormatError(`Already tracking location of ${e}`);this.offsets[e]=t}offset(e){for(const t in this.offsets)this.offsets[t]+=e}setEntryLocation(e,t,s){if(!(e in this.offsets))throw new _util.FormatError(`Not tracking location of ${e}`);const r=s.data,n=this.offsets[e],i=5;for(let a=0,l=t.length;a<l;++a){const e=a*i+n,s=e+1,l=e+2,o=e+3,c=e+4;if(29!==r[e]||0!==r[s]||0!==r[l]||0!==r[o]||0!==r[c])throw new _util.FormatError("writing to an offset that is not empty");const u=t[a];r[e]=29,r[s]=u>>24&255,r[l]=u>>16&255,r[o]=u>>8&255,r[c]=255&u}}}class CFFCompiler{constructor(e){this.cff=e}compile(){const e=this.cff,t={data:[],length:0,add:function(e){this.data=this.data.concat(e),this.length=this.data.length}},s=this.compileHeader(e.header);t.add(s);const r=this.compileNameIndex(e.names);if(t.add(r),e.isCIDFont&&e.topDict.hasName("FontMatrix")){const t=e.topDict.getByName("FontMatrix");e.topDict.removeByName("FontMatrix");for(let s=0,r=e.fdArray.length;s<r;s++){const r=e.fdArray[s];let n=t.slice(0);r.hasName("FontMatrix")&&(n=_util.Util.transform(n,r.getByName("FontMatrix"))),r.setByName("FontMatrix",n)}}const n=e.topDict.getByName("XUID");n&&n.length>16&&e.topDict.removeByName("XUID"),e.topDict.setByName("charset",0);let i=this.compileTopDicts([e.topDict],t.length,e.isCIDFont);t.add(i.output);const a=i.trackers[0],l=this.compileStringIndex(e.strings.strings);t.add(l);const o=this.compileIndex(e.globalSubrIndex);if(t.add(o),e.encoding&&e.topDict.hasName("Encoding"))if(e.encoding.predefined)a.setEntryLocation("Encoding",[e.encoding.format],t);else{const s=this.compileEncoding(e.encoding);a.setEntryLocation("Encoding",[t.length],t),t.add(s)}const c=this.compileCharset(e.charset,e.charStrings.count,e.strings,e.isCIDFont);a.setEntryLocation("charset",[t.length],t),t.add(c);const u=this.compileCharStrings(e.charStrings);if(a.setEntryLocation("CharStrings",[t.length],t),t.add(u),e.isCIDFont){a.setEntryLocation("FDSelect",[t.length],t);const s=this.compileFDSelect(e.fdSelect);t.add(s),i=this.compileTopDicts(e.fdArray,t.length,!0),a.setEntryLocation("FDArray",[t.length],t),t.add(i.output);const r=i.trackers;this.compilePrivateDicts(e.fdArray,r,t)}return this.compilePrivateDicts([e.topDict],[a],t),t.add([0]),t.data}encodeNumber(e){return Number.isInteger(e)?this.encodeInteger(e):this.encodeFloat(e)}static get EncodeFloatRegExp(){return(0,_util.shadow)(this,"EncodeFloatRegExp",/\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/)}encodeFloat(e){let t=e.toString();const s=CFFCompiler.EncodeFloatRegExp.exec(t);if(s){const r=parseFloat("1e"+((s[2]?+s[2]:0)+s[1].length));t=(Math.round(e*r)/r).toString()}let r,n,i="";for(r=0,n=t.length;r<n;++r){const e=t[r];i+="e"===e?"-"===t[++r]?"c":"b":"."===e?"a":"-"===e?"e":e}i+=1&i.length?"f":"ff";const a=[30];for(r=0,n=i.length;r<n;r+=2)a.push(parseInt(i.substring(r,r+2),16));return a}encodeInteger(e){let t;return e>=-107&&e<=107?t=[e+139]:e>=108&&e<=1131?(e-=108,t=[247+(e>>8),255&e]):e>=-1131&&e<=-108?(e=-e-108,t=[251+(e>>8),255&e]):t=e>=-32768&&e<=32767?[28,e>>8&255,255&e]:[29,e>>24&255,e>>16&255,e>>8&255,255&e],t}compileHeader(e){return[e.major,e.minor,4,e.offSize]}compileNameIndex(e){const t=new CFFIndex;for(let s=0,r=e.length;s<r;++s){const r=e[s],n=Math.min(r.length,127);let i=new Array(n);for(let e=0;e<n;e++){let t=r[e];(t<"!"||t>"~"||"["===t||"]"===t||"("===t||")"===t||"{"===t||"}"===t||"<"===t||">"===t||"/"===t||"%"===t)&&(t="_"),i[e]=t}i=i.join(""),""===i&&(i="Bad_Font_Name"),t.add((0,_util.stringToBytes)(i))}return this.compileIndex(t)}compileTopDicts(e,t,s){const r=[];let n=new CFFIndex;for(let i=0,a=e.length;i<a;++i){const a=e[i];s&&(a.removeByName("CIDFontVersion"),a.removeByName("CIDFontRevision"),a.removeByName("CIDFontType"),a.removeByName("CIDCount"),a.removeByName("UIDBase"));const l=new CFFOffsetTracker,o=this.compileDict(a,l);r.push(l),n.add(o),l.offset(t)}return n=this.compileIndex(n,r),{trackers:r,output:n}}compilePrivateDicts(e,t,s){for(let r=0,n=e.length;r<n;++r){const n=e[r],i=n.privateDict;if(!i||!n.hasName("Private"))throw new _util.FormatError("There must be a private dictionary.");const a=new CFFOffsetTracker,l=this.compileDict(i,a);let o=s.length;if(a.offset(o),l.length||(o=0),t[r].setEntryLocation("Private",[l.length,o],s),s.add(l),i.subrsIndex&&i.hasName("Subrs")){const e=this.compileIndex(i.subrsIndex);a.setEntryLocation("Subrs",[l.length],s),s.add(e)}}}compileDict(e,t){let s=[];const r=e.order;for(let n=0;n<r.length;++n){const i=r[n];if(!(i in e.values))continue;let a=e.values[i],l=e.types[i];if(Array.isArray(l)||(l=[l]),Array.isArray(a)||(a=[a]),0!==a.length){for(let r=0,n=l.length;r<n;++r){const n=l[r],o=a[r];switch(n){case"num":case"sid":s=s.concat(this.encodeNumber(o));break;case"offset":const r=e.keyToNameMap[i];t.isTracking(r)||t.track(r,s.length),s=s.concat([29,0,0,0,0]);break;case"array":case"delta":s=s.concat(this.encodeNumber(o));for(let e=1,t=a.length;e<t;++e)s=s.concat(this.encodeNumber(a[e]));break;default:throw new _util.FormatError(`Unknown data type of ${n}`)}}s=s.concat(e.opcodes[i])}}return s}compileStringIndex(e){const t=new CFFIndex;for(let s=0,r=e.length;s<r;++s)t.add((0,_util.stringToBytes)(e[s]));return this.compileIndex(t)}compileGlobalSubrIndex(){const e=this.cff.globalSubrIndex;this.out.writeByteArray(this.compileIndex(e))}compileCharStrings(e){const t=new CFFIndex;for(let s=0;s<e.count;s++){const r=e.get(s);0!==r.length?t.add(r):t.add(new Uint8Array([139,14]))}return this.compileIndex(t)}compileCharset(e,t,s,r){let n;const i=t-1;if(r)n=new Uint8Array([2,0,0,i>>8&255,255&i]);else{const t=1+2*i;n=new Uint8Array(t),n[0]=0;let r=0;const a=e.charset.length;let l=!1;for(let i=1;i<n.length;i+=2){let t=0;if(r<a){const n=e.charset[r++];t=s.getSID(n),-1===t&&(t=0,l||(l=!0,(0,_util.warn)(`Couldn't find ${n} in CFF strings`)))}n[i]=t>>8&255,n[i+1]=255&t}}return this.compileTypedArray(n)}compileEncoding(e){return this.compileTypedArray(e.raw)}compileFDSelect(e){const t=e.format;let s,r;switch(t){case 0:for(s=new Uint8Array(1+e.fdSelect.length),s[0]=t,r=0;r<e.fdSelect.length;r++)s[r+1]=e.fdSelect[r];break;case 3:const n=0;let i=e.fdSelect[0];const a=[t,0,0,n>>8&255,255&n,i];for(r=1;r<e.fdSelect.length;r++){const t=e.fdSelect[r];t!==i&&(a.push(r>>8&255,255&r,t),i=t)}const l=(a.length-3)/3;a[1]=l>>8&255,a[2]=255&l,a.push(r>>8&255,255&r),s=new Uint8Array(a);break}return this.compileTypedArray(s)}compileTypedArray(e){const t=[];for(let s=0,r=e.length;s<r;++s)t[s]=e[s];return t}compileIndex(e,t=[]){const s=e.objects,r=s.length;if(0===r)return[0,0,0];const n=[r>>8&255,255&r];let i,a,l=1;for(i=0;i<r;++i)l+=s[i].length;a=l<256?1:l<65536?2:l<16777216?3:4,n.push(a);let o=1;for(i=0;i<r+1;i++)1===a?n.push(255&o):2===a?n.push(o>>8&255,255&o):3===a?n.push(o>>16&255,o>>8&255,255&o):n.push(o>>>24&255,o>>16&255,o>>8&255,255&o),s[i]&&(o+=s[i].length);for(i=0;i<r;i++){t[i]&&t[i].offset(n.length);for(let e=0,t=s[i].length;e<t;e++)n.push(s[i][e])}return n}}exports.CFFCompiler=CFFCompiler;