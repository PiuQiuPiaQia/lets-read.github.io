"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PostScriptParser=exports.PostScriptLexer=void 0;var _util=require("../shared/util.js"),_primitives=require("./primitives.js"),_core_utils=require("./core_utils.js");class PostScriptParser{constructor(t){this.lexer=t,this.operators=[],this.token=null,this.prev=null}nextToken(){this.prev=this.token,this.token=this.lexer.getToken()}accept(t){return this.token.type===t&&(this.nextToken(),!0)}expect(t){if(this.accept(t))return!0;throw new _util.FormatError(`Unexpected symbol: found ${this.token.type} expected ${t}.`)}parse(){return this.nextToken(),this.expect(PostScriptTokenTypes.LBRACE),this.parseBlock(),this.expect(PostScriptTokenTypes.RBRACE),this.operators}parseBlock(){while(1)if(this.accept(PostScriptTokenTypes.NUMBER))this.operators.push(this.prev.value);else if(this.accept(PostScriptTokenTypes.OPERATOR))this.operators.push(this.prev.value);else{if(!this.accept(PostScriptTokenTypes.LBRACE))return;this.parseCondition()}}parseCondition(){const t=this.operators.length;if(this.operators.push(null,null),this.parseBlock(),this.expect(PostScriptTokenTypes.RBRACE),this.accept(PostScriptTokenTypes.IF))this.operators[t]=this.operators.length,this.operators[t+1]="jz";else{if(!this.accept(PostScriptTokenTypes.LBRACE))throw new _util.FormatError("PS Function: error parsing conditional.");{const e=this.operators.length;this.operators.push(null,null);const s=this.operators.length;this.parseBlock(),this.expect(PostScriptTokenTypes.RBRACE),this.expect(PostScriptTokenTypes.IFELSE),this.operators[e]=this.operators.length,this.operators[e+1]="j",this.operators[t]=s,this.operators[t+1]="jz"}}}}exports.PostScriptParser=PostScriptParser;const PostScriptTokenTypes={LBRACE:0,RBRACE:1,NUMBER:2,OPERATOR:3,IF:4,IFELSE:5};class PostScriptToken{static get opCache(){return(0,_util.shadow)(this,"opCache",Object.create(null))}constructor(t,e){this.type=t,this.value=e}static getOperator(t){const e=PostScriptToken.opCache[t];return e||(PostScriptToken.opCache[t]=new PostScriptToken(PostScriptTokenTypes.OPERATOR,t))}static get LBRACE(){return(0,_util.shadow)(this,"LBRACE",new PostScriptToken(PostScriptTokenTypes.LBRACE,"{"))}static get RBRACE(){return(0,_util.shadow)(this,"RBRACE",new PostScriptToken(PostScriptTokenTypes.RBRACE,"}"))}static get IF(){return(0,_util.shadow)(this,"IF",new PostScriptToken(PostScriptTokenTypes.IF,"IF"))}static get IFELSE(){return(0,_util.shadow)(this,"IFELSE",new PostScriptToken(PostScriptTokenTypes.IFELSE,"IFELSE"))}}class PostScriptLexer{constructor(t){this.stream=t,this.nextChar(),this.strBuf=[]}nextChar(){return this.currentChar=this.stream.getByte()}getToken(){let t=!1,e=this.currentChar;while(1){if(e<0)return _primitives.EOF;if(t)10!==e&&13!==e||(t=!1);else if(37===e)t=!0;else if(!(0,_core_utils.isWhiteSpace)(e))break;e=this.nextChar()}switch(0|e){case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:case 43:case 45:case 46:return new PostScriptToken(PostScriptTokenTypes.NUMBER,this.getNumber());case 123:return this.nextChar(),PostScriptToken.LBRACE;case 125:return this.nextChar(),PostScriptToken.RBRACE}const s=this.strBuf;s.length=0,s[0]=String.fromCharCode(e);while((e=this.nextChar())>=0&&(e>=65&&e<=90||e>=97&&e<=122))s.push(String.fromCharCode(e));const r=s.join("");switch(r.toLowerCase()){case"if":return PostScriptToken.IF;case"ifelse":return PostScriptToken.IFELSE;default:return PostScriptToken.getOperator(r)}}getNumber(){let t=this.currentChar;const e=this.strBuf;e.length=0,e[0]=String.fromCharCode(t);while((t=this.nextChar())>=0){if(!(t>=48&&t<=57||45===t||46===t))break;e.push(String.fromCharCode(t))}const s=parseFloat(e.join(""));if(isNaN(s))throw new _util.FormatError(`Invalid floating point number: ${s}`);return s}}exports.PostScriptLexer=PostScriptLexer;