"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ColorSpace=void 0;var _util=require("../shared/util.js"),_primitives=require("./primitives.js"),_core_utils=require("./core_utils.js");function resizeRgbImage(t,e,r,n,i,s,a){const o=3;a=1!==a?0:a;const c=r/i,l=n/s;let u,h=0;const f=new Uint16Array(i),g=r*o;for(let m=0;m<i;m++)f[m]=Math.floor(m*c)*o;for(let m=0;m<s;m++){const r=Math.floor(m*l)*g;for(let n=0;n<i;n++)u=r+f[n],e[h++]=t[u++],e[h++]=t[u++],e[h++]=t[u++],h+=a}}class ColorSpace{constructor(t,e){this.constructor===ColorSpace&&(0,_util.unreachable)("Cannot initialize ColorSpace."),this.name=t,this.numComps=e}getRgb(t,e){const r=new Uint8ClampedArray(3);return this.getRgbItem(t,e,r,0),r}getRgbItem(t,e,r,n){(0,_util.unreachable)("Should not call ColorSpace.getRgbItem")}getRgbBuffer(t,e,r,n,i,s,a){(0,_util.unreachable)("Should not call ColorSpace.getRgbBuffer")}getOutputLength(t,e){(0,_util.unreachable)("Should not call ColorSpace.getOutputLength")}isPassthrough(t){return!1}isDefaultDecode(t,e){return ColorSpace.isDefaultDecode(t,this.numComps)}fillRgb(t,e,r,n,i,s,a,o,c){const l=e*r;let u=null;const h=1<<a,f=r!==i||e!==n;if(this.isPassthrough(a))u=o;else if(1===this.numComps&&l>h&&"DeviceGray"!==this.name&&"DeviceRGB"!==this.name){const e=a<=8?new Uint8Array(h):new Uint16Array(h);for(let t=0;t<h;t++)e[t]=t;const r=new Uint8ClampedArray(3*h);if(this.getRgbBuffer(e,0,h,r,0,a,0),f){u=new Uint8Array(3*l);let t=0;for(let e=0;e<l;++e){const n=3*o[e];u[t++]=r[n],u[t++]=r[n+1],u[t++]=r[n+2]}}else{let e=0;for(let n=0;n<l;++n){const i=3*o[n];t[e++]=r[i],t[e++]=r[i+1],t[e++]=r[i+2],e+=c}}}else f?(u=new Uint8ClampedArray(3*l),this.getRgbBuffer(o,0,l,u,0,a,0)):this.getRgbBuffer(o,0,n*s,t,0,a,c);if(u)if(f)resizeRgbImage(u,t,e,r,n,i,c);else{let e=0,r=0;for(let i=0,a=n*s;i<a;i++)t[e++]=u[r++],t[e++]=u[r++],t[e++]=u[r++],e+=c}}get usesZeroToOneRange(){return(0,_util.shadow)(this,"usesZeroToOneRange",!0)}static _cache(t,e,r,n){if(!r)throw new Error('ColorSpace._cache - expected "localColorSpaceCache" argument.');if(!n)throw new Error('ColorSpace._cache - expected "parsedColorSpace" argument.');let i,s;t instanceof _primitives.Ref&&(s=t,t=e.fetch(t)),t instanceof _primitives.Name&&(i=t.name),(i||s)&&r.set(i,s,n)}static getCached(t,e,r){if(!r)throw new Error('ColorSpace.getCached - expected "localColorSpaceCache" argument.');if(t instanceof _primitives.Ref){const i=r.getByRef(t);if(i)return i;try{t=e.fetch(t)}catch(n){if(n instanceof _core_utils.MissingDataException)throw n}}if(t instanceof _primitives.Name){const e=r.getByName(t.name);if(e)return e}return null}static async parseAsync({cs:t,xref:e,resources:r=null,pdfFunctionFactory:n,localColorSpaceCache:i}){const s=this._parse(t,e,r,n);return this._cache(t,e,i,s),s}static parse({cs:t,xref:e,resources:r=null,pdfFunctionFactory:n,localColorSpaceCache:i}){const s=this.getCached(t,e,i);if(s)return s;const a=this._parse(t,e,r,n);return this._cache(t,e,i,a),a}static _parse(t,e,r=null,n){if(t=e.fetchIfRef(t),(0,_primitives.isName)(t))switch(t.name){case"DeviceGray":case"G":return this.singletons.gray;case"DeviceRGB":case"RGB":return this.singletons.rgb;case"DeviceCMYK":case"CMYK":return this.singletons.cmyk;case"Pattern":return new PatternCS(null);default:if((0,_primitives.isDict)(r)){const i=r.get("ColorSpace");if((0,_primitives.isDict)(i)){const s=i.get(t.name);if(s){if((0,_primitives.isName)(s))return this._parse(s,e,r,n);t=s;break}}}throw new _util.FormatError(`Unrecognized ColorSpace: ${t.name}`)}if(Array.isArray(t)){const i=e.fetchIfRef(t[0]).name;let s,a,o,c,l,u;switch(i){case"DeviceGray":case"G":return this.singletons.gray;case"DeviceRGB":case"RGB":return this.singletons.rgb;case"DeviceCMYK":case"CMYK":return this.singletons.cmyk;case"CalGray":return s=e.fetchIfRef(t[1]),c=s.getArray("WhitePoint"),l=s.getArray("BlackPoint"),u=s.get("Gamma"),new CalGrayCS(c,l,u);case"CalRGB":s=e.fetchIfRef(t[1]),c=s.getArray("WhitePoint"),l=s.getArray("BlackPoint"),u=s.getArray("Gamma");const h=s.getArray("Matrix");return new CalRGBCS(c,l,u,h);case"ICCBased":const f=e.fetchIfRef(t[1]),g=f.dict;a=g.get("N");const m=g.get("Alternate");if(m){const t=this._parse(m,e,r,n);if(t.numComps===a)return t;(0,_util.warn)("ICCBased color space: Ignoring incorrect /Alternate entry.")}if(1===a)return this.singletons.gray;if(3===a)return this.singletons.rgb;if(4===a)return this.singletons.cmyk;break;case"Pattern":return o=t[1]||null,o&&(o=this._parse(o,e,r,n)),new PatternCS(o);case"Indexed":case"I":o=this._parse(t[1],e,r,n);const p=e.fetchIfRef(t[2])+1,C=e.fetchIfRef(t[3]);return new IndexedCS(o,p,C);case"Separation":case"DeviceN":const b=e.fetchIfRef(t[1]);a=Array.isArray(b)?b.length:1,o=this._parse(t[2],e,r,n);const d=n.create(t[3]);return new AlternateCS(a,o,d);case"Lab":s=e.fetchIfRef(t[1]),c=s.getArray("WhitePoint"),l=s.getArray("BlackPoint");const B=s.getArray("Range");return new LabCS(c,l,B);default:throw new _util.FormatError(`Unimplemented ColorSpace object: ${i}`)}}throw new _util.FormatError(`Unrecognized ColorSpace object: ${t}`)}static isDefaultDecode(t,e){if(!Array.isArray(t))return!0;if(2*e!==t.length)return(0,_util.warn)("The decode map is not the correct length"),!0;for(let r=0,n=t.length;r<n;r+=2)if(0!==t[r]||1!==t[r+1])return!1;return!0}static get singletons(){return(0,_util.shadow)(this,"singletons",{get gray(){return(0,_util.shadow)(this,"gray",new DeviceGrayCS)},get rgb(){return(0,_util.shadow)(this,"rgb",new DeviceRgbCS)},get cmyk(){return(0,_util.shadow)(this,"cmyk",new DeviceCmykCS)}})}}exports.ColorSpace=ColorSpace;class AlternateCS extends ColorSpace{constructor(t,e,r){super("Alternate",t),this.base=e,this.tintFn=r,this.tmpBuf=new Float32Array(e.numComps)}getRgbItem(t,e,r,n){const i=this.tmpBuf;this.tintFn(t,e,i,0),this.base.getRgbItem(i,0,r,n)}getRgbBuffer(t,e,r,n,i,s,a){const o=this.tintFn,c=this.base,l=1/((1<<s)-1),u=c.numComps,h=c.usesZeroToOneRange,f=(c.isPassthrough(8)||!h)&&0===a;let g=f?i:0;const m=f?n:new Uint8ClampedArray(u*r),p=this.numComps,C=new Float32Array(p),b=new Float32Array(u);let d,B;for(d=0;d<r;d++){for(B=0;B<p;B++)C[B]=t[e++]*l;if(o(C,0,b,0),h)for(B=0;B<u;B++)m[g++]=255*b[B];else c.getRgbItem(b,0,m,g),g+=u}f||c.getRgbBuffer(m,0,r,n,i,8,a)}getOutputLength(t,e){return this.base.getOutputLength(t*this.base.numComps/this.numComps,e)}}class PatternCS extends ColorSpace{constructor(t){super("Pattern",null),this.base=t}isDefaultDecode(t,e){(0,_util.unreachable)("Should not call PatternCS.isDefaultDecode")}}class IndexedCS extends ColorSpace{constructor(t,e,r){super("Indexed",1),this.base=t,this.highVal=e;const n=t.numComps*e;if(this.lookup=new Uint8Array(n),(0,_primitives.isStream)(r)){const t=r.getBytes(n);this.lookup.set(t)}else{if("string"!==typeof r)throw new _util.FormatError(`IndexedCS - unrecognized lookup table: ${r}`);for(let t=0;t<n;++t)this.lookup[t]=255&r.charCodeAt(t)}}getRgbItem(t,e,r,n){const i=this.base.numComps,s=t[e]*i;this.base.getRgbBuffer(this.lookup,s,1,r,n,8,0)}getRgbBuffer(t,e,r,n,i,s,a){const o=this.base,c=o.numComps,l=o.getOutputLength(c,a),u=this.lookup;for(let h=0;h<r;++h){const r=t[e++]*c;o.getRgbBuffer(u,r,1,n,i,8,a),i+=l}}getOutputLength(t,e){return this.base.getOutputLength(t*this.base.numComps,e)}isDefaultDecode(t,e){return!Array.isArray(t)||(2!==t.length?((0,_util.warn)("Decode map length is not correct"),!0):!Number.isInteger(e)||e<1?((0,_util.warn)("Bits per component is not correct"),!0):0===t[0]&&t[1]===(1<<e)-1)}}class DeviceGrayCS extends ColorSpace{constructor(){super("DeviceGray",1)}getRgbItem(t,e,r,n){const i=255*t[e];r[n]=r[n+1]=r[n+2]=i}getRgbBuffer(t,e,r,n,i,s,a){const o=255/((1<<s)-1);let c=e,l=i;for(let u=0;u<r;++u){const e=o*t[c++];n[l++]=e,n[l++]=e,n[l++]=e,l+=a}}getOutputLength(t,e){return t*(3+e)}}class DeviceRgbCS extends ColorSpace{constructor(){super("DeviceRGB",3)}getRgbItem(t,e,r,n){r[n]=255*t[e],r[n+1]=255*t[e+1],r[n+2]=255*t[e+2]}getRgbBuffer(t,e,r,n,i,s,a){if(8===s&&0===a)return void n.set(t.subarray(e,e+3*r),i);const o=255/((1<<s)-1);let c=e,l=i;for(let u=0;u<r;++u)n[l++]=o*t[c++],n[l++]=o*t[c++],n[l++]=o*t[c++],l+=a}getOutputLength(t,e){return t*(3+e)/3|0}isPassthrough(t){return 8===t}}const DeviceCmykCS=function(){function t(t,e,r,n,i){const s=t[e]*r,a=t[e+1]*r,o=t[e+2]*r,c=t[e+3]*r;n[i]=255+s*(-4.387332384609988*s+54.48615194189176*a+18.82290502165302*o+212.25662451639585*c-285.2331026137004)+a*(1.7149763477362134*a-5.6096736904047315*o+-17.873870861415444*c-5.497006427196366)+o*(-2.5217340131683033*o-21.248923337353073*c+17.5119270841813)+c*(-21.86122147463605*c-189.48180835922747),n[i+1]=255+s*(8.841041422036149*s+60.118027045597366*a+6.871425592049007*o+31.159100130055922*c-79.2970844816548)+a*(-15.310361306967817*a+17.575251261109482*o+131.35250912493976*c-190.9453302588951)+o*(4.444339102852739*o+9.8632861493405*c-24.86741582555878)+c*(-20.737325471181034*c-187.80453709719578),n[i+2]=255+s*(.8842522430003296*s+8.078677503112928*a+30.89978309703729*o-.23883238689178934*c-14.183576799673286)+a*(10.49593273432072*a+63.02378494754052*o+50.606957656360734*c-112.23884253719248)+o*(.03296041114873217*o+115.60384449646641*c-193.58209356861505)+c*(-22.33816807309886*c-180.12613974708367)}class e extends ColorSpace{constructor(){super("DeviceCMYK",4)}getRgbItem(e,r,n,i){t(e,r,1,n,i)}getRgbBuffer(e,r,n,i,s,a,o){const c=1/((1<<a)-1);for(let l=0;l<n;l++)t(e,r,c,i,s),r+=4,s+=3+o}getOutputLength(t,e){return t/4*(3+e)|0}}return e}(),CalGrayCS=function(){function t(t,e,r,n,i,s){const a=e[r]*s,o=a**t.G,c=t.YW*o,l=Math.max(295.8*c**.3333333333333333-40.8,0);n[i]=l,n[i+1]=l,n[i+2]=l}class e extends ColorSpace{constructor(t,e,r){if(super("CalGray",1),!t)throw new _util.FormatError("WhitePoint missing - required for color space CalGray");if(e=e||[0,0,0],r=r||1,this.XW=t[0],this.YW=t[1],this.ZW=t[2],this.XB=e[0],this.YB=e[1],this.ZB=e[2],this.G=r,this.XW<0||this.ZW<0||1!==this.YW)throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);(this.XB<0||this.YB<0||this.ZB<0)&&((0,_util.info)(`Invalid BlackPoint for ${this.name}, falling back to default.`),this.XB=this.YB=this.ZB=0),0===this.XB&&0===this.YB&&0===this.ZB||(0,_util.warn)(`${this.name}, BlackPoint: XB: ${this.XB}, YB: ${this.YB}, ZB: ${this.ZB}, only default values are supported.`),this.G<1&&((0,_util.info)(`Invalid Gamma: ${this.G} for ${this.name}, falling back to default.`),this.G=1)}getRgbItem(e,r,n,i){t(this,e,r,n,i,1)}getRgbBuffer(e,r,n,i,s,a,o){const c=1/((1<<a)-1);for(let l=0;l<n;++l)t(this,e,r,i,s,c),r+=1,s+=3+o}getOutputLength(t,e){return t*(3+e)}}return e}(),CalRGBCS=function(){const t=new Float32Array([.8951,.2664,-.1614,-.7502,1.7135,.0367,.0389,-.0685,1.0296]),e=new Float32Array([.9869929,-.1470543,.1599627,.4323053,.5183603,.0492912,-.0085287,.0400428,.9684867]),r=new Float32Array([3.2404542,-1.5371385,-.4985314,-.969266,1.8760108,.041556,.0556434,-.2040259,1.0572252]),n=new Float32Array([1,1,1]),i=new Float32Array(3),s=new Float32Array(3),a=new Float32Array(3),o=(24/116)**3/8;function c(t,e,r){r[0]=t[0]*e[0]+t[1]*e[1]+t[2]*e[2],r[1]=t[3]*e[0]+t[4]*e[1]+t[5]*e[2],r[2]=t[6]*e[0]+t[7]*e[1]+t[8]*e[2]}function l(t,e,r){r[0]=1*e[0]/t[0],r[1]=1*e[1]/t[1],r[2]=1*e[2]/t[2]}function u(t,e,r){const n=.95047,i=1,s=1.08883;r[0]=e[0]*n/t[0],r[1]=e[1]*i/t[1],r[2]=e[2]*s/t[2]}function h(t){return t<=.0031308?f(0,1,12.92*t):t>=.99554525?1:f(0,1,1.055*t**(1/2.4)-.055)}function f(t,e,r){return Math.max(t,Math.min(e,r))}function g(t){return t<0?-g(-t):t>8?((t+16)/116)**3:t*o}function m(t,e,r){if(0===t[0]&&0===t[1]&&0===t[2])return r[0]=e[0],r[1]=e[1],void(r[2]=e[2]);const n=g(0),i=n,s=g(t[0]),a=n,o=g(t[1]),c=n,l=g(t[2]),u=(1-i)/(1-s),h=1-u,f=(1-a)/(1-o),m=1-f,p=(1-c)/(1-l),C=1-p;r[0]=e[0]*u+h,r[1]=e[1]*f+m,r[2]=e[2]*p+C}function p(r,n,s){if(1===r[0]&&1===r[2])return s[0]=n[0],s[1]=n[1],void(s[2]=n[2]);const a=s;c(t,n,a);const o=i;l(r,a,o),c(e,o,s)}function C(r,n,s){const a=s;c(t,n,a);const o=i;u(r,a,o),c(e,o,s)}function b(t,e,i,o,l,u){const g=f(0,1,e[i]*u),b=f(0,1,e[i+1]*u),d=f(0,1,e[i+2]*u),B=1===g?1:g**t.GR,y=1===b?1:b**t.GG,w=1===d?1:d**t.GB,R=t.MXA*B+t.MXB*y+t.MXC*w,_=t.MYA*B+t.MYB*y+t.MYC*w,S=t.MZA*B+t.MZB*y+t.MZC*w,A=s;A[0]=R,A[1]=_,A[2]=S;const G=a;p(t.whitePoint,A,G);const v=s;m(t.blackPoint,G,v);const I=a;C(n,v,I);const x=s;c(r,I,x),o[l]=255*h(x[0]),o[l+1]=255*h(x[1]),o[l+2]=255*h(x[2])}class d extends ColorSpace{constructor(t,e,r,n){if(super("CalRGB",3),!t)throw new _util.FormatError("WhitePoint missing - required for color space CalRGB");e=e||new Float32Array(3),r=r||new Float32Array([1,1,1]),n=n||new Float32Array([1,0,0,0,1,0,0,0,1]);const i=t[0],s=t[1],a=t[2];this.whitePoint=t;const o=e[0],c=e[1],l=e[2];if(this.blackPoint=e,this.GR=r[0],this.GG=r[1],this.GB=r[2],this.MXA=n[0],this.MYA=n[1],this.MZA=n[2],this.MXB=n[3],this.MYB=n[4],this.MZB=n[5],this.MXC=n[6],this.MYC=n[7],this.MZC=n[8],i<0||a<0||1!==s)throw new _util.FormatError(`Invalid WhitePoint components for ${this.name}, no fallback available`);(o<0||c<0||l<0)&&((0,_util.info)(`Invalid BlackPoint for ${this.name} [${o}, ${c}, ${l}], falling back to default.`),this.blackPoint=new Float32Array(3)),(this.GR<0||this.GG<0||this.GB<0)&&((0,_util.info)(`Invalid Gamma [${this.GR}, ${this.GG}, ${this.GB}] for ${this.name}, falling back to default.`),this.GR=this.GG=this.GB=1)}getRgbItem(t,e,r,n){b(this,t,e,r,n,1)}getRgbBuffer(t,e,r,n,i,s,a){const o=1/((1<<s)-1);for(let c=0;c<r;++c)b(this,t,e,n,i,o),e+=3,i+=3+a}getOutputLength(t,e){return t*(3+e)/3|0}}return d}(),LabCS=function(){function t(t){let e;return e=t>=6/29?t**3:108/841*(t-4/29),e}function e(t,e,r,n){return r+t*(n-r)/e}function r(r,n,i,s,a,o){let c=n[i],l=n[i+1],u=n[i+2];!1!==s&&(c=e(c,s,0,100),l=e(l,s,r.amin,r.amax),u=e(u,s,r.bmin,r.bmax)),l>r.amax?l=r.amax:l<r.amin&&(l=r.amin),u>r.bmax?u=r.bmax:u<r.bmin&&(u=r.bmin);const h=(c+16)/116,f=h+l/500,g=h-u/200,m=r.XW*t(f),p=r.YW*t(h),C=r.ZW*t(g);let b,d,B;r.ZW<1?(b=3.1339*m+-1.617*p+-.4906*C,d=-.9785*m+1.916*p+.0333*C,B=.072*m+-.229*p+1.4057*C):(b=3.2406*m+-1.5372*p+-.4986*C,d=-.9689*m+1.8758*p+.0415*C,B=.0557*m+-.204*p+1.057*C),a[o]=255*Math.sqrt(b),a[o+1]=255*Math.sqrt(d),a[o+2]=255*Math.sqrt(B)}class n extends ColorSpace{constructor(t,e,r){if(super("Lab",3),!t)throw new _util.FormatError("WhitePoint missing - required for color space Lab");if(e=e||[0,0,0],r=r||[-100,100,-100,100],this.XW=t[0],this.YW=t[1],this.ZW=t[2],this.amin=r[0],this.amax=r[1],this.bmin=r[2],this.bmax=r[3],this.XB=e[0],this.YB=e[1],this.ZB=e[2],this.XW<0||this.ZW<0||1!==this.YW)throw new _util.FormatError("Invalid WhitePoint components, no fallback available");(this.XB<0||this.YB<0||this.ZB<0)&&((0,_util.info)("Invalid BlackPoint, falling back to default"),this.XB=this.YB=this.ZB=0),(this.amin>this.amax||this.bmin>this.bmax)&&((0,_util.info)("Invalid Range, falling back to defaults"),this.amin=-100,this.amax=100,this.bmin=-100,this.bmax=100)}getRgbItem(t,e,n,i){r(this,t,e,!1,n,i)}getRgbBuffer(t,e,n,i,s,a,o){const c=(1<<a)-1;for(let l=0;l<n;l++)r(this,t,e,c,i,s),e+=3,s+=3+o}getOutputLength(t,e){return t*(3+e)/3|0}isDefaultDecode(t,e){return!0}get usesZeroToOneRange(){return(0,_util.shadow)(this,"usesZeroToOneRange",!1)}}return n}();