"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getTilingPatternIR=getTilingPatternIR,exports.Pattern=void 0;var _util=require("../shared/util.js"),_colorspace=require("./colorspace.js"),_primitives=require("./primitives.js"),_core_utils=require("./core_utils.js");const ShadingType={FUNCTION_BASED:1,AXIAL:2,RADIAL:3,FREE_FORM_MESH:4,LATTICE_FORM_MESH:5,COONS_PATCH_MESH:6,TENSOR_PATCH_MESH:7};class Pattern{constructor(){(0,_util.unreachable)("Cannot initialize Pattern.")}static parseShading(t,e,s,r,n,a){const o=(0,_primitives.isStream)(t)?t.dict:t,i=o.get("ShadingType");try{switch(i){case ShadingType.AXIAL:case ShadingType.RADIAL:return new RadialAxialShading(o,e,s,n,a);case ShadingType.FREE_FORM_MESH:case ShadingType.LATTICE_FORM_MESH:case ShadingType.COONS_PATCH_MESH:case ShadingType.TENSOR_PATCH_MESH:return new MeshShading(t,e,s,n,a);default:throw new _util.FormatError("Unsupported ShadingType: "+i)}}catch(h){if(h instanceof _core_utils.MissingDataException)throw h;return r.send("UnsupportedFeature",{featureId:_util.UNSUPPORTED_FEATURES.shadingPattern}),(0,_util.warn)(h),new DummyShading}}}exports.Pattern=Pattern;class BaseShading{static get SMALL_NUMBER(){return(0,_util.shadow)(this,"SMALL_NUMBER",1e-6)}constructor(){this.constructor===BaseShading&&(0,_util.unreachable)("Cannot initialize BaseShading.")}getIR(){(0,_util.unreachable)("Abstract method `getIR` called.")}}class RadialAxialShading extends BaseShading{constructor(t,e,s,r,n){super(),this.coordsArr=t.getArray("Coords"),this.shadingType=t.get("ShadingType");const a=_colorspace.ColorSpace.parse({cs:t.getRaw("ColorSpace")||t.getRaw("CS"),xref:e,resources:s,pdfFunctionFactory:r,localColorSpaceCache:n}),o=t.getArray("BBox");Array.isArray(o)&&4===o.length?this.bbox=_util.Util.normalizeRect(o):this.bbox=null;let i=0,h=1;if(t.has("Domain")){const e=t.getArray("Domain");i=e[0],h=e[1]}let c=!1,l=!1;if(t.has("Extend")){const e=t.getArray("Extend");c=e[0],l=e[1]}if(this.shadingType===ShadingType.RADIAL&&(!c||!l)){const[t,e,s,r,n,a]=this.coordsArr,o=Math.hypot(t-r,e-n);s<=a+o&&a<=s+o&&(0,_util.warn)("Unsupported radial gradient.")}this.extendStart=c,this.extendEnd=l;const d=t.getRaw("Function"),g=r.createFromArray(d),u=10,p=(h-i)/u,_=this.colorStops=[];if(i>=h||p<=0)return void(0,_util.info)("Bad shading domain.");const S=new Float32Array(a.numComps),y=new Float32Array(1);let A;for(let m=0;m<=u;m++){y[0]=i+m*p,g(y,0,S,0),A=a.getRgb(S,0);const t=_util.Util.makeHexColor(A[0],A[1],A[2]);_.push([m/u,t])}let f="transparent";t.has("Background")&&(A=a.getRgb(t.get("Background"),0),f=_util.Util.makeHexColor(A[0],A[1],A[2])),c||(_.unshift([0,f]),_[1][0]+=BaseShading.SMALL_NUMBER),l||(_[_.length-1][0]-=BaseShading.SMALL_NUMBER,_.push([1,f])),this.colorStops=_}getIR(){const t=this.coordsArr,e=this.shadingType;let s,r,n,a,o;return e===ShadingType.AXIAL?(r=[t[0],t[1]],n=[t[2],t[3]],a=null,o=null,s="axial"):e===ShadingType.RADIAL?(r=[t[0],t[1]],n=[t[3],t[4]],a=t[2],o=t[5],s="radial"):(0,_util.unreachable)(`getPattern type unknown: ${e}`),["RadialAxial",s,this.bbox,this.colorStops,r,n,a,o]}}class MeshStreamReader{constructor(t,e){this.stream=t,this.context=e,this.buffer=0,this.bufferLength=0;const s=e.numComps;this.tmpCompsBuf=new Float32Array(s);const r=e.colorSpace.numComps;this.tmpCsCompsBuf=e.colorFn?new Float32Array(r):this.tmpCompsBuf}get hasData(){if(this.stream.end)return this.stream.pos<this.stream.end;if(this.bufferLength>0)return!0;const t=this.stream.getByte();return!(t<0)&&(this.buffer=t,this.bufferLength=8,!0)}readBits(t){let e=this.buffer,s=this.bufferLength;if(32===t){if(0===s)return(this.stream.getByte()<<24|this.stream.getByte()<<16|this.stream.getByte()<<8|this.stream.getByte())>>>0;e=e<<24|this.stream.getByte()<<16|this.stream.getByte()<<8|this.stream.getByte();const t=this.stream.getByte();return this.buffer=t&(1<<s)-1,(e<<8-s|(255&t)>>s)>>>0}if(8===t&&0===s)return this.stream.getByte();while(s<t)e=e<<8|this.stream.getByte(),s+=8;return s-=t,this.bufferLength=s,this.buffer=e&(1<<s)-1,e>>s}align(){this.buffer=0,this.bufferLength=0}readFlag(){return this.readBits(this.context.bitsPerFlag)}readCoordinate(){const t=this.context.bitsPerCoordinate,e=this.readBits(t),s=this.readBits(t),r=this.context.decode,n=t<32?1/((1<<t)-1):2.3283064365386963e-10;return[e*n*(r[1]-r[0])+r[0],s*n*(r[3]-r[2])+r[2]]}readComponents(){const t=this.context.numComps,e=this.context.bitsPerComponent,s=e<32?1/((1<<e)-1):2.3283064365386963e-10,r=this.context.decode,n=this.tmpCompsBuf;for(let o=0,i=4;o<t;o++,i+=2){const t=this.readBits(e);n[o]=t*s*(r[i+1]-r[i])+r[i]}const a=this.tmpCsCompsBuf;return this.context.colorFn&&this.context.colorFn(n,0,a,0),this.context.colorSpace.getRgb(a,0)}}const getB=function(){function t(t){const e=[];for(let s=0;s<=t;s++){const r=s/t,n=1-r;e.push(new Float32Array([n*n*n,3*r*n*n,3*r*r*n,r*r*r]))}return e}const e=[];return function(s){return e[s]||(e[s]=t(s)),e[s]}}();class MeshShading extends BaseShading{static get MIN_SPLIT_PATCH_CHUNKS_AMOUNT(){return(0,_util.shadow)(this,"MIN_SPLIT_PATCH_CHUNKS_AMOUNT",3)}static get MAX_SPLIT_PATCH_CHUNKS_AMOUNT(){return(0,_util.shadow)(this,"MAX_SPLIT_PATCH_CHUNKS_AMOUNT",20)}static get TRIANGLE_DENSITY(){return(0,_util.shadow)(this,"TRIANGLE_DENSITY",20)}constructor(t,e,s,r,n){if(super(),!(0,_primitives.isStream)(t))throw new _util.FormatError("Mesh data is not a stream");const a=t.dict;this.shadingType=a.get("ShadingType");const o=a.getArray("BBox");Array.isArray(o)&&4===o.length?this.bbox=_util.Util.normalizeRect(o):this.bbox=null;const i=_colorspace.ColorSpace.parse({cs:a.getRaw("ColorSpace")||a.getRaw("CS"),xref:e,resources:s,pdfFunctionFactory:r,localColorSpaceCache:n});this.background=a.has("Background")?i.getRgb(a.get("Background"),0):null;const h=a.getRaw("Function"),c=h?r.createFromArray(h):null;this.coords=[],this.colors=[],this.figures=[];const l={bitsPerCoordinate:a.get("BitsPerCoordinate"),bitsPerComponent:a.get("BitsPerComponent"),bitsPerFlag:a.get("BitsPerFlag"),decode:a.getArray("Decode"),colorFn:c,colorSpace:i,numComps:c?1:i.numComps},d=new MeshStreamReader(t,l);let g=!1;switch(this.shadingType){case ShadingType.FREE_FORM_MESH:this._decodeType4Shading(d);break;case ShadingType.LATTICE_FORM_MESH:const t=0|a.get("VerticesPerRow");if(t<2)throw new _util.FormatError("Invalid VerticesPerRow");this._decodeType5Shading(d,t);break;case ShadingType.COONS_PATCH_MESH:this._decodeType6Shading(d),g=!0;break;case ShadingType.TENSOR_PATCH_MESH:this._decodeType7Shading(d),g=!0;break;default:(0,_util.unreachable)("Unsupported mesh type.");break}if(g){this._updateBounds();for(let t=0,e=this.figures.length;t<e;t++)this._buildFigureFromPatch(t)}this._updateBounds(),this._packData()}_decodeType4Shading(t){const e=this.coords,s=this.colors,r=[],n=[];let a=0;while(t.hasData){const o=t.readFlag(),i=t.readCoordinate(),h=t.readComponents();if(0===a){if(!(0<=o&&o<=2))throw new _util.FormatError("Unknown type4 flag");switch(o){case 0:a=3;break;case 1:n.push(n[n.length-2],n[n.length-1]),a=1;break;case 2:n.push(n[n.length-3],n[n.length-1]),a=1;break}r.push(o)}n.push(e.length),e.push(i),s.push(h),a--,t.align()}this.figures.push({type:"triangles",coords:new Int32Array(n),colors:new Int32Array(n)})}_decodeType5Shading(t,e){const s=this.coords,r=this.colors,n=[];while(t.hasData){const e=t.readCoordinate(),a=t.readComponents();n.push(s.length),s.push(e),r.push(a)}this.figures.push({type:"lattice",coords:new Int32Array(n),colors:new Int32Array(n),verticesPerRow:e})}_decodeType6Shading(t){const e=this.coords,s=this.colors,r=new Int32Array(16),n=new Int32Array(4);while(t.hasData){const a=t.readFlag();if(!(0<=a&&a<=3))throw new _util.FormatError("Unknown type6 flag");const o=e.length;for(let s=0,r=0!==a?8:12;s<r;s++)e.push(t.readCoordinate());const i=s.length;for(let e=0,r=0!==a?2:4;e<r;e++)s.push(t.readComponents());let h,c,l,d;switch(a){case 0:r[12]=o+3,r[13]=o+4,r[14]=o+5,r[15]=o+6,r[8]=o+2,r[11]=o+7,r[4]=o+1,r[7]=o+8,r[0]=o,r[1]=o+11,r[2]=o+10,r[3]=o+9,n[2]=i+1,n[3]=i+2,n[0]=i,n[1]=i+3;break;case 1:h=r[12],c=r[13],l=r[14],d=r[15],r[12]=d,r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=l,r[11]=o+3,r[4]=c,r[7]=o+4,r[0]=h,r[1]=o+7,r[2]=o+6,r[3]=o+5,h=n[2],c=n[3],n[2]=c,n[3]=i,n[0]=h,n[1]=i+1;break;case 2:h=r[15],c=r[11],r[12]=r[3],r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=r[7],r[11]=o+3,r[4]=c,r[7]=o+4,r[0]=h,r[1]=o+7,r[2]=o+6,r[3]=o+5,h=n[3],n[2]=n[1],n[3]=i,n[0]=h,n[1]=i+1;break;case 3:r[12]=r[0],r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=r[1],r[11]=o+3,r[4]=r[2],r[7]=o+4,r[0]=r[3],r[1]=o+7,r[2]=o+6,r[3]=o+5,n[2]=n[0],n[3]=i,n[0]=n[1],n[1]=i+1;break}r[5]=e.length,e.push([(-4*e[r[0]][0]-e[r[15]][0]+6*(e[r[4]][0]+e[r[1]][0])-2*(e[r[12]][0]+e[r[3]][0])+3*(e[r[13]][0]+e[r[7]][0]))/9,(-4*e[r[0]][1]-e[r[15]][1]+6*(e[r[4]][1]+e[r[1]][1])-2*(e[r[12]][1]+e[r[3]][1])+3*(e[r[13]][1]+e[r[7]][1]))/9]),r[6]=e.length,e.push([(-4*e[r[3]][0]-e[r[12]][0]+6*(e[r[2]][0]+e[r[7]][0])-2*(e[r[0]][0]+e[r[15]][0])+3*(e[r[4]][0]+e[r[14]][0]))/9,(-4*e[r[3]][1]-e[r[12]][1]+6*(e[r[2]][1]+e[r[7]][1])-2*(e[r[0]][1]+e[r[15]][1])+3*(e[r[4]][1]+e[r[14]][1]))/9]),r[9]=e.length,e.push([(-4*e[r[12]][0]-e[r[3]][0]+6*(e[r[8]][0]+e[r[13]][0])-2*(e[r[0]][0]+e[r[15]][0])+3*(e[r[11]][0]+e[r[1]][0]))/9,(-4*e[r[12]][1]-e[r[3]][1]+6*(e[r[8]][1]+e[r[13]][1])-2*(e[r[0]][1]+e[r[15]][1])+3*(e[r[11]][1]+e[r[1]][1]))/9]),r[10]=e.length,e.push([(-4*e[r[15]][0]-e[r[0]][0]+6*(e[r[11]][0]+e[r[14]][0])-2*(e[r[12]][0]+e[r[3]][0])+3*(e[r[2]][0]+e[r[8]][0]))/9,(-4*e[r[15]][1]-e[r[0]][1]+6*(e[r[11]][1]+e[r[14]][1])-2*(e[r[12]][1]+e[r[3]][1])+3*(e[r[2]][1]+e[r[8]][1]))/9]),this.figures.push({type:"patch",coords:new Int32Array(r),colors:new Int32Array(n)})}}_decodeType7Shading(t){const e=this.coords,s=this.colors,r=new Int32Array(16),n=new Int32Array(4);while(t.hasData){const a=t.readFlag();if(!(0<=a&&a<=3))throw new _util.FormatError("Unknown type7 flag");const o=e.length;for(let s=0,r=0!==a?12:16;s<r;s++)e.push(t.readCoordinate());const i=s.length;for(let e=0,r=0!==a?2:4;e<r;e++)s.push(t.readComponents());let h,c,l,d;switch(a){case 0:r[12]=o+3,r[13]=o+4,r[14]=o+5,r[15]=o+6,r[8]=o+2,r[9]=o+13,r[10]=o+14,r[11]=o+7,r[4]=o+1,r[5]=o+12,r[6]=o+15,r[7]=o+8,r[0]=o,r[1]=o+11,r[2]=o+10,r[3]=o+9,n[2]=i+1,n[3]=i+2,n[0]=i,n[1]=i+3;break;case 1:h=r[12],c=r[13],l=r[14],d=r[15],r[12]=d,r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=l,r[9]=o+9,r[10]=o+10,r[11]=o+3,r[4]=c,r[5]=o+8,r[6]=o+11,r[7]=o+4,r[0]=h,r[1]=o+7,r[2]=o+6,r[3]=o+5,h=n[2],c=n[3],n[2]=c,n[3]=i,n[0]=h,n[1]=i+1;break;case 2:h=r[15],c=r[11],r[12]=r[3],r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=r[7],r[9]=o+9,r[10]=o+10,r[11]=o+3,r[4]=c,r[5]=o+8,r[6]=o+11,r[7]=o+4,r[0]=h,r[1]=o+7,r[2]=o+6,r[3]=o+5,h=n[3],n[2]=n[1],n[3]=i,n[0]=h,n[1]=i+1;break;case 3:r[12]=r[0],r[13]=o+0,r[14]=o+1,r[15]=o+2,r[8]=r[1],r[9]=o+9,r[10]=o+10,r[11]=o+3,r[4]=r[2],r[5]=o+8,r[6]=o+11,r[7]=o+4,r[0]=r[3],r[1]=o+7,r[2]=o+6,r[3]=o+5,n[2]=n[0],n[3]=i,n[0]=n[1],n[1]=i+1;break}this.figures.push({type:"patch",coords:new Int32Array(r),colors:new Int32Array(n)})}}_buildFigureFromPatch(t){const e=this.figures[t];(0,_util.assert)("patch"===e.type,"Unexpected patch mesh figure");const s=this.coords,r=this.colors,n=e.coords,a=e.colors,o=Math.min(s[n[0]][0],s[n[3]][0],s[n[12]][0],s[n[15]][0]),i=Math.min(s[n[0]][1],s[n[3]][1],s[n[12]][1],s[n[15]][1]),h=Math.max(s[n[0]][0],s[n[3]][0],s[n[12]][0],s[n[15]][0]),c=Math.max(s[n[0]][1],s[n[3]][1],s[n[12]][1],s[n[15]][1]);let l=Math.ceil((h-o)*MeshShading.TRIANGLE_DENSITY/(this.bounds[2]-this.bounds[0]));l=Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT,Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT,l));let d=Math.ceil((c-i)*MeshShading.TRIANGLE_DENSITY/(this.bounds[3]-this.bounds[1]));d=Math.max(MeshShading.MIN_SPLIT_PATCH_CHUNKS_AMOUNT,Math.min(MeshShading.MAX_SPLIT_PATCH_CHUNKS_AMOUNT,d));const g=l+1,u=new Int32Array((d+1)*g),p=new Int32Array((d+1)*g);let _=0;const S=new Uint8Array(3),y=new Uint8Array(3),A=r[a[0]],f=r[a[1]],m=r[a[2]],T=r[a[3]],w=getB(d),C=getB(l);for(let M=0;M<=d;M++){S[0]=(A[0]*(d-M)+m[0]*M)/d|0,S[1]=(A[1]*(d-M)+m[1]*M)/d|0,S[2]=(A[2]*(d-M)+m[2]*M)/d|0,y[0]=(f[0]*(d-M)+T[0]*M)/d|0,y[1]=(f[1]*(d-M)+T[1]*M)/d|0,y[2]=(f[2]*(d-M)+T[2]*M)/d|0;for(let t=0;t<=l;t++,_++){if((0===M||M===d)&&(0===t||t===l))continue;let e=0,a=0,o=0;for(let r=0;r<=3;r++)for(let i=0;i<=3;i++,o++){const h=w[M][r]*C[t][i];e+=s[n[o]][0]*h,a+=s[n[o]][1]*h}u[_]=s.length,s.push([e,a]),p[_]=r.length;const i=new Uint8Array(3);i[0]=(S[0]*(l-t)+y[0]*t)/l|0,i[1]=(S[1]*(l-t)+y[1]*t)/l|0,i[2]=(S[2]*(l-t)+y[2]*t)/l|0,r.push(i)}}u[0]=n[0],p[0]=a[0],u[l]=n[3],p[l]=a[1],u[g*d]=n[12],p[g*d]=a[2],u[g*d+l]=n[15],p[g*d+l]=a[3],this.figures[t]={type:"lattice",coords:u,colors:p,verticesPerRow:g}}_updateBounds(){let t=this.coords[0][0],e=this.coords[0][1],s=t,r=e;for(let n=1,a=this.coords.length;n<a;n++){const a=this.coords[n][0],o=this.coords[n][1];t=t>a?a:t,e=e>o?o:e,s=s<a?a:s,r=r<o?o:r}this.bounds=[t,e,s,r]}_packData(){let t,e,s,r;const n=this.coords,a=new Float32Array(2*n.length);for(t=0,s=0,e=n.length;t<e;t++){const e=n[t];a[s++]=e[0],a[s++]=e[1]}this.coords=a;const o=this.colors,i=new Uint8Array(3*o.length);for(t=0,s=0,e=o.length;t<e;t++){const e=o[t];i[s++]=e[0],i[s++]=e[1],i[s++]=e[2]}this.colors=i;const h=this.figures;for(t=0,e=h.length;t<e;t++){const e=h[t],n=e.coords,a=e.colors;for(s=0,r=n.length;s<r;s++)n[s]*=2,a[s]*=3}}getIR(){return["Mesh",this.shadingType,this.coords,this.colors,this.figures,this.bounds,this.bbox,this.background]}}class DummyShading extends BaseShading{getIR(){return["Dummy"]}}function getTilingPatternIR(t,e,s){const r=e.getArray("Matrix"),n=_util.Util.normalizeRect(e.getArray("BBox")),a=e.get("XStep"),o=e.get("YStep"),i=e.get("PaintType"),h=e.get("TilingType");if(n[2]-n[0]===0||n[3]-n[1]===0)throw new _util.FormatError(`Invalid getTilingPatternIR /BBox array: [${n}].`);return["TilingPattern",s,t,r,n,a,o,i,h]}