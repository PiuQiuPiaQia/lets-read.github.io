"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.JpxImage=void 0;var _util=require("../shared/util.js"),_core_utils=require("./core_utils.js"),_arithmetic_decoder=require("./arithmetic_decoder.js");class JpxError extends _util.BaseException{constructor(e){super(`JPX error: ${e}`,"JpxError")}}const SubbandsGainLog2={LL:0,LH:1,HL:1,HH:2};class JpxImage{constructor(){this.failOnCorruptedImage=!1}parse(e){const t=(0,_core_utils.readUint16)(e,0);if(65359===t)return void this.parseCodestream(e,0,e.length);const i=e.length;let n=0;while(n<i){let t=8,s=(0,_core_utils.readUint32)(e,n);const r=(0,_core_utils.readUint32)(e,n+4);if(n+=t,1===s&&(s=4294967296*(0,_core_utils.readUint32)(e,n)+(0,_core_utils.readUint32)(e,n+4),n+=8,t+=8),0===s&&(s=i-n+t),s<t)throw new JpxError("Invalid box field size");const o=s-t;let c=!0;switch(r){case 1785737832:c=!1;break;case 1668246642:const t=e[n];if(1===t){const t=(0,_core_utils.readUint32)(e,n+3);switch(t){case 16:case 17:case 18:break;default:(0,_util.warn)("Unknown colorspace "+t);break}}else 2===t&&(0,_util.info)("ICC profile not supported");break;case 1785737827:this.parseCodestream(e,n,n+o);break;case 1783636e3:218793738!==(0,_core_utils.readUint32)(e,n)&&(0,_util.warn)("Invalid JP2 signature");break;case 1783634458:case 1718909296:case 1920099697:case 1919251232:case 1768449138:break;default:const i=String.fromCharCode(r>>24&255,r>>16&255,r>>8&255,255&r);(0,_util.warn)(`Unsupported header type ${r} (${i}).`);break}c&&(n+=o)}}parseImageProperties(e){let t=e.getByte();while(t>=0){const i=t;t=e.getByte();const n=i<<8|t;if(65361===n){e.skip(4);const t=e.getInt32()>>>0,i=e.getInt32()>>>0,n=e.getInt32()>>>0,s=e.getInt32()>>>0;e.skip(16);const r=e.getUint16();return this.width=t-n,this.height=i-s,this.componentsCount=r,void(this.bitsPerComponent=8)}}throw new JpxError("No size marker found in JPX stream")}parseCodestream(e,t,i){const n={};let s=!1;try{let r=t;while(r+1<i){const t=(0,_core_utils.readUint16)(e,r);r+=2;let i,o,c,a,l,h,u=0;switch(t){case 65359:n.mainHeader=!0;break;case 65497:break;case 65361:u=(0,_core_utils.readUint16)(e,r);const d={};d.Xsiz=(0,_core_utils.readUint32)(e,r+4),d.Ysiz=(0,_core_utils.readUint32)(e,r+8),d.XOsiz=(0,_core_utils.readUint32)(e,r+12),d.YOsiz=(0,_core_utils.readUint32)(e,r+16),d.XTsiz=(0,_core_utils.readUint32)(e,r+20),d.YTsiz=(0,_core_utils.readUint32)(e,r+24),d.XTOsiz=(0,_core_utils.readUint32)(e,r+28),d.YTOsiz=(0,_core_utils.readUint32)(e,r+32);const m=(0,_core_utils.readUint16)(e,r+36);d.Csiz=m;const f=[];i=r+38;for(let t=0;t<m;t++){const t={precision:1+(127&e[i]),isSigned:!!(128&e[i]),XRsiz:e[i+1],YRsiz:e[i+2]};i+=3,calculateComponentDimensions(t,d),f.push(t)}n.SIZ=d,n.components=f,calculateTileGrids(n,f),n.QCC=[],n.COC=[];break;case 65372:u=(0,_core_utils.readUint16)(e,r);const p={};switch(i=r+2,o=e[i++],31&o){case 0:a=8,l=!0;break;case 1:a=16,l=!1;break;case 2:a=16,l=!0;break;default:throw new Error("Invalid SQcd value "+o)}p.noQuantization=8===a,p.scalarExpounded=l,p.guardBits=o>>5,c=[];while(i<u+r){const t={};8===a?(t.epsilon=e[i++]>>3,t.mu=0):(t.epsilon=e[i]>>3,t.mu=(7&e[i])<<8|e[i+1],i+=2),c.push(t)}p.SPqcds=c,n.mainHeader?n.QCD=p:(n.currentTile.QCD=p,n.currentTile.QCC=[]);break;case 65373:u=(0,_core_utils.readUint16)(e,r);const b={};let x;switch(i=r+2,n.SIZ.Csiz<257?x=e[i++]:(x=(0,_core_utils.readUint16)(e,i),i+=2),o=e[i++],31&o){case 0:a=8,l=!0;break;case 1:a=16,l=!1;break;case 2:a=16,l=!0;break;default:throw new Error("Invalid SQcd value "+o)}b.noQuantization=8===a,b.scalarExpounded=l,b.guardBits=o>>5,c=[];while(i<u+r){const t={};8===a?(t.epsilon=e[i++]>>3,t.mu=0):(t.epsilon=e[i]>>3,t.mu=(7&e[i])<<8|e[i+1],i+=2),c.push(t)}b.SPqcds=c,n.mainHeader?n.QCC[x]=b:n.currentTile.QCC[x]=b;break;case 65362:u=(0,_core_utils.readUint16)(e,r);const g={};i=r+2;const y=e[i++];g.entropyCoderWithCustomPrecincts=!!(1&y),g.sopMarkerUsed=!!(2&y),g.ephMarkerUsed=!!(4&y),g.progressionOrder=e[i++],g.layersCount=(0,_core_utils.readUint16)(e,i),i+=2,g.multipleComponentTransform=e[i++],g.decompositionLevelsCount=e[i++],g.xcb=2+(15&e[i++]),g.ycb=2+(15&e[i++]);const P=e[i++];if(g.selectiveArithmeticCodingBypass=!!(1&P),g.resetContextProbabilities=!!(2&P),g.terminationOnEachCodingPass=!!(4&P),g.verticallyStripe=!!(8&P),g.predictableTermination=!!(16&P),g.segmentationSymbolUsed=!!(32&P),g.reversibleTransformation=e[i++],g.entropyCoderWithCustomPrecincts){const t=[];while(i<u+r){const n=e[i++];t.push({PPx:15&n,PPy:n>>4})}g.precinctsSizes=t}const C=[];g.selectiveArithmeticCodingBypass&&C.push("selectiveArithmeticCodingBypass"),g.resetContextProbabilities&&C.push("resetContextProbabilities"),g.terminationOnEachCodingPass&&C.push("terminationOnEachCodingPass"),g.verticallyStripe&&C.push("verticallyStripe"),g.predictableTermination&&C.push("predictableTermination"),C.length>0&&(s=!0,(0,_util.warn)(`JPX: Unsupported COD options (${C.join(", ")}).`)),n.mainHeader?n.COD=g:(n.currentTile.COD=g,n.currentTile.COC=[]);break;case 65424:u=(0,_core_utils.readUint16)(e,r),h={},h.index=(0,_core_utils.readUint16)(e,r+2),h.length=(0,_core_utils.readUint32)(e,r+4),h.dataEnd=h.length+r-2,h.partIndex=e[r+8],h.partsCount=e[r+9],n.mainHeader=!1,0===h.partIndex&&(h.COD=n.COD,h.COC=n.COC.slice(0),h.QCD=n.QCD,h.QCC=n.QCC.slice(0)),n.currentTile=h;break;case 65427:h=n.currentTile,0===h.partIndex&&(initializeTile(n,h.index),buildPackets(n)),u=h.dataEnd-r,parseTilePackets(n,e,r,u);break;case 65363:(0,_util.warn)("JPX: Codestream code 0xFF53 (COC) is not implemented.");case 65365:case 65367:case 65368:case 65380:u=(0,_core_utils.readUint16)(e,r);break;default:throw new Error("Unknown codestream code: "+t.toString(16))}r+=u}}catch(r){if(s||this.failOnCorruptedImage)throw new JpxError(r.message);(0,_util.warn)(`JPX: Trying to recover from: "${r.message}".`)}this.tiles=transformComponents(n),this.width=n.SIZ.Xsiz-n.SIZ.XOsiz,this.height=n.SIZ.Ysiz-n.SIZ.YOsiz,this.componentsCount=n.SIZ.Csiz}}function calculateComponentDimensions(e,t){e.x0=Math.ceil(t.XOsiz/e.XRsiz),e.x1=Math.ceil(t.Xsiz/e.XRsiz),e.y0=Math.ceil(t.YOsiz/e.YRsiz),e.y1=Math.ceil(t.Ysiz/e.YRsiz),e.width=e.x1-e.x0,e.height=e.y1-e.y0}function calculateTileGrids(e,t){const i=e.SIZ,n=[];let s;const r=Math.ceil((i.Xsiz-i.XTOsiz)/i.XTsiz),o=Math.ceil((i.Ysiz-i.YTOsiz)/i.YTsiz);for(let a=0;a<o;a++)for(let e=0;e<r;e++)s={},s.tx0=Math.max(i.XTOsiz+e*i.XTsiz,i.XOsiz),s.ty0=Math.max(i.YTOsiz+a*i.YTsiz,i.YOsiz),s.tx1=Math.min(i.XTOsiz+(e+1)*i.XTsiz,i.Xsiz),s.ty1=Math.min(i.YTOsiz+(a+1)*i.YTsiz,i.Ysiz),s.width=s.tx1-s.tx0,s.height=s.ty1-s.ty0,s.components=[],n.push(s);e.tiles=n;const c=i.Csiz;for(let a=0,l=c;a<l;a++){const e=t[a];for(let t=0,i=n.length;t<i;t++){const i={};s=n[t],i.tcx0=Math.ceil(s.tx0/e.XRsiz),i.tcy0=Math.ceil(s.ty0/e.YRsiz),i.tcx1=Math.ceil(s.tx1/e.XRsiz),i.tcy1=Math.ceil(s.ty1/e.YRsiz),i.width=i.tcx1-i.tcx0,i.height=i.tcy1-i.tcy0,s.components[a]=i}}}function getBlocksDimensions(e,t,i){const n=t.codingStyleParameters,s={};return n.entropyCoderWithCustomPrecincts?(s.PPx=n.precinctsSizes[i].PPx,s.PPy=n.precinctsSizes[i].PPy):(s.PPx=15,s.PPy=15),s.xcb_=i>0?Math.min(n.xcb,s.PPx-1):Math.min(n.xcb,s.PPx),s.ycb_=i>0?Math.min(n.ycb,s.PPy-1):Math.min(n.ycb,s.PPy),s}function buildPrecincts(e,t,i){const n=1<<i.PPx,s=1<<i.PPy,r=0===t.resLevel,o=1<<i.PPx+(r?0:-1),c=1<<i.PPy+(r?0:-1),a=t.trx1>t.trx0?Math.ceil(t.trx1/n)-Math.floor(t.trx0/n):0,l=t.try1>t.try0?Math.ceil(t.try1/s)-Math.floor(t.try0/s):0,h=a*l;t.precinctParameters={precinctWidth:n,precinctHeight:s,numprecinctswide:a,numprecinctshigh:l,numprecincts:h,precinctWidthInSubband:o,precinctHeightInSubband:c}}function buildCodeblocks(e,t,i){const n=i.xcb_,s=i.ycb_,r=1<<n,o=1<<s,c=t.tbx0>>n,a=t.tby0>>s,l=t.tbx1+r-1>>n,h=t.tby1+o-1>>s,u=t.resolution.precinctParameters,d=[],m=[];let f,p,b,x;for(p=a;p<h;p++)for(f=c;f<l;f++){b={cbx:f,cby:p,tbx0:r*f,tby0:o*p,tbx1:r*(f+1),tby1:o*(p+1)},b.tbx0_=Math.max(t.tbx0,b.tbx0),b.tby0_=Math.max(t.tby0,b.tby0),b.tbx1_=Math.min(t.tbx1,b.tbx1),b.tby1_=Math.min(t.tby1,b.tby1);const e=Math.floor((b.tbx0_-t.tbx0)/u.precinctWidthInSubband),i=Math.floor((b.tby0_-t.tby0)/u.precinctHeightInSubband);if(x=e+i*u.numprecinctswide,b.precinctNumber=x,b.subbandType=t.type,b.Lblock=3,b.tbx1_<=b.tbx0_||b.tby1_<=b.tby0_)continue;d.push(b);let n=m[x];void 0!==n?(f<n.cbxMin?n.cbxMin=f:f>n.cbxMax&&(n.cbxMax=f),p<n.cbyMin?n.cbxMin=p:p>n.cbyMax&&(n.cbyMax=p)):m[x]=n={cbxMin:f,cbyMin:p,cbxMax:f,cbyMax:p},b.precinct=n}t.codeblockParameters={codeblockWidth:n,codeblockHeight:s,numcodeblockwide:l-c+1,numcodeblockhigh:h-a+1},t.codeblocks=d,t.precincts=m}function createPacket(e,t,i){const n=[],s=e.subbands;for(let r=0,o=s.length;r<o;r++){const e=s[r],i=e.codeblocks;for(let s=0,r=i.length;s<r;s++){const e=i[s];e.precinctNumber===t&&n.push(e)}}return{layerNumber:i,codeblocks:n}}function LayerResolutionComponentPositionIterator(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=n.codingStyleDefaultParameters.layersCount,r=t.Csiz;let o=0;for(let u=0;u<r;u++)o=Math.max(o,n.components[u].codingStyleParameters.decompositionLevelsCount);let c=0,a=0,l=0,h=0;this.nextPacket=function(){for(;c<s;c++){for(;a<=o;a++){for(;l<r;l++){const e=n.components[l];if(a>e.codingStyleParameters.decompositionLevelsCount)continue;const t=e.resolutions[a],i=t.precinctParameters.numprecincts;for(;h<i;){const e=createPacket(t,h,c);return h++,e}h=0}l=0}a=0}throw new JpxError("Out of packets")}}function ResolutionLayerComponentPositionIterator(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=n.codingStyleDefaultParameters.layersCount,r=t.Csiz;let o=0;for(let u=0;u<r;u++)o=Math.max(o,n.components[u].codingStyleParameters.decompositionLevelsCount);let c=0,a=0,l=0,h=0;this.nextPacket=function(){for(;c<=o;c++){for(;a<s;a++){for(;l<r;l++){const e=n.components[l];if(c>e.codingStyleParameters.decompositionLevelsCount)continue;const t=e.resolutions[c],i=t.precinctParameters.numprecincts;for(;h<i;){const e=createPacket(t,h,a);return h++,e}h=0}l=0}a=0}throw new JpxError("Out of packets")}}function ResolutionPositionComponentLayerIterator(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=n.codingStyleDefaultParameters.layersCount,r=t.Csiz;let o,c,a,l,h=0;for(a=0;a<r;a++){const e=n.components[a];h=Math.max(h,e.codingStyleParameters.decompositionLevelsCount)}const u=new Int32Array(h+1);for(c=0;c<=h;++c){let e=0;for(a=0;a<r;++a){const t=n.components[a].resolutions;c<t.length&&(e=Math.max(e,t[c].precinctParameters.numprecincts))}u[c]=e}o=0,c=0,a=0,l=0,this.nextPacket=function(){for(;c<=h;c++){for(;l<u[c];l++){for(;a<r;a++){const e=n.components[a];if(c>e.codingStyleParameters.decompositionLevelsCount)continue;const t=e.resolutions[c],i=t.precinctParameters.numprecincts;if(!(l>=i)){for(;o<s;){const e=createPacket(t,l,o);return o++,e}o=0}}a=0}l=0}throw new JpxError("Out of packets")}}function PositionComponentResolutionLayerIterator(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=n.codingStyleDefaultParameters.layersCount,r=t.Csiz,o=getPrecinctSizesInImageScale(n),c=o;let a=0,l=0,h=0,u=0,d=0;this.nextPacket=function(){for(;d<c.maxNumHigh;d++){for(;u<c.maxNumWide;u++){for(;h<r;h++){const e=n.components[h],t=e.codingStyleParameters.decompositionLevelsCount;for(;l<=t;l++){const t=e.resolutions[l],i=o.components[h].resolutions[l],n=getPrecinctIndexIfExist(u,d,i,c,t);if(null!==n){for(;a<s;){const e=createPacket(t,n,a);return a++,e}a=0}}l=0}h=0}u=0}throw new JpxError("Out of packets")}}function ComponentPositionResolutionLayerIterator(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=n.codingStyleDefaultParameters.layersCount,r=t.Csiz,o=getPrecinctSizesInImageScale(n);let c=0,a=0,l=0,h=0,u=0;this.nextPacket=function(){for(;l<r;++l){const e=n.components[l],t=o.components[l],i=e.codingStyleParameters.decompositionLevelsCount;for(;u<t.maxNumHigh;u++){for(;h<t.maxNumWide;h++){for(;a<=i;a++){const i=e.resolutions[a],n=t.resolutions[a],r=getPrecinctIndexIfExist(h,u,n,t,i);if(null!==r){for(;c<s;){const e=createPacket(i,r,c);return c++,e}c=0}}a=0}h=0}u=0}throw new JpxError("Out of packets")}}function getPrecinctIndexIfExist(e,t,i,n,s){const r=e*n.minWidth,o=t*n.minHeight;if(r%i.width!==0||o%i.height!==0)return null;const c=o/i.width*s.precinctParameters.numprecinctswide;return r/i.height+c}function getPrecinctSizesInImageScale(e){const t=e.components.length;let i=Number.MAX_VALUE,n=Number.MAX_VALUE,s=0,r=0;const o=new Array(t);for(let c=0;c<t;c++){const t=e.components[c],a=t.codingStyleParameters.decompositionLevelsCount,l=new Array(a+1);let h=Number.MAX_VALUE,u=Number.MAX_VALUE,d=0,m=0,f=1;for(let e=a;e>=0;--e){const i=t.resolutions[e],n=f*i.precinctParameters.precinctWidth,s=f*i.precinctParameters.precinctHeight;h=Math.min(h,n),u=Math.min(u,s),d=Math.max(d,i.precinctParameters.numprecinctswide),m=Math.max(m,i.precinctParameters.numprecinctshigh),l[e]={width:n,height:s},f<<=1}i=Math.min(i,h),n=Math.min(n,u),s=Math.max(s,d),r=Math.max(r,m),o[c]={resolutions:l,minWidth:h,minHeight:u,maxNumWide:d,maxNumHigh:m}}return{components:o,minWidth:i,minHeight:n,maxNumWide:s,maxNumHigh:r}}function buildPackets(e){const t=e.SIZ,i=e.currentTile.index,n=e.tiles[i],s=t.Csiz;for(let o=0;o<s;o++){const t=n.components[o],i=t.codingStyleParameters.decompositionLevelsCount,s=[],r=[];for(let n=0;n<=i;n++){const o=getBlocksDimensions(e,t,n),c={},a=1<<i-n;let l;if(c.trx0=Math.ceil(t.tcx0/a),c.try0=Math.ceil(t.tcy0/a),c.trx1=Math.ceil(t.tcx1/a),c.try1=Math.ceil(t.tcy1/a),c.resLevel=n,buildPrecincts(e,c,o),s.push(c),0===n)l={},l.type="LL",l.tbx0=Math.ceil(t.tcx0/a),l.tby0=Math.ceil(t.tcy0/a),l.tbx1=Math.ceil(t.tcx1/a),l.tby1=Math.ceil(t.tcy1/a),l.resolution=c,buildCodeblocks(e,l,o),r.push(l),c.subbands=[l];else{const s=1<<i-n+1,a=[];l={},l.type="HL",l.tbx0=Math.ceil(t.tcx0/s-.5),l.tby0=Math.ceil(t.tcy0/s),l.tbx1=Math.ceil(t.tcx1/s-.5),l.tby1=Math.ceil(t.tcy1/s),l.resolution=c,buildCodeblocks(e,l,o),r.push(l),a.push(l),l={},l.type="LH",l.tbx0=Math.ceil(t.tcx0/s),l.tby0=Math.ceil(t.tcy0/s-.5),l.tbx1=Math.ceil(t.tcx1/s),l.tby1=Math.ceil(t.tcy1/s-.5),l.resolution=c,buildCodeblocks(e,l,o),r.push(l),a.push(l),l={},l.type="HH",l.tbx0=Math.ceil(t.tcx0/s-.5),l.tby0=Math.ceil(t.tcy0/s-.5),l.tbx1=Math.ceil(t.tcx1/s-.5),l.tby1=Math.ceil(t.tcy1/s-.5),l.resolution=c,buildCodeblocks(e,l,o),r.push(l),a.push(l),c.subbands=a}}t.resolutions=s,t.subbands=r}const r=n.codingStyleDefaultParameters.progressionOrder;switch(r){case 0:n.packetsIterator=new LayerResolutionComponentPositionIterator(e);break;case 1:n.packetsIterator=new ResolutionLayerComponentPositionIterator(e);break;case 2:n.packetsIterator=new ResolutionPositionComponentLayerIterator(e);break;case 3:n.packetsIterator=new PositionComponentResolutionLayerIterator(e);break;case 4:n.packetsIterator=new ComponentPositionResolutionLayerIterator(e);break;default:throw new JpxError(`Unsupported progression order ${r}`)}}function parseTilePackets(e,t,i,n){let s,r=0,o=0,c=!1;function a(e){while(o<e){const e=t[i+r];r++,c?(s=s<<7|e,o+=7,c=!1):(s=s<<8|e,o+=8),255===e&&(c=!0)}return o-=e,s>>>o&(1<<e)-1}function l(e){return 255===t[i+r-1]&&t[i+r]===e?(h(1),!0):255===t[i+r]&&t[i+r+1]===e&&(h(2),!0)}function h(e){r+=e}function u(){o=0,c&&(r++,c=!1)}function d(){if(0===a(1))return 1;if(0===a(1))return 2;let e=a(2);return e<3?e+3:(e=a(5),e<31?e+6:(e=a(7),e+37))}const m=e.currentTile.index,f=e.tiles[m],p=e.COD.sopMarkerUsed,b=e.COD.ephMarkerUsed,x=f.packetsIterator;while(r<n){u(),p&&l(145)&&h(4);const e=x.nextPacket();if(!a(1))continue;const n=e.layerNumber,s=[];let o;for(let t=0,i=e.codeblocks.length;t<i;t++){o=e.codeblocks[t];let i=o.precinct;const r=o.cbx-i.cbxMin,c=o.cby-i.cbyMin;let l,h,u=!1,m=!1;if(void 0!==o.included)u=!!a(1);else{let e;if(i=o.precinct,void 0!==i.inclusionTree)e=i.inclusionTree;else{const t=i.cbxMax-i.cbxMin+1,s=i.cbyMax-i.cbyMin+1;e=new InclusionTree(t,s,n),h=new TagTree(t,s),i.inclusionTree=e,i.zeroBitPlanesTree=h;for(let e=0;e<n;e++)if(0!==a(1))throw new JpxError("Invalid tag tree")}if(e.reset(r,c,n))while(1){if(!a(1)){e.incrementValue(n);break}if(l=!e.nextLevel(),l){o.included=!0,u=m=!0;break}}}if(!u)continue;if(m){h=i.zeroBitPlanesTree,h.reset(r,c);while(1)if(a(1)){if(l=!h.nextLevel(),l)break}else h.incrementValue();o.zeroBitPlanes=h.value}const f=d();while(a(1))o.Lblock++;const p=(0,_core_utils.log2)(f),b=(f<1<<p?p-1:p)+o.Lblock,x=a(b);s.push({codeblock:o,codingpasses:f,dataLength:x})}u(),b&&l(146);while(s.length>0){const e=s.shift();o=e.codeblock,void 0===o.data&&(o.data=[]),o.data.push({data:t,start:i+r,end:i+r+e.dataLength,codingpasses:e.codingpasses}),r+=e.dataLength}}return r}function copyCoefficients(e,t,i,n,s,r,o,c){const a=n.tbx0,l=n.tby0,h=n.tbx1-n.tbx0,u=n.codeblocks,d="H"===n.type.charAt(0)?1:0,m="H"===n.type.charAt(1)?t:0;for(let f=0,p=u.length;f<p;++f){const i=u[f],p=i.tbx1_-i.tbx0_,b=i.tby1_-i.tby0_;if(0===p||0===b)continue;if(void 0===i.data)continue;const x=new BitModel(p,b,i.subbandType,i.zeroBitPlanes,r);let g=2;const y=i.data;let P,C,w,M=0,_=0;for(P=0,C=y.length;P<C;P++)w=y[P],M+=w.end-w.start,_+=w.codingpasses;const k=new Uint8Array(M);let S=0;for(P=0,C=y.length;P<C;P++){w=y[P];const e=w.data.subarray(w.start,w.end);k.set(e,S),S+=e.length}const v=new _arithmetic_decoder.ArithmeticDecoder(k,0,M);for(x.setDecoder(v),P=0;P<_;P++){switch(g){case 0:x.runSignificancePropagationPass();break;case 1:x.runMagnitudeRefinementPass();break;case 2:x.runCleanupPass(),c&&x.checkSegmentationSymbol();break}g=(g+1)%3}let T=i.tbx0_-a+(i.tby0_-l)*h;const z=x.coefficentsSign,I=x.coefficentsMagnitude,L=x.bitsDecoded,U=o?0:.5;let O,A,D;S=0;const B="LL"!==n.type;for(P=0;P<b;P++){const i=T/h|0,n=2*i*(t-h)+d+m;for(O=0;O<p;O++){if(A=I[S],0!==A){A=(A+U)*s,0!==z[S]&&(A=-A),D=L[S];const t=B?n+(T<<1):T;e[t]=o&&D>=r?A:A*(1<<r-D)}T++,S++}T+=h-p}}}function transformTile(e,t,i){const n=t.components[i],s=n.codingStyleParameters,r=n.quantizationParameters,o=s.decompositionLevelsCount,c=r.SPqcds,a=r.scalarExpounded,l=r.guardBits,h=s.segmentationSymbolUsed,u=e.components[i].precision,d=s.reversibleTransformation,m=d?new ReversibleTransform:new IrreversibleTransform,f=[];let p=0;for(let x=0;x<=o;x++){const e=n.resolutions[x],t=e.trx1-e.trx0,i=e.try1-e.try0,s=new Float32Array(t*i);for(let n=0,r=e.subbands.length;n<r;n++){let r,o;a?(r=c[p].mu,o=c[p].epsilon,p++):(r=c[0].mu,o=c[0].epsilon+(x>0?1-x:0));const m=e.subbands[n],f=SubbandsGainLog2[m.type],b=d?1:2**(u+f-o)*(1+r/2048),g=l+o-1;copyCoefficients(s,t,i,m,b,g,d,h)}f.push({width:t,height:i,items:s})}const b=m.calculate(f,n.tcx0,n.tcy0);return{left:n.tcx0,top:n.tcy0,width:b.width,height:b.height,items:b.items}}function transformComponents(e){const t=e.SIZ,i=e.components,n=t.Csiz,s=[];for(let r=0,o=e.tiles.length;r<o;r++){const t=e.tiles[r],o=[];for(let i=0;i<n;i++)o[i]=transformTile(e,t,i);const c=o[0],a=new Uint8ClampedArray(c.items.length*n),l={left:c.left,top:c.top,width:c.width,height:c.height,items:a};let h,u,d,m,f,p,b,x=0;if(t.codingStyleDefaultParameters.multipleComponentTransform){const e=4===n,s=o[0].items,r=o[1].items,c=o[2].items,l=e?o[3].items:null;h=i[0].precision-8,u=.5+(128<<h);const g=t.components[0],y=n-3;if(m=s.length,g.codingStyleParameters.reversibleTransformation)for(d=0;d<m;d++,x+=y){f=s[d]+u,p=r[d],b=c[d];const e=f-(b+p>>2);a[x++]=e+b>>h,a[x++]=e>>h,a[x++]=e+p>>h}else for(d=0;d<m;d++,x+=y)f=s[d]+u,p=r[d],b=c[d],a[x++]=f+1.402*b>>h,a[x++]=f-.34413*p-.71414*b>>h,a[x++]=f+1.772*p>>h;if(e)for(d=0,x=3;d<m;d++,x+=4)a[x]=l[d]+u>>h}else for(let e=0;e<n;e++){const t=o[e].items;for(h=i[e].precision-8,u=.5+(128<<h),x=e,d=0,m=t.length;d<m;d++)a[x]=t[d]+u>>h,x+=n}s.push(l)}return s}function initializeTile(e,t){const i=e.SIZ,n=i.Csiz,s=e.tiles[t];for(let r=0;r<n;r++){const t=s.components[r],i=void 0!==e.currentTile.QCC[r]?e.currentTile.QCC[r]:e.currentTile.QCD;t.quantizationParameters=i;const n=void 0!==e.currentTile.COC[r]?e.currentTile.COC[r]:e.currentTile.COD;t.codingStyleParameters=n}s.codingStyleDefaultParameters=e.currentTile.COD}exports.JpxImage=JpxImage;class TagTree{constructor(e,t){const i=(0,_core_utils.log2)(Math.max(e,t))+1;this.levels=[];for(let n=0;n<i;n++){const i={width:e,height:t,items:[]};this.levels.push(i),e=Math.ceil(e/2),t=Math.ceil(t/2)}}reset(e,t){let i,n=0,s=0;while(n<this.levels.length){i=this.levels[n];const r=e+t*i.width;if(void 0!==i.items[r]){s=i.items[r];break}i.index=r,e>>=1,t>>=1,n++}n--,i=this.levels[n],i.items[i.index]=s,this.currentLevel=n,delete this.value}incrementValue(){const e=this.levels[this.currentLevel];e.items[e.index]++}nextLevel(){let e=this.currentLevel,t=this.levels[e];const i=t.items[t.index];return e--,e<0?(this.value=i,!1):(this.currentLevel=e,t=this.levels[e],t.items[t.index]=i,!0)}}class InclusionTree{constructor(e,t,i){const n=(0,_core_utils.log2)(Math.max(e,t))+1;this.levels=[];for(let s=0;s<n;s++){const n=new Uint8Array(e*t);for(let e=0,t=n.length;e<t;e++)n[e]=i;const s={width:e,height:t,items:n};this.levels.push(s),e=Math.ceil(e/2),t=Math.ceil(t/2)}}reset(e,t,i){let n=0;while(n<this.levels.length){const s=this.levels[n],r=e+t*s.width;s.index=r;const o=s.items[r];if(255===o)break;if(o>i)return this.currentLevel=n,this.propagateValues(),!1;e>>=1,t>>=1,n++}return this.currentLevel=n-1,!0}incrementValue(e){const t=this.levels[this.currentLevel];t.items[t.index]=e+1,this.propagateValues()}propagateValues(){let e=this.currentLevel,t=this.levels[e];const i=t.items[t.index];while(--e>=0)t=this.levels[e],t.items[t.index]=i}nextLevel(){let e=this.currentLevel,t=this.levels[e];const i=t.items[t.index];return t.items[t.index]=255,e--,!(e<0)&&(this.currentLevel=e,t=this.levels[e],t.items[t.index]=i,!0)}}const BitModel=function(){const e=17,t=18,i=new Uint8Array([0,5,8,0,3,7,8,0,4,7,8,0,0,0,0,0,1,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8,0,0,0,0,0,2,6,8,0,3,7,8,0,4,7,8]),n=new Uint8Array([0,3,4,0,5,7,7,0,8,8,8,0,0,0,0,0,1,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8,0,0,0,0,0,2,3,4,0,6,7,7,0,8,8,8]),s=new Uint8Array([0,1,2,0,1,2,2,0,2,2,2,0,0,0,0,0,3,4,5,0,4,5,5,0,5,5,5,0,0,0,0,0,6,7,7,0,7,7,7,0,7,7,7,0,0,0,0,0,8,8,8,0,8,8,8,0,8,8,8,0,0,0,0,0,8,8,8,0,8,8,8,0,8,8,8]);class r{constructor(e,t,r,o,c){let a;this.width=e,this.height=t,a="HH"===r?s:"HL"===r?n:i,this.contextLabelTable=a;const l=e*t;let h;this.neighborsSignificance=new Uint8Array(l),this.coefficentsSign=new Uint8Array(l),h=c>14?new Uint32Array(l):c>6?new Uint16Array(l):new Uint8Array(l),this.coefficentsMagnitude=h,this.processingFlags=new Uint8Array(l);const u=new Uint8Array(l);if(0!==o)for(let i=0;i<l;i++)u[i]=o;this.bitsDecoded=u,this.reset()}setDecoder(e){this.decoder=e}reset(){this.contexts=new Int8Array(19),this.contexts[0]=8,this.contexts[e]=92,this.contexts[t]=6}setNeighborsSignificance(e,t,i){const n=this.neighborsSignificance,s=this.width,r=this.height,o=t>0,c=t+1<s;let a;e>0&&(a=i-s,o&&(n[a-1]+=16),c&&(n[a+1]+=16),n[a]+=4),e+1<r&&(a=i+s,o&&(n[a-1]+=16),c&&(n[a+1]+=16),n[a]+=4),o&&(n[i-1]+=1),c&&(n[i+1]+=1),n[i]|=128}runSignificancePropagationPass(){const e=this.decoder,t=this.width,i=this.height,n=this.coefficentsMagnitude,s=this.coefficentsSign,r=this.neighborsSignificance,o=this.processingFlags,c=this.contexts,a=this.contextLabelTable,l=this.bitsDecoded,h=-2,u=1,d=2;for(let m=0;m<i;m+=4)for(let f=0;f<t;f++){let p=m*t+f;for(let b=0;b<4;b++,p+=t){const t=m+b;if(t>=i)break;if(o[p]&=h,n[p]||!r[p])continue;const x=a[r[p]],g=e.readBit(c,x);if(g){const e=this.decodeSignBit(t,f,p);s[p]=e,n[p]=1,this.setNeighborsSignificance(t,f,p),o[p]|=d}l[p]++,o[p]|=u}}}decodeSignBit(e,t,i){const n=this.width,s=this.height,r=this.coefficentsMagnitude,o=this.coefficentsSign;let c,a,l,h,u,d;h=t>0&&0!==r[i-1],t+1<n&&0!==r[i+1]?(l=o[i+1],h?(a=o[i-1],c=1-l-a):c=1-l-l):h?(a=o[i-1],c=1-a-a):c=0;const m=3*c;return h=e>0&&0!==r[i-n],e+1<s&&0!==r[i+n]?(l=o[i+n],h?(a=o[i-n],c=1-l-a+m):c=1-l-l+m):h?(a=o[i-n],c=1-a-a+m):c=m,c>=0?(u=9+c,d=this.decoder.readBit(this.contexts,u)):(u=9-c,d=1^this.decoder.readBit(this.contexts,u)),d}runMagnitudeRefinementPass(){const e=this.decoder,t=this.width,i=this.height,n=this.coefficentsMagnitude,s=this.neighborsSignificance,r=this.contexts,o=this.bitsDecoded,c=this.processingFlags,a=1,l=2,h=t*i,u=4*t;for(let d,m=0;m<h;m=d){d=Math.min(h,m+u);for(let i=0;i<t;i++)for(let h=m+i;h<d;h+=t){if(!n[h]||0!==(c[h]&a))continue;let t=16;if(0!==(c[h]&l)){c[h]^=l;const e=127&s[h];t=0===e?15:14}const i=e.readBit(r,t);n[h]=n[h]<<1|i,o[h]++,c[h]|=a}}}runCleanupPass(){const i=this.decoder,n=this.width,s=this.height,r=this.neighborsSignificance,o=this.coefficentsMagnitude,c=this.coefficentsSign,a=this.contexts,l=this.contextLabelTable,h=this.bitsDecoded,u=this.processingFlags,d=1,m=2,f=n,p=2*n,b=3*n;let x;for(let g=0;g<s;g=x){x=Math.min(g+4,s);const y=g*n,P=g+3<s;for(let s=0;s<n;s++){const C=y+s,w=P&&0===u[C]&&0===u[C+f]&&0===u[C+p]&&0===u[C+b]&&0===r[C]&&0===r[C+f]&&0===r[C+p]&&0===r[C+b];let M,_=0,k=C,S=g;if(w){const r=i.readBit(a,t);if(!r){h[C]++,h[C+f]++,h[C+p]++,h[C+b]++;continue}_=i.readBit(a,e)<<1|i.readBit(a,e),0!==_&&(S=g+_,k+=_*n),M=this.decodeSignBit(S,s,k),c[k]=M,o[k]=1,this.setNeighborsSignificance(S,s,k),u[k]|=m,k=C;for(let e=g;e<=S;e++,k+=n)h[k]++;_++}for(S=g+_;S<x;S++,k+=n){if(o[k]||0!==(u[k]&d))continue;const e=l[r[k]],t=i.readBit(a,e);1===t&&(M=this.decodeSignBit(S,s,k),c[k]=M,o[k]=1,this.setNeighborsSignificance(S,s,k),u[k]|=m),h[k]++}}}}checkSegmentationSymbol(){const t=this.decoder,i=this.contexts,n=t.readBit(i,e)<<3|t.readBit(i,e)<<2|t.readBit(i,e)<<1|t.readBit(i,e);if(10!==n)throw new JpxError("Invalid segmentation symbol")}}return r}();class Transform{constructor(){this.constructor===Transform&&(0,_util.unreachable)("Cannot initialize Transform.")}calculate(e,t,i){let n=e[0];for(let s=1,r=e.length;s<r;s++)n=this.iterate(n,e[s],t,i);return n}extend(e,t,i){let n=t-1,s=t+1,r=t+i-2,o=t+i;e[n--]=e[s++],e[o++]=e[r--],e[n--]=e[s++],e[o++]=e[r--],e[n--]=e[s++],e[o++]=e[r--],e[n]=e[s],e[o]=e[r]}filter(e,t,i){(0,_util.unreachable)("Abstract method `filter` called")}iterate(e,t,i,n){const s=e.width,r=e.height;let o=e.items;const c=t.width,a=t.height,l=t.items;let h,u,d,m,f,p;for(d=0,h=0;h<r;h++)for(m=2*h*c,u=0;u<s;u++,d++,m+=2)l[m]=o[d];o=e.items=null;const b=4,x=new Float32Array(c+2*b);if(1===c){if(0!==(1&i))for(p=0,d=0;p<a;p++,d+=c)l[d]*=.5}else for(p=0,d=0;p<a;p++,d+=c)x.set(l.subarray(d,d+c),b),this.extend(x,b,c),this.filter(x,b,c),l.set(x.subarray(b,b+c),d);let g=16;const y=[];for(h=0;h<g;h++)y.push(new Float32Array(a+2*b));let P,C=0;if(e=b+a,1===a){if(0!==(1&n))for(f=0;f<c;f++)l[f]*=.5}else for(f=0;f<c;f++){if(0===C){for(g=Math.min(c-f,g),d=f,m=b;m<e;d+=c,m++)for(P=0;P<g;P++)y[P][m]=l[d+P];C=g}C--;const t=y[C];if(this.extend(t,b,a),this.filter(t,b,a),0===C)for(d=f-g+1,m=b;m<e;d+=c,m++)for(P=0;P<g;P++)l[d+P]=y[P][m]}return{width:c,height:a,items:l}}}class IrreversibleTransform extends Transform{filter(e,t,i){const n=i>>1;let s,r,o,c;t|=0;const a=-1.586134342059924,l=-.052980118572961,h=.882911075530934,u=.443506852043971,d=1.230174104914001,m=1/d;for(s=t-3,r=n+4;r--;s+=2)e[s]*=m;for(s=t-2,o=u*e[s-1],r=n+3;r--;s+=2){if(c=u*e[s+1],e[s]=d*e[s]-o-c,!r--)break;s+=2,o=u*e[s+1],e[s]=d*e[s]-o-c}for(s=t-1,o=h*e[s-1],r=n+2;r--;s+=2){if(c=h*e[s+1],e[s]-=o+c,!r--)break;s+=2,o=h*e[s+1],e[s]-=o+c}for(s=t,o=l*e[s-1],r=n+1;r--;s+=2){if(c=l*e[s+1],e[s]-=o+c,!r--)break;s+=2,o=l*e[s+1],e[s]-=o+c}if(0!==n)for(s=t+1,o=a*e[s-1],r=n;r--;s+=2){if(c=a*e[s+1],e[s]-=o+c,!r--)break;s+=2,o=a*e[s+1],e[s]-=o+c}}}class ReversibleTransform extends Transform{filter(e,t,i){const n=i>>1;let s,r;for(t|=0,s=t,r=n+1;r--;s+=2)e[s]-=e[s-1]+e[s+1]+2>>2;for(s=t+1,r=n;r--;s+=2)e[s]+=e[s-1]+e[s+1]>>1}}