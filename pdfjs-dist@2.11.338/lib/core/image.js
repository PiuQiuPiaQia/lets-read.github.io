"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PDFImage=void 0;var _util=require("../shared/util.js"),_primitives=require("./primitives.js"),_colorspace=require("./colorspace.js"),_decode_stream=require("./decode_stream.js"),_jpeg_stream=require("./jpeg_stream.js"),_jpx=require("./jpx.js");function decodeAndClamp(e,t,i,s){return e=t+e*i,e<0?e=0:e>s&&(e=s),e}function resizeImageMask(e,t,i,s,a,r){const o=a*r;let n;n=t<=8?new Uint8Array(o):t<=16?new Uint16Array(o):new Uint32Array(o);const h=i/a,c=s/r;let m,d,l,g,f=0;const p=new Uint16Array(a),u=i;for(m=0;m<a;m++)p[m]=Math.floor(m*h);for(m=0;m<r;m++)for(l=Math.floor(m*c)*u,d=0;d<a;d++)g=l+p[d],n[f++]=e[g];return n}class PDFImage{constructor({xref:e,res:t,image:i,isInline:s=!1,smask:a=null,mask:r=null,isMask:o=!1,pdfFunctionFactory:n,localColorSpaceCache:h}){this.image=i;const c=i.dict,m=c.get("Filter");if((0,_primitives.isName)(m))switch(m.name){case"JPXDecode":const e=new _jpx.JpxImage;e.parseImageProperties(i.stream),i.stream.reset(),i.width=e.width,i.height=e.height,i.bitsPerComponent=e.bitsPerComponent,i.numComps=e.componentsCount;break;case"JBIG2Decode":i.bitsPerComponent=1,i.numComps=1;break}let d=c.get("Width","W"),l=c.get("Height","H");if(Number.isInteger(i.width)&&i.width>0&&Number.isInteger(i.height)&&i.height>0&&(i.width!==d||i.height!==l)&&((0,_util.warn)("PDFImage - using the Width/Height of the image data, rather than the image dictionary."),d=i.width,l=i.height),d<1||l<1)throw new _util.FormatError(`Invalid image width: ${d} or height: ${l}`);this.width=d,this.height=l,this.interpolate=c.get("Interpolate","I"),this.imageMask=c.get("ImageMask","IM")||!1,this.matte=c.get("Matte")||!1;let g=i.bitsPerComponent;if(!g&&(g=c.get("BitsPerComponent","BPC"),!g)){if(!this.imageMask)throw new _util.FormatError(`Bits per component missing in image: ${this.imageMask}`);g=1}if(this.bpc=g,!this.imageMask){let a=c.getRaw("ColorSpace")||c.getRaw("CS");if(!a)switch((0,_util.info)("JPX images (which do not require color spaces)"),i.numComps){case 1:a=_primitives.Name.get("DeviceGray");break;case 3:a=_primitives.Name.get("DeviceRGB");break;case 4:a=_primitives.Name.get("DeviceCMYK");break;default:throw new Error(`JPX images with ${i.numComps} color components not supported.`)}this.colorSpace=_colorspace.ColorSpace.parse({cs:a,xref:e,resources:s?t:null,pdfFunctionFactory:n,localColorSpaceCache:h}),this.numComps=this.colorSpace.numComps}if(this.decode=c.getArray("Decode","D"),this.needsDecode=!1,this.decode&&(this.colorSpace&&!this.colorSpace.isDefaultDecode(this.decode,g)||o&&!_colorspace.ColorSpace.isDefaultDecode(this.decode,1))){this.needsDecode=!0;const e=(1<<g)-1;this.decodeCoefficients=[],this.decodeAddends=[];const t=this.colorSpace&&"Indexed"===this.colorSpace.name;for(let i=0,s=0;i<this.decode.length;i+=2,++s){const a=this.decode[i],r=this.decode[i+1];this.decodeCoefficients[s]=t?(r-a)/e:r-a,this.decodeAddends[s]=t?a:e*a}}if(a)this.smask=new PDFImage({xref:e,res:t,image:a,isInline:s,pdfFunctionFactory:n,localColorSpaceCache:h});else if(r)if((0,_primitives.isStream)(r)){const i=r.dict,a=i.get("ImageMask","IM");a?this.mask=new PDFImage({xref:e,res:t,image:r,isInline:s,isMask:!0,pdfFunctionFactory:n,localColorSpaceCache:h}):(0,_util.warn)("Ignoring /Mask in image without /ImageMask.")}else this.mask=r}static async buildImage({xref:e,res:t,image:i,isInline:s=!1,pdfFunctionFactory:a,localColorSpaceCache:r}){const o=i;let n=null,h=null;const c=i.dict.get("SMask"),m=i.dict.get("Mask");return c?n=c:m&&((0,_primitives.isStream)(m)||Array.isArray(m)?h=m:(0,_util.warn)("Unsupported mask format.")),new PDFImage({xref:e,res:t,image:o,isInline:s,smask:n,mask:h,pdfFunctionFactory:a,localColorSpaceCache:r})}static createMask({imgArray:e,width:t,height:i,imageIsFromDecodeStream:s,inverseDecode:a,interpolate:r}){const o=(t+7>>3)*i,n=e.byteLength,h=o===n;let c,m;if(!s||a&&!h)if(a)for(c=new Uint8ClampedArray(o),c.set(e),m=n;m<o;m++)c[m]=255;else c=new Uint8ClampedArray(n),c.set(e);else c=e;if(a)for(m=0;m<n;m++)c[m]^=255;return{data:c,width:t,height:i,interpolate:r}}get drawWidth(){return Math.max(this.width,this.smask&&this.smask.width||0,this.mask&&this.mask.width||0)}get drawHeight(){return Math.max(this.height,this.smask&&this.smask.height||0,this.mask&&this.mask.height||0)}decodeBuffer(e){const t=this.bpc,i=this.numComps,s=this.decodeAddends,a=this.decodeCoefficients,r=(1<<t)-1;let o,n;if(1===t){for(o=0,n=e.length;o<n;o++)e[o]=+!e[o];return}let h=0;for(o=0,n=this.width*this.height;o<n;o++)for(let t=0;t<i;t++)e[h]=decodeAndClamp(e[h],s[t],a[t],r),h++}getComponents(e){const t=this.bpc;if(8===t)return e;const i=this.width,s=this.height,a=this.numComps,r=i*s*a;let o,n=0;o=t<=8?new Uint8Array(r):t<=16?new Uint16Array(r):new Uint32Array(r);const h=i*a,c=(1<<t)-1;let m,d,l=0;if(1===t){let t,i,a;for(let r=0;r<s;r++){i=l+(-8&h),a=l+h;while(l<i)d=e[n++],o[l]=d>>7&1,o[l+1]=d>>6&1,o[l+2]=d>>5&1,o[l+3]=d>>4&1,o[l+4]=d>>3&1,o[l+5]=d>>2&1,o[l+6]=d>>1&1,o[l+7]=1&d,l+=8;if(l<a){d=e[n++],t=128;while(l<a)o[l++]=+!!(d&t),t>>=1}}}else{let i=0;for(d=0,l=0,m=r;l<m;++l){l%h===0&&(d=0,i=0);while(i<t)d=d<<8|e[n++],i+=8;const s=i-t;let a=d>>s;a<0?a=0:a>c&&(a=c),o[l]=a,d&=(1<<s)-1,i=s}}return o}fillOpacity(e,t,i,s,a){const r=this.smask,o=this.mask;let n,h,c,m,d,l;if(r)h=r.width,c=r.height,n=new Uint8ClampedArray(h*c),r.fillGrayBuffer(n),h===t&&c===i||(n=resizeImageMask(n,r.bpc,h,c,t,i));else if(o)if(o instanceof PDFImage){for(h=o.width,c=o.height,n=new Uint8ClampedArray(h*c),o.numComps=1,o.fillGrayBuffer(n),m=0,d=h*c;m<d;++m)n[m]=255-n[m];h===t&&c===i||(n=resizeImageMask(n,o.bpc,h,c,t,i))}else{if(!Array.isArray(o))throw new _util.FormatError("Unknown mask format.");{n=new Uint8ClampedArray(t*i);const e=this.numComps;for(m=0,d=t*i;m<d;++m){let t=0;const i=m*e;for(l=0;l<e;++l){const e=a[i+l],s=2*l;if(e<o[s]||e>o[s+1]){t=255;break}}n[m]=t}}}if(n)for(m=0,l=3,d=t*s;m<d;++m,l+=4)e[l]=n[m];else for(m=0,l=3,d=t*s;m<d;++m,l+=4)e[l]=255}undoPreblend(e,t,i){const s=this.smask&&this.smask.matte;if(!s)return;const a=this.colorSpace.getRgb(s,0),r=a[0],o=a[1],n=a[2],h=t*i*4;for(let c=0;c<h;c+=4){const t=e[c+3];if(0===t){e[c]=255,e[c+1]=255,e[c+2]=255;continue}const i=255/t;e[c]=(e[c]-r)*i+r,e[c+1]=(e[c+1]-o)*i+o,e[c+2]=(e[c+2]-n)*i+n}}createImageData(e=!1){const t=this.drawWidth,i=this.drawHeight,s={width:t,height:i,interpolate:this.interpolate,kind:0,data:null},a=this.numComps,r=this.width,o=this.height,n=this.bpc,h=r*a*n+7>>3;let c;if(!e){let e;if("DeviceGray"===this.colorSpace.name&&1===n?e=_util.ImageKind.GRAYSCALE_1BPP:"DeviceRGB"!==this.colorSpace.name||8!==n||this.needsDecode||(e=_util.ImageKind.RGB_24BPP),e&&!this.smask&&!this.mask&&t===r&&i===o){if(s.kind=e,c=this.getImageBytes(o*h),this.image instanceof _decode_stream.DecodeStream)s.data=c;else{const e=new Uint8ClampedArray(c.length);e.set(c),s.data=e}if(this.needsDecode){(0,_util.assert)(e===_util.ImageKind.GRAYSCALE_1BPP,"PDFImage.createImageData: The image must be grayscale.");const t=s.data;for(let e=0,i=t.length;e<i;e++)t[e]^=255}return s}if(this.image instanceof _jpeg_stream.JpegStream&&!this.smask&&!this.mask){let e=o*h;switch(this.colorSpace.name){case"DeviceGray":e*=3;case"DeviceRGB":case"DeviceCMYK":return s.kind=_util.ImageKind.RGB_24BPP,s.data=this.getImageBytes(e,t,i,!0),s}}}c=this.getImageBytes(o*h);const m=0|c.length/h*i/o,d=this.getComponents(c);let l,g;return e||this.smask||this.mask?(s.kind=_util.ImageKind.RGBA_32BPP,s.data=new Uint8ClampedArray(t*i*4),l=1,g=!0,this.fillOpacity(s.data,t,i,m,d)):(s.kind=_util.ImageKind.RGB_24BPP,s.data=new Uint8ClampedArray(t*i*3),l=0,g=!1),this.needsDecode&&this.decodeBuffer(d),this.colorSpace.fillRgb(s.data,r,o,t,i,m,n,d,l),g&&this.undoPreblend(s.data,t,m),s}fillGrayBuffer(e){const t=this.numComps;if(1!==t)throw new _util.FormatError(`Reading gray scale from a color image: ${t}`);const i=this.width,s=this.height,a=this.bpc,r=i*t*a+7>>3,o=this.getImageBytes(s*r),n=this.getComponents(o);let h,c;if(1===a){if(c=i*s,this.needsDecode)for(h=0;h<c;++h)e[h]=n[h]-1&255;else for(h=0;h<c;++h)e[h]=255&-n[h];return}this.needsDecode&&this.decodeBuffer(n),c=i*s;const m=255/((1<<a)-1);for(h=0;h<c;++h)e[h]=m*n[h]}getImageBytes(e,t,i,s=!1){return this.image.reset(),this.image.drawWidth=t||this.width,this.image.drawHeight=i||this.height,this.image.forceRGB=!!s,this.image.getBytes(e,!0)}}exports.PDFImage=PDFImage;