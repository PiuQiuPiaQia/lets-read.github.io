"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PDFNetworkStream=void 0;var _util=require("../shared/util.js"),_network_utils=require("./network_utils.js");const OK_RESPONSE=200,PARTIAL_CONTENT_RESPONSE=206;function getArrayBuffer(e){const t=e.response;if("string"!==typeof t)return t;const s=(0,_util.stringToBytes)(t);return s.buffer}class NetworkManager{constructor(e,t={}){this.url=e,this.isHttp=/^https?:/i.test(e),this.httpHeaders=this.isHttp&&t.httpHeaders||Object.create(null),this.withCredentials=t.withCredentials||!1,this.getXhr=t.getXhr||function(){return new XMLHttpRequest},this.currXhrId=0,this.pendingRequests=Object.create(null)}requestRange(e,t,s){const r={begin:e,end:t};for(const n in s)r[n]=s[n];return this.request(r)}requestFull(e){return this.request(e)}request(e){const t=this.getXhr(),s=this.currXhrId++,r=this.pendingRequests[s]={xhr:t};t.open("GET",this.url),t.withCredentials=this.withCredentials;for(const n in this.httpHeaders){const e=this.httpHeaders[n];"undefined"!==typeof e&&t.setRequestHeader(n,e)}return this.isHttp&&"begin"in e&&"end"in e?(t.setRequestHeader("Range",`bytes=${e.begin}-${e.end-1}`),r.expectedStatus=PARTIAL_CONTENT_RESPONSE):r.expectedStatus=OK_RESPONSE,t.responseType="arraybuffer",e.onError&&(t.onerror=function(s){e.onError(t.status)}),t.onreadystatechange=this.onStateChange.bind(this,s),t.onprogress=this.onProgress.bind(this,s),r.onHeadersReceived=e.onHeadersReceived,r.onDone=e.onDone,r.onError=e.onError,r.onProgress=e.onProgress,t.send(null),s}onProgress(e,t){const s=this.pendingRequests[e];s&&s.onProgress?.(t)}onStateChange(e,t){const s=this.pendingRequests[e];if(!s)return;const r=s.xhr;if(r.readyState>=2&&s.onHeadersReceived&&(s.onHeadersReceived(),delete s.onHeadersReceived),4!==r.readyState)return;if(!(e in this.pendingRequests))return;if(delete this.pendingRequests[e],0===r.status&&this.isHttp)return void s.onError?.(r.status);const n=r.status||OK_RESPONSE,i=n===OK_RESPONSE&&s.expectedStatus===PARTIAL_CONTENT_RESPONSE;if(!i&&n!==s.expectedStatus)return void s.onError?.(r.status);const o=getArrayBuffer(r);if(n===PARTIAL_CONTENT_RESPONSE){const e=r.getResponseHeader("Content-Range"),t=/bytes (\d+)-(\d+)\/(\d+)/.exec(e);s.onDone({begin:parseInt(t[1],10),chunk:o})}else o?s.onDone({begin:0,chunk:o}):s.onError?.(r.status)}getRequestXhr(e){return this.pendingRequests[e].xhr}isPendingRequest(e){return e in this.pendingRequests}abortRequest(e){const t=this.pendingRequests[e].xhr;delete this.pendingRequests[e],t.abort()}}class PDFNetworkStream{constructor(e){this._source=e,this._manager=new NetworkManager(e.url,{httpHeaders:e.httpHeaders,withCredentials:e.withCredentials}),this._rangeChunkSize=e.rangeChunkSize,this._fullRequestReader=null,this._rangeRequestReaders=[]}_onRangeRequestReaderClosed(e){const t=this._rangeRequestReaders.indexOf(e);t>=0&&this._rangeRequestReaders.splice(t,1)}getFullReader(){return(0,_util.assert)(!this._fullRequestReader,"PDFNetworkStream.getFullReader can only be called once."),this._fullRequestReader=new PDFNetworkStreamFullRequestReader(this._manager,this._source),this._fullRequestReader}getRangeReader(e,t){const s=new PDFNetworkStreamRangeRequestReader(this._manager,e,t);return s.onClosed=this._onRangeRequestReaderClosed.bind(this),this._rangeRequestReaders.push(s),s}cancelAllRequests(e){this._fullRequestReader?.cancel(e);for(const t of this._rangeRequestReaders.slice(0))t.cancel(e)}}exports.PDFNetworkStream=PDFNetworkStream;class PDFNetworkStreamFullRequestReader{constructor(e,t){this._manager=e;const s={onHeadersReceived:this._onHeadersReceived.bind(this),onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};this._url=t.url,this._fullRequestId=e.requestFull(s),this._headersReceivedCapability=(0,_util.createPromiseCapability)(),this._disableRange=t.disableRange||!1,this._contentLength=t.length,this._rangeChunkSize=t.rangeChunkSize,this._rangeChunkSize||this._disableRange||(this._disableRange=!0),this._isStreamingSupported=!1,this._isRangeSupported=!1,this._cachedChunks=[],this._requests=[],this._done=!1,this._storedError=void 0,this._filename=null,this.onProgress=null}_onHeadersReceived(){const e=this._fullRequestId,t=this._manager.getRequestXhr(e),s=e=>t.getResponseHeader(e),{allowRangeRequests:r,suggestedLength:n}=(0,_network_utils.validateRangeRequestCapabilities)({getResponseHeader:s,isHttp:this._manager.isHttp,rangeChunkSize:this._rangeChunkSize,disableRange:this._disableRange});r&&(this._isRangeSupported=!0),this._contentLength=n||this._contentLength,this._filename=(0,_network_utils.extractFilenameFromHeader)(s),this._isRangeSupported&&this._manager.abortRequest(e),this._headersReceivedCapability.resolve()}_onDone(e){if(e)if(this._requests.length>0){const t=this._requests.shift();t.resolve({value:e.chunk,done:!1})}else this._cachedChunks.push(e.chunk);if(this._done=!0,!(this._cachedChunks.length>0)){for(const e of this._requests)e.resolve({value:void 0,done:!0});this._requests.length=0}}_onError(e){this._storedError=(0,_network_utils.createResponseStatusError)(e,this._url),this._headersReceivedCapability.reject(this._storedError);for(const t of this._requests)t.reject(this._storedError);this._requests.length=0,this._cachedChunks.length=0}_onProgress(e){this.onProgress?.({loaded:e.loaded,total:e.lengthComputable?e.total:this._contentLength})}get filename(){return this._filename}get isRangeSupported(){return this._isRangeSupported}get isStreamingSupported(){return this._isStreamingSupported}get contentLength(){return this._contentLength}get headersReady(){return this._headersReceivedCapability.promise}async read(){if(this._storedError)throw this._storedError;if(this._cachedChunks.length>0){const e=this._cachedChunks.shift();return{value:e,done:!1}}if(this._done)return{value:void 0,done:!0};const e=(0,_util.createPromiseCapability)();return this._requests.push(e),e.promise}cancel(e){this._done=!0,this._headersReceivedCapability.reject(e);for(const t of this._requests)t.resolve({value:void 0,done:!0});this._requests.length=0,this._manager.isPendingRequest(this._fullRequestId)&&this._manager.abortRequest(this._fullRequestId),this._fullRequestReader=null}}class PDFNetworkStreamRangeRequestReader{constructor(e,t,s){this._manager=e;const r={onDone:this._onDone.bind(this),onError:this._onError.bind(this),onProgress:this._onProgress.bind(this)};this._url=e.url,this._requestId=e.requestRange(t,s,r),this._requests=[],this._queuedChunk=null,this._done=!1,this._storedError=void 0,this.onProgress=null,this.onClosed=null}_close(){this.onClosed?.(this)}_onDone(e){const t=e.chunk;if(this._requests.length>0){const e=this._requests.shift();e.resolve({value:t,done:!1})}else this._queuedChunk=t;this._done=!0;for(const s of this._requests)s.resolve({value:void 0,done:!0});this._requests.length=0,this._close()}_onError(e){this._storedError=(0,_network_utils.createResponseStatusError)(e,this._url);for(const t of this._requests)t.reject(this._storedError);this._requests.length=0,this._queuedChunk=null}_onProgress(e){this.isStreamingSupported||this.onProgress?.({loaded:e.loaded})}get isStreamingSupported(){return!1}async read(){if(this._storedError)throw this._storedError;if(null!==this._queuedChunk){const e=this._queuedChunk;return this._queuedChunk=null,{value:e,done:!1}}if(this._done)return{value:void 0,done:!0};const e=(0,_util.createPromiseCapability)();return this._requests.push(e),e.promise}cancel(e){this._done=!0;for(const t of this._requests)t.resolve({value:void 0,done:!0});this._requests.length=0,this._manager.isPendingRequest(this._requestId)&&this._manager.abortRequest(this._requestId),this._close()}}