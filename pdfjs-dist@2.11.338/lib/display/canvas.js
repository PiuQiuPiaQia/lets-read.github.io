"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CanvasGraphics=void 0;var _util=require("../shared/util.js"),_pattern_helper=require("./pattern_helper.js"),_display_utils=require("./display_utils.js");const MIN_FONT_SIZE=16,MAX_FONT_SIZE=100,MAX_GROUP_SIZE=4096,MAX_CACHED_CANVAS_PATTERNS=2,EXECUTION_TIME=15,EXECUTION_STEPS=10,COMPILE_TYPE3_GLYPHS=!0,MAX_SIZE_TO_COMPILE=1e3,FULL_CHUNK_HEIGHT=16,LINEWIDTH_SCALE_FACTOR=1.000001;function addContextCurrentTransform(t){if(!t.mozCurrentTransform){t._originalSave=t.save,t._originalRestore=t.restore,t._originalRotate=t.rotate,t._originalScale=t.scale,t._originalTranslate=t.translate,t._originalTransform=t.transform,t._originalSetTransform=t.setTransform,t._originalResetTransform=t.resetTransform,t._transformMatrix=t._transformMatrix||[1,0,0,1,0,0],t._transformStack=[];try{const e=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),"lineWidth");t._setLineWidth=e.set,t._getLineWidth=e.get,Object.defineProperty(t,"lineWidth",{set:function(t){this._setLineWidth(t*LINEWIDTH_SCALE_FACTOR)},get:function(){return this._getLineWidth()}})}catch(e){}Object.defineProperty(t,"mozCurrentTransform",{get:function(){return this._transformMatrix}}),Object.defineProperty(t,"mozCurrentTransformInverse",{get:function(){const[t,e,s,i,a,n]=this._transformMatrix,r=t*i-e*s,o=e*s-t*i;return[i/r,e/o,s/o,t/r,(i*a-s*n)/o,(e*a-t*n)/r]}}),t.save=function(){const t=this._transformMatrix;this._transformStack.push(t),this._transformMatrix=t.slice(0,6),this._originalSave()},t.restore=function(){const t=this._transformStack.pop();t&&(this._transformMatrix=t,this._originalRestore())},t.translate=function(t,e){const s=this._transformMatrix;s[4]=s[0]*t+s[2]*e+s[4],s[5]=s[1]*t+s[3]*e+s[5],this._originalTranslate(t,e)},t.scale=function(t,e){const s=this._transformMatrix;s[0]*=t,s[1]*=t,s[2]*=e,s[3]*=e,this._originalScale(t,e)},t.transform=function(e,s,i,a,n,r){const o=this._transformMatrix;this._transformMatrix=[o[0]*e+o[2]*s,o[1]*e+o[3]*s,o[0]*i+o[2]*a,o[1]*i+o[3]*a,o[0]*n+o[2]*r+o[4],o[1]*n+o[3]*r+o[5]],t._originalTransform(e,s,i,a,n,r)},t.setTransform=function(e,s,i,a,n,r){this._transformMatrix=[e,s,i,a,n,r],t._originalSetTransform(e,s,i,a,n,r)},t.resetTransform=function(){this._transformMatrix=[1,0,0,1,0,0],t._originalResetTransform()},t.rotate=function(t){const e=Math.cos(t),s=Math.sin(t),i=this._transformMatrix;this._transformMatrix=[i[0]*e+i[2]*s,i[1]*e+i[3]*s,i[0]*-s+i[2]*e,i[1]*-s+i[3]*e,i[4],i[5]],this._originalRotate(t)}}}class CachedCanvases{constructor(t){this.canvasFactory=t,this.cache=Object.create(null)}getCanvas(t,e,s,i){let a;return void 0!==this.cache[t]?(a=this.cache[t],this.canvasFactory.reset(a,e,s),a.context.setTransform(1,0,0,1,0,0)):(a=this.canvasFactory.create(e,s),this.cache[t]=a),i&&addContextCurrentTransform(a.context),a}clear(){for(const t in this.cache){const e=this.cache[t];this.canvasFactory.destroy(e),delete this.cache[t]}}}class LRUCache{constructor(t=0){this._cache=new Map,this._maxSize=t}has(t){return this._cache.has(t)}get(t){if(this._cache.has(t)){const e=this._cache.get(t);this._cache.delete(t),this._cache.set(t,e)}return this._cache.get(t)}set(t,e){this._maxSize<=0||(this._cache.size+1>this._maxSize&&this._cache.delete(this._cache.keys().next().value),this._cache.set(t,e))}clear(){this._cache.clear()}}function compileType3Glyph(t){const e=1e3,s=new Uint8Array([0,2,4,0,1,0,5,4,8,10,0,8,0,2,1,0]),i=t.width,a=t.height,n=i+1;let r,o,h,c;const l=new Uint8Array(n*(a+1)),u=i+7&-8,f=t.data,m=new Uint8Array(u*a);let p=0;for(r=0,o=f.length;r<o;r++){const t=f[r];let e=128;while(e>0)m[p++]=t&e?0:255,e>>=1}let g=0;for(p=0,0!==m[p]&&(l[0]=1,++g),h=1;h<i;h++)m[p]!==m[p+1]&&(l[h]=m[p]?2:1,++g),p++;for(0!==m[p]&&(l[h]=2,++g),r=1;r<a;r++){p=r*u,c=r*n,m[p-u]!==m[p]&&(l[c]=m[p]?1:8,++g);let t=(m[p]?4:0)+(m[p-u]?8:0);for(h=1;h<i;h++)t=(t>>2)+(m[p+1]?4:0)+(m[p-u+1]?8:0),s[t]&&(l[c+h]=s[t],++g),p++;if(m[p-u]!==m[p]&&(l[c+h]=m[p]?2:4,++g),g>e)return null}for(p=u*(a-1),c=r*n,0!==m[p]&&(l[c]=8,++g),h=1;h<i;h++)m[p]!==m[p+1]&&(l[c+h]=m[p]?4:8,++g),p++;if(0!==m[p]&&(l[c+h]=4,++g),g>e)return null;const d=new Int32Array([0,n,-1,0,-n,0,0,0,1]),x=[];for(r=0;g&&r<=a;r++){let t=r*n;const e=t+i;while(t<e&&!l[t])t++;if(t===e)continue;const s=[t%n,r],a=t;let o=l[t];do{const e=d[o];do{t+=e}while(!l[t]);const i=l[t];5!==i&&10!==i?(o=i,l[t]=0):(o=i&51*o>>4,l[t]&=o>>2|o<<2),s.push(t%n,t/n|0),l[t]||--g}while(a!==t);x.push(s),--r}const _=function(t){t.save(),t.scale(1/i,-1/a),t.translate(0,-a),t.beginPath();for(let e=0,s=x.length;e<s;e++){const s=x[e];t.moveTo(s[0],s[1]);for(let e=2,i=s.length;e<i;e+=2)t.lineTo(s[e],s[e+1])}t.fill(),t.beginPath(),t.restore()};return _}class CanvasExtraState{constructor(){this.alphaIsShape=!1,this.fontSize=0,this.fontSizeScale=1,this.textMatrix=_util.IDENTITY_MATRIX,this.textMatrixScale=1,this.fontMatrix=_util.FONT_IDENTITY_MATRIX,this.leading=0,this.x=0,this.y=0,this.lineX=0,this.lineY=0,this.charSpacing=0,this.wordSpacing=0,this.textHScale=1,this.textRenderingMode=_util.TextRenderingMode.FILL,this.textRise=0,this.fillColor="#000000",this.strokeColor="#000000",this.patternFill=!1,this.fillAlpha=1,this.strokeAlpha=1,this.lineWidth=1,this.activeSMask=null,this.resumeSMaskCtx=null,this.transferMaps=null}clone(){return Object.create(this)}setCurrentPoint(t,e){this.x=t,this.y=e}}function putBinaryImageData(t,e,s=null){if("undefined"!==typeof ImageData&&e instanceof ImageData)return void t.putImageData(e,0,0);const i=e.height,a=e.width,n=i%FULL_CHUNK_HEIGHT,r=(i-n)/FULL_CHUNK_HEIGHT,o=0===n?r:r+1,h=t.createImageData(a,FULL_CHUNK_HEIGHT);let c,l=0;const u=e.data,f=h.data;let m,p,g,d,x,_,S,T;if(s)switch(s.length){case 1:x=s[0],_=s[0],S=s[0],T=s[0];break;case 4:x=s[0],_=s[1],S=s[2],T=s[3];break}if(e.kind===_util.ImageKind.GRAYSCALE_1BPP){const e=u.byteLength,s=new Uint32Array(f.buffer,0,f.byteLength>>2),i=s.length,d=a+7>>3;let x=4294967295,_=_util.IsLittleEndianCached.value?4278190080:255;for(T&&255===T[0]&&0===T[255]&&([x,_]=[_,x]),m=0;m<o;m++){for(g=m<r?FULL_CHUNK_HEIGHT:n,c=0,p=0;p<g;p++){const t=e-l;let i=0;const n=t>d?a:8*t-7,r=-8&n;let o=0,h=0;for(;i<r;i+=8)h=u[l++],s[c++]=128&h?x:_,s[c++]=64&h?x:_,s[c++]=32&h?x:_,s[c++]=16&h?x:_,s[c++]=8&h?x:_,s[c++]=4&h?x:_,s[c++]=2&h?x:_,s[c++]=1&h?x:_;for(;i<n;i++)0===o&&(h=u[l++],o=128),s[c++]=h&o?x:_,o>>=1}while(c<i)s[c++]=0;t.putImageData(h,0,m*FULL_CHUNK_HEIGHT)}}else if(e.kind===_util.ImageKind.RGBA_32BPP){const e=!!(x||_||S);for(p=0,d=a*FULL_CHUNK_HEIGHT*4,m=0;m<r;m++){if(f.set(u.subarray(l,l+d)),l+=d,e)for(let t=0;t<d;t+=4)x&&(f[t+0]=x[f[t+0]]),_&&(f[t+1]=_[f[t+1]]),S&&(f[t+2]=S[f[t+2]]);t.putImageData(h,0,p),p+=FULL_CHUNK_HEIGHT}if(m<o){if(d=a*n*4,f.set(u.subarray(l,l+d)),e)for(let t=0;t<d;t+=4)x&&(f[t+0]=x[f[t+0]]),_&&(f[t+1]=_[f[t+1]]),S&&(f[t+2]=S[f[t+2]]);t.putImageData(h,0,p)}}else{if(e.kind!==_util.ImageKind.RGB_24BPP)throw new Error(`bad image kind: ${e.kind}`);{const e=!!(x||_||S);for(g=FULL_CHUNK_HEIGHT,d=a*g,m=0;m<o;m++){for(m>=r&&(g=n,d=a*g),c=0,p=d;p--;)f[c++]=u[l++],f[c++]=u[l++],f[c++]=u[l++],f[c++]=255;if(e)for(let t=0;t<c;t+=4)x&&(f[t+0]=x[f[t+0]]),_&&(f[t+1]=_[f[t+1]]),S&&(f[t+2]=S[f[t+2]]);t.putImageData(h,0,m*FULL_CHUNK_HEIGHT)}}}}function putBinaryImageMask(t,e){const s=e.height,i=e.width,a=s%FULL_CHUNK_HEIGHT,n=(s-a)/FULL_CHUNK_HEIGHT,r=0===a?n:n+1,o=t.createImageData(i,FULL_CHUNK_HEIGHT);let h=0;const c=e.data,l=o.data;for(let u=0;u<r;u++){const e=u<n?FULL_CHUNK_HEIGHT:a;let s=3;for(let t=0;t<e;t++){let t,e=0;for(let a=0;a<i;a++)e||(t=c[h++],e=128),l[s]=t&e?0:255,s+=4,e>>=1}t.putImageData(o,0,u*FULL_CHUNK_HEIGHT)}}function copyCtxState(t,e){const s=["strokeStyle","fillStyle","fillRule","globalAlpha","lineWidth","lineCap","lineJoin","miterLimit","globalCompositeOperation","font"];for(let i=0,a=s.length;i<a;i++){const a=s[i];void 0!==t[a]&&(e[a]=t[a])}void 0!==t.setLineDash&&(e.setLineDash(t.getLineDash()),e.lineDashOffset=t.lineDashOffset)}function resetCtxToDefault(t){t.strokeStyle="#000000",t.fillStyle="#000000",t.fillRule="nonzero",t.globalAlpha=1,t.lineWidth=1,t.lineCap="butt",t.lineJoin="miter",t.miterLimit=10,t.globalCompositeOperation="source-over",t.font="10px sans-serif",void 0!==t.setLineDash&&(t.setLineDash([]),t.lineDashOffset=0)}function composeSMaskBackdrop(t,e,s,i){const a=t.length;for(let n=3;n<a;n+=4){const a=t[n];if(0===a)t[n-3]=e,t[n-2]=s,t[n-1]=i;else if(a<255){const r=255-a;t[n-3]=t[n-3]*a+e*r>>8,t[n-2]=t[n-2]*a+s*r>>8,t[n-1]=t[n-1]*a+i*r>>8}}}function composeSMaskAlpha(t,e,s){const i=t.length,a=1/255;for(let n=3;n<i;n+=4){const i=s?s[t[n]]:t[n];e[n]=e[n]*i*a|0}}function composeSMaskLuminosity(t,e,s){const i=t.length;for(let a=3;a<i;a+=4){const i=77*t[a-3]+152*t[a-2]+28*t[a-1];e[a]=s?e[a]*s[i>>8]>>8:e[a]*i>>16}}function genericComposeSMask(t,e,s,i,a,n,r){const o=!!n,h=o?n[0]:0,c=o?n[1]:0,l=o?n[2]:0;let u;u="Luminosity"===a?composeSMaskLuminosity:composeSMaskAlpha;const f=1048576,m=Math.min(i,Math.ceil(f/s));for(let p=0;p<i;p+=m){const a=Math.min(m,i-p),n=t.getImageData(0,p,s,a),f=e.getImageData(0,p,s,a);o&&composeSMaskBackdrop(n.data,h,c,l),u(n.data,f.data,r),t.putImageData(f,0,p)}}function composeSMask(t,e,s){const i=e.canvas,a=e.context;t.setTransform(e.scaleX,0,0,e.scaleY,e.offsetX,e.offsetY),genericComposeSMask(a,s,i.width,i.height,e.subtype,e.backdrop,e.transferMap),t.drawImage(i,0,0)}function getImageSmoothingEnabled(t,e){const s=_util.Util.singularValueDecompose2dScale(t);s[0]=Math.fround(s[0]),s[1]=Math.fround(s[1]);const i=Math.fround((globalThis.devicePixelRatio||1)*_display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);return void 0!==e?e:s[0]<=i||s[1]<=i}const LINE_CAP_STYLES=["butt","round","square"],LINE_JOIN_STYLES=["miter","round","bevel"],NORMAL_CLIP={},EO_CLIP={};class CanvasGraphics{constructor(t,e,s,i,a,n){this.ctx=t,this.current=new CanvasExtraState,this.stateStack=[],this.pendingClip=null,this.pendingEOFill=!1,this.res=null,this.xobjs=null,this.commonObjs=e,this.objs=s,this.canvasFactory=i,this.imageLayer=a,this.groupStack=[],this.processingType3=null,this.baseTransform=null,this.baseTransformStack=[],this.groupLevel=0,this.smaskStack=[],this.smaskCounter=0,this.tempSMask=null,this.contentVisible=!0,this.markedContentStack=[],this.optionalContentConfig=n,this.cachedCanvases=new CachedCanvases(this.canvasFactory),this.cachedCanvasPatterns=new LRUCache(MAX_CACHED_CANVAS_PATTERNS),this.cachedPatterns=new Map,t&&addContextCurrentTransform(t),this._cachedGetSinglePixelWidth=null}beginDrawing({transform:t,viewport:e,transparency:s=!1,background:i=null}){const a=this.ctx.canvas.width,n=this.ctx.canvas.height;if(this.ctx.save(),this.ctx.fillStyle=i||"rgb(255, 255, 255)",this.ctx.fillRect(0,0,a,n),this.ctx.restore(),s){const t=this.cachedCanvases.getCanvas("transparent",a,n,!0);this.compositeCtx=this.ctx,this.transparentCanvas=t.canvas,this.ctx=t.context,this.ctx.save(),this.ctx.transform.apply(this.ctx,this.compositeCtx.mozCurrentTransform)}this.ctx.save(),resetCtxToDefault(this.ctx),t&&this.ctx.transform.apply(this.ctx,t),this.ctx.transform.apply(this.ctx,e.transform),this.baseTransform=this.ctx.mozCurrentTransform.slice(),this._combinedScaleFactor=Math.hypot(this.baseTransform[0],this.baseTransform[2]),this.imageLayer&&this.imageLayer.beginLayout()}executeOperatorList(t,e,s,i){const a=t.argsArray,n=t.fnArray;let r=e||0;const o=a.length;if(o===r)return r;const h=o-r>EXECUTION_STEPS&&"function"===typeof s,c=h?Date.now()+EXECUTION_TIME:0;let l=0;const u=this.commonObjs,f=this.objs;let m;while(1){if(void 0!==i&&r===i.nextBreakPoint)return i.breakIt(r,s),r;if(m=n[r],m!==_util.OPS.dependency)this[m].apply(this,a[r]);else for(const t of a[r]){const e=t.startsWith("g_")?u:f;if(!e.has(t))return e.get(t,s),r}if(r++,r===o)return r;if(h&&++l>EXECUTION_STEPS){if(Date.now()>c)return s(),r;l=0}}}endDrawing(){while(this.stateStack.length||null!==this.current.activeSMask)this.restore();this.ctx.restore(),this.transparentCanvas&&(this.ctx=this.compositeCtx,this.ctx.save(),this.ctx.setTransform(1,0,0,1,0,0),this.ctx.drawImage(this.transparentCanvas,0,0),this.ctx.restore(),this.transparentCanvas=null),this.cachedCanvases.clear(),this.cachedCanvasPatterns.clear(),this.cachedPatterns.clear(),this.imageLayer&&this.imageLayer.endLayout()}_scaleImage(t,e){const s=t.width,i=t.height;let a,n,r=Math.max(Math.hypot(e[0],e[1]),1),o=Math.max(Math.hypot(e[2],e[3]),1),h=s,c=i,l="prescale1";while(r>2&&h>1||o>2&&c>1){let e=h,s=c;r>2&&h>1&&(e=Math.ceil(h/2),r/=h/e),o>2&&c>1&&(s=Math.ceil(c/2),o/=c/s),a=this.cachedCanvases.getCanvas(l,e,s),n=a.context,n.clearRect(0,0,e,s),n.drawImage(t,0,0,h,c,0,0,e,s),t=a.canvas,h=e,c=s,l="prescale1"===l?"prescale2":"prescale1"}return{img:t,paintWidth:h,paintHeight:c}}_createMaskCanvas(t){const e=this.ctx,s=t.width,i=t.height,a=this.current.fillColor,n=this.current.patternFill,r=this.cachedCanvases.getCanvas("maskCanvas",s,i),o=r.context;putBinaryImageMask(o,t);const h=e.mozCurrentTransform;let c=_util.Util.transform(h,[1/s,0,0,-1/i,0,0]);c=_util.Util.transform(c,[1,0,0,1,0,-i]);const l=_util.Util.applyTransform([0,0],c),u=_util.Util.applyTransform([s,i],c),f=_util.Util.normalizeRect([l[0],l[1],u[0],u[1]]),m=Math.ceil(f[2]-f[0]),p=Math.ceil(f[3]-f[1]),g=this.cachedCanvases.getCanvas("fillCanvas",m,p,!0),d=g.context,x=Math.min(l[0],u[0]),_=Math.min(l[1],u[1]);d.translate(-x,-_),d.transform.apply(d,c);const S=this._scaleImage(r.canvas,d.mozCurrentTransformInverse);d.imageSmoothingEnabled=getImageSmoothingEnabled(d.mozCurrentTransform,t.interpolate),d.drawImage(S.img,0,0,S.img.width,S.img.height,0,0,s,i),d.globalCompositeOperation="source-in";const T=_util.Util.transform(d.mozCurrentTransformInverse,[1,0,0,1,-x,-_]);return d.fillStyle=n?a.getPattern(e,this,T,!1):a,d.fillRect(0,0,s,i),{canvas:g.canvas,offsetX:Math.round(x),offsetY:Math.round(_)}}setLineWidth(t){this.current.lineWidth=t,this.ctx.lineWidth=t}setLineCap(t){this.ctx.lineCap=LINE_CAP_STYLES[t]}setLineJoin(t){this.ctx.lineJoin=LINE_JOIN_STYLES[t]}setMiterLimit(t){this.ctx.miterLimit=t}setDash(t,e){const s=this.ctx;void 0!==s.setLineDash&&(s.setLineDash(t),s.lineDashOffset=e)}setRenderingIntent(t){}setFlatness(t){}setGState(t){for(let e=0,s=t.length;e<s;e++){const s=t[e],i=s[0],a=s[1];switch(i){case"LW":this.setLineWidth(a);break;case"LC":this.setLineCap(a);break;case"LJ":this.setLineJoin(a);break;case"ML":this.setMiterLimit(a);break;case"D":this.setDash(a[0],a[1]);break;case"RI":this.setRenderingIntent(a);break;case"FL":this.setFlatness(a);break;case"Font":this.setFont(a[0],a[1]);break;case"CA":this.current.strokeAlpha=s[1];break;case"ca":this.current.fillAlpha=s[1],this.ctx.globalAlpha=s[1];break;case"BM":this.ctx.globalCompositeOperation=a;break;case"SMask":this.current.activeSMask&&(this.stateStack.length>0&&this.stateStack[this.stateStack.length-1].activeSMask===this.current.activeSMask?this.suspendSMaskGroup():this.endSMaskGroup()),this.current.activeSMask=a?this.tempSMask:null,this.current.activeSMask&&this.beginSMaskGroup(),this.tempSMask=null;break;case"TR":this.current.transferMaps=a}}}beginSMaskGroup(){const t=this.current.activeSMask,e=t.canvas.width,s=t.canvas.height,i="smaskGroupAt"+this.groupLevel,a=this.cachedCanvases.getCanvas(i,e,s,!0),n=this.ctx,r=n.mozCurrentTransform;this.ctx.save();const o=a.context;o.scale(1/t.scaleX,1/t.scaleY),o.translate(-t.offsetX,-t.offsetY),o.transform.apply(o,r),t.startTransformInverse=o.mozCurrentTransformInverse,copyCtxState(n,o),this.ctx=o,this.setGState([["BM","source-over"],["ca",1],["CA",1]]),this.groupStack.push(n),this.groupLevel++}suspendSMaskGroup(){const t=this.ctx;this.groupLevel--,this.ctx=this.groupStack.pop(),composeSMask(this.ctx,this.current.activeSMask,t),this.ctx.restore(),this.ctx.save(),copyCtxState(t,this.ctx),this.current.resumeSMaskCtx=t;const e=_util.Util.transform(this.current.activeSMask.startTransformInverse,t.mozCurrentTransform);this.ctx.transform.apply(this.ctx,e),t.save(),t.setTransform(1,0,0,1,0,0),t.clearRect(0,0,t.canvas.width,t.canvas.height),t.restore()}resumeSMaskGroup(){const t=this.current.resumeSMaskCtx,e=this.ctx;this.ctx=t,this.groupStack.push(e),this.groupLevel++}endSMaskGroup(){const t=this.ctx;this.groupLevel--,this.ctx=this.groupStack.pop(),composeSMask(this.ctx,this.current.activeSMask,t),this.ctx.restore(),copyCtxState(t,this.ctx);const e=_util.Util.transform(this.current.activeSMask.startTransformInverse,t.mozCurrentTransform);this.ctx.transform.apply(this.ctx,e)}save(){this.ctx.save();const t=this.current;this.stateStack.push(t),this.current=t.clone(),this.current.resumeSMaskCtx=null}restore(){this.current.resumeSMaskCtx&&this.resumeSMaskGroup(),null===this.current.activeSMask||0!==this.stateStack.length&&this.stateStack[this.stateStack.length-1].activeSMask===this.current.activeSMask||this.endSMaskGroup(),0!==this.stateStack.length?(this.current=this.stateStack.pop(),this.ctx.restore(),this.pendingClip=null,this._cachedGetSinglePixelWidth=null):this.current.activeSMask=null}transform(t,e,s,i,a,n){this.ctx.transform(t,e,s,i,a,n),this._cachedGetSinglePixelWidth=null}constructPath(t,e){const s=this.ctx,i=this.current;let a=i.x,n=i.y;for(let r=0,o=0,h=t.length;r<h;r++)switch(0|t[r]){case _util.OPS.rectangle:a=e[o++],n=e[o++];const t=e[o++],i=e[o++],r=a+t,h=n+i;s.moveTo(a,n),0===t||0===i?s.lineTo(r,h):(s.lineTo(r,n),s.lineTo(r,h),s.lineTo(a,h)),s.closePath();break;case _util.OPS.moveTo:a=e[o++],n=e[o++],s.moveTo(a,n);break;case _util.OPS.lineTo:a=e[o++],n=e[o++],s.lineTo(a,n);break;case _util.OPS.curveTo:a=e[o+4],n=e[o+5],s.bezierCurveTo(e[o],e[o+1],e[o+2],e[o+3],a,n),o+=6;break;case _util.OPS.curveTo2:s.bezierCurveTo(a,n,e[o],e[o+1],e[o+2],e[o+3]),a=e[o+2],n=e[o+3],o+=4;break;case _util.OPS.curveTo3:a=e[o+2],n=e[o+3],s.bezierCurveTo(e[o],e[o+1],a,n,a,n),o+=4;break;case _util.OPS.closePath:s.closePath();break}i.setCurrentPoint(a,n)}closePath(){this.ctx.closePath()}stroke(t){t="undefined"===typeof t||t;const e=this.ctx,s=this.current.strokeColor;if(e.globalAlpha=this.current.strokeAlpha,this.contentVisible)if("object"===typeof s&&s?.getPattern){const t=this.getSinglePixelWidth();e.save(),e.strokeStyle=s.getPattern(e,this,e.mozCurrentTransformInverse),e.lineWidth=Math.max(t,this.current.lineWidth),e.stroke(),e.restore()}else{const t=this.getSinglePixelWidth();t<0&&-t>=this.current.lineWidth?(e.save(),e.resetTransform(),e.lineWidth=Math.round(this._combinedScaleFactor),e.stroke(),e.restore()):(e.lineWidth=Math.max(t,this.current.lineWidth),e.stroke())}t&&this.consumePath(),e.globalAlpha=this.current.fillAlpha}closeStroke(){this.closePath(),this.stroke()}fill(t){t="undefined"===typeof t||t;const e=this.ctx,s=this.current.fillColor,i=this.current.patternFill;let a=!1;i&&(e.save(),e.fillStyle=s.getPattern(e,this,e.mozCurrentTransformInverse),a=!0),this.contentVisible&&(this.pendingEOFill?(e.fill("evenodd"),this.pendingEOFill=!1):e.fill()),a&&e.restore(),t&&this.consumePath()}eoFill(){this.pendingEOFill=!0,this.fill()}fillStroke(){this.fill(!1),this.stroke(!1),this.consumePath()}eoFillStroke(){this.pendingEOFill=!0,this.fillStroke()}closeFillStroke(){this.closePath(),this.fillStroke()}closeEOFillStroke(){this.pendingEOFill=!0,this.closePath(),this.fillStroke()}endPath(){this.consumePath()}clip(){this.pendingClip=NORMAL_CLIP}eoClip(){this.pendingClip=EO_CLIP}beginText(){this.current.textMatrix=_util.IDENTITY_MATRIX,this.current.textMatrixScale=1,this.current.x=this.current.lineX=0,this.current.y=this.current.lineY=0}endText(){const t=this.pendingTextPaths,e=this.ctx;if(void 0!==t){e.save(),e.beginPath();for(let s=0;s<t.length;s++){const i=t[s];e.setTransform.apply(e,i.transform),e.translate(i.x,i.y),i.addToPath(e,i.fontSize)}e.restore(),e.clip(),e.beginPath(),delete this.pendingTextPaths}else e.beginPath()}setCharSpacing(t){this.current.charSpacing=t}setWordSpacing(t){this.current.wordSpacing=t}setHScale(t){this.current.textHScale=t/100}setLeading(t){this.current.leading=-t}setFont(t,e){const s=this.commonObjs.get(t),i=this.current;if(!s)throw new Error(`Can't find font for ${t}`);if(i.fontMatrix=s.fontMatrix||_util.FONT_IDENTITY_MATRIX,0!==i.fontMatrix[0]&&0!==i.fontMatrix[3]||(0,_util.warn)("Invalid font matrix for font "+t),e<0?(e=-e,i.fontDirection=-1):i.fontDirection=1,this.current.font=s,this.current.fontSize=e,s.isType3Font)return;const a=s.loadedName||"sans-serif";let n="normal";s.black?n="900":s.bold&&(n="bold");const r=s.italic?"italic":"normal",o=`"${a}", ${s.fallbackName}`;let h=e;e<MIN_FONT_SIZE?h=MIN_FONT_SIZE:e>MAX_FONT_SIZE&&(h=MAX_FONT_SIZE),this.current.fontSizeScale=e/h,this.ctx.font=`${r} ${n} ${h}px ${o}`}setTextRenderingMode(t){this.current.textRenderingMode=t}setTextRise(t){this.current.textRise=t}moveText(t,e){this.current.x=this.current.lineX+=t,this.current.y=this.current.lineY+=e}setLeadingMoveText(t,e){this.setLeading(-e),this.moveText(t,e)}setTextMatrix(t,e,s,i,a,n){this.current.textMatrix=[t,e,s,i,a,n],this.current.textMatrixScale=Math.hypot(t,e),this.current.x=this.current.lineX=0,this.current.y=this.current.lineY=0}nextLine(){this.moveText(0,this.current.leading)}paintChar(t,e,s,i,a){const n=this.ctx,r=this.current,o=r.font,h=r.textRenderingMode,c=r.fontSize/r.fontSizeScale,l=h&_util.TextRenderingMode.FILL_STROKE_MASK,u=!!(h&_util.TextRenderingMode.ADD_TO_PATH_FLAG),f=r.patternFill&&!o.missingFile;let m;if((o.disableFontFace||u||f)&&(m=o.getPathGenerator(this.commonObjs,t)),o.disableFontFace||f?(n.save(),n.translate(e,s),n.beginPath(),m(n,c),i&&n.setTransform.apply(n,i),l!==_util.TextRenderingMode.FILL&&l!==_util.TextRenderingMode.FILL_STROKE||n.fill(),l!==_util.TextRenderingMode.STROKE&&l!==_util.TextRenderingMode.FILL_STROKE||(a&&(n.resetTransform(),n.lineWidth=Math.round(this._combinedScaleFactor)),n.stroke()),n.restore()):(l!==_util.TextRenderingMode.FILL&&l!==_util.TextRenderingMode.FILL_STROKE||n.fillText(t,e,s),l!==_util.TextRenderingMode.STROKE&&l!==_util.TextRenderingMode.FILL_STROKE||(a?(n.save(),n.moveTo(e,s),n.resetTransform(),n.lineWidth=Math.round(this._combinedScaleFactor),n.strokeText(t,0,0),n.restore()):n.strokeText(t,e,s))),u){const t=this.pendingTextPaths||(this.pendingTextPaths=[]);t.push({transform:n.mozCurrentTransform,x:e,y:s,fontSize:c,addToPath:m})}}get isFontSubpixelAAEnabled(){const{context:t}=this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled",10,10);t.scale(1.5,1),t.fillText("I",0,10);const e=t.getImageData(0,0,10,10).data;let s=!1;for(let i=3;i<e.length;i+=4)if(e[i]>0&&e[i]<255){s=!0;break}return(0,_util.shadow)(this,"isFontSubpixelAAEnabled",s)}showText(t){const e=this.current,s=e.font;if(s.isType3Font)return this.showType3Text(t);const i=e.fontSize;if(0===i)return;const a=this.ctx,n=e.fontSizeScale,r=e.charSpacing,o=e.wordSpacing,h=e.fontDirection,c=e.textHScale*h,l=t.length,u=s.vertical,f=u?1:-1,m=s.defaultVMetrics,p=i*e.fontMatrix[0],g=e.textRenderingMode===_util.TextRenderingMode.FILL&&!s.disableFontFace&&!e.patternFill;let d;if(a.save(),e.patternFill){a.save();const t=e.fillColor.getPattern(a,this,a.mozCurrentTransformInverse);d=a.mozCurrentTransform,a.restore(),a.fillStyle=t}a.transform.apply(a,e.textMatrix),a.translate(e.x,e.y+e.textRise),h>0?a.scale(c,-1):a.scale(c,1);let x=e.lineWidth,_=!1;const S=e.textMatrixScale;if(0===S||0===x){const t=e.textRenderingMode&_util.TextRenderingMode.FILL_STROKE_MASK;t!==_util.TextRenderingMode.STROKE&&t!==_util.TextRenderingMode.FILL_STROKE||(this._cachedGetSinglePixelWidth=null,x=this.getSinglePixelWidth(),_=x<0)}else x/=S;1!==n&&(a.scale(n,n),x/=n),a.lineWidth=x;let T,C=0;for(T=0;T<l;++T){const e=t[T];if((0,_util.isNum)(e)){C+=f*e*i/1e3;continue}let c=!1;const l=(e.isSpace?o:0)+r,x=e.fontChar,S=e.accent;let v,M,k,b=e.width;if(u){const t=e.vmetric||m,s=-(e.vmetric?t[1]:.5*b)*p,i=t[2]*p;b=t?-t[0]:b,v=s/n,M=(C+i)/n}else v=C/n,M=0;if(s.remeasure&&b>0){const t=1e3*a.measureText(x).width/i*n;if(b<t&&this.isFontSubpixelAAEnabled){const e=b/t;c=!0,a.save(),a.scale(e,1),v/=e}else b!==t&&(v+=(b-t)/2e3*i/n)}if(this.contentVisible&&(e.isInFont||s.missingFile))if(g&&!S)a.fillText(x,v,M);else if(this.paintChar(x,v,M,d,_),S){const t=v+i*S.offset.x/n,e=M-i*S.offset.y/n;this.paintChar(S.fontChar,t,e,d,_)}k=u?b*p-l*h:b*p+l*h,C+=k,c&&a.restore()}u?e.y-=C:e.x+=C*c,a.restore()}showType3Text(t){const e=this.ctx,s=this.current,i=s.font,a=s.fontSize,n=s.fontDirection,r=i.vertical?1:-1,o=s.charSpacing,h=s.wordSpacing,c=s.textHScale*n,l=s.fontMatrix||_util.FONT_IDENTITY_MATRIX,u=t.length,f=s.textRenderingMode===_util.TextRenderingMode.INVISIBLE;let m,p,g,d;if(!f&&0!==a){for(this._cachedGetSinglePixelWidth=null,e.save(),e.transform.apply(e,s.textMatrix),e.translate(s.x,s.y),e.scale(c,n),m=0;m<u;++m){if(p=t[m],(0,_util.isNum)(p)){d=r*p*a/1e3,this.ctx.translate(d,0),s.x+=d*c;continue}const n=(p.isSpace?h:0)+o,u=i.charProcOperatorList[p.operatorListId];if(!u){(0,_util.warn)(`Type3 character "${p.operatorListId}" is not available.`);continue}this.contentVisible&&(this.processingType3=p,this.save(),e.scale(a,a),e.transform.apply(e,l),this.executeOperatorList(u),this.restore());const f=_util.Util.applyTransform([p.width,0],l);g=f[0]*a+n,e.translate(g,0),s.x+=g*c}e.restore(),this.processingType3=null}}setCharWidth(t,e){}setCharWidthAndBounds(t,e,s,i,a,n){this.ctx.rect(s,i,a-s,n-i),this.clip(),this.endPath()}getColorN_Pattern(t){let e;if("TilingPattern"===t[0]){const s=t[1],i=this.baseTransform||this.ctx.mozCurrentTransform.slice(),a={createCanvasGraphics:t=>new CanvasGraphics(t,this.commonObjs,this.objs,this.canvasFactory)};e=new _pattern_helper.TilingPattern(t,s,this.ctx,a,i)}else e=this._getPattern(t[1],t[2]);return e}setStrokeColorN(){this.current.strokeColor=this.getColorN_Pattern(arguments)}setFillColorN(){this.current.fillColor=this.getColorN_Pattern(arguments),this.current.patternFill=!0}setStrokeRGBColor(t,e,s){const i=_util.Util.makeHexColor(t,e,s);this.ctx.strokeStyle=i,this.current.strokeColor=i}setFillRGBColor(t,e,s){const i=_util.Util.makeHexColor(t,e,s);this.ctx.fillStyle=i,this.current.fillColor=i,this.current.patternFill=!1}_getPattern(t,e=null){let s;return this.cachedPatterns.has(t)?s=this.cachedPatterns.get(t):(s=(0,_pattern_helper.getShadingPattern)(this.objs.get(t),this.cachedCanvasPatterns),this.cachedPatterns.set(t,s)),e&&(s.matrix=e),s}shadingFill(t){if(!this.contentVisible)return;const e=this.ctx;this.save();const s=this._getPattern(t);e.fillStyle=s.getPattern(e,this,e.mozCurrentTransformInverse,!0);const i=e.mozCurrentTransformInverse;if(i){const t=e.canvas,s=t.width,a=t.height,n=_util.Util.applyTransform([0,0],i),r=_util.Util.applyTransform([0,a],i),o=_util.Util.applyTransform([s,0],i),h=_util.Util.applyTransform([s,a],i),c=Math.min(n[0],r[0],o[0],h[0]),l=Math.min(n[1],r[1],o[1],h[1]),u=Math.max(n[0],r[0],o[0],h[0]),f=Math.max(n[1],r[1],o[1],h[1]);this.ctx.fillRect(c,l,u-c,f-l)}else this.ctx.fillRect(-1e10,-1e10,2e10,2e10);this.restore()}beginInlineImage(){(0,_util.unreachable)("Should not call beginInlineImage")}beginImageData(){(0,_util.unreachable)("Should not call beginImageData")}paintFormXObjectBegin(t,e){if(this.contentVisible&&(this.save(),this.baseTransformStack.push(this.baseTransform),Array.isArray(t)&&6===t.length&&this.transform.apply(this,t),this.baseTransform=this.ctx.mozCurrentTransform,e)){const t=e[2]-e[0],s=e[3]-e[1];this.ctx.rect(e[0],e[1],t,s),this.clip(),this.endPath()}}paintFormXObjectEnd(){this.contentVisible&&(this.restore(),this.baseTransform=this.baseTransformStack.pop())}beginGroup(t){if(!this.contentVisible)return;this.save();const e=this.ctx;t.isolated||(0,_util.info)("TODO: Support non-isolated groups."),t.knockout&&(0,_util.warn)("Knockout groups not supported.");const s=e.mozCurrentTransform;if(t.matrix&&e.transform.apply(e,t.matrix),!t.bbox)throw new Error("Bounding box is required.");let i=_util.Util.getAxialAlignedBoundingBox(t.bbox,e.mozCurrentTransform);const a=[0,0,e.canvas.width,e.canvas.height];i=_util.Util.intersect(i,a)||[0,0,0,0];const n=Math.floor(i[0]),r=Math.floor(i[1]);let o=Math.max(Math.ceil(i[2])-n,1),h=Math.max(Math.ceil(i[3])-r,1),c=1,l=1;o>MAX_GROUP_SIZE&&(c=o/MAX_GROUP_SIZE,o=MAX_GROUP_SIZE),h>MAX_GROUP_SIZE&&(l=h/MAX_GROUP_SIZE,h=MAX_GROUP_SIZE);let u="groupAt"+this.groupLevel;t.smask&&(u+="_smask_"+this.smaskCounter++%2);const f=this.cachedCanvases.getCanvas(u,o,h,!0),m=f.context;m.scale(1/c,1/l),m.translate(-n,-r),m.transform.apply(m,s),t.smask?this.smaskStack.push({canvas:f.canvas,context:m,offsetX:n,offsetY:r,scaleX:c,scaleY:l,subtype:t.smask.subtype,backdrop:t.smask.backdrop,transferMap:t.smask.transferMap||null,startTransformInverse:null}):(e.setTransform(1,0,0,1,0,0),e.translate(n,r),e.scale(c,l)),copyCtxState(e,m),this.ctx=m,this.setGState([["BM","source-over"],["ca",1],["CA",1]]),this.groupStack.push(e),this.groupLevel++,this.current.activeSMask=null}endGroup(t){if(!this.contentVisible)return;this.groupLevel--;const e=this.ctx;this.ctx=this.groupStack.pop(),this.ctx.imageSmoothingEnabled=!1,t.smask?this.tempSMask=this.smaskStack.pop():this.ctx.drawImage(e.canvas,0,0),this.restore()}beginAnnotations(){this.save(),this.baseTransform&&this.ctx.setTransform.apply(this.ctx,this.baseTransform)}endAnnotations(){this.restore()}beginAnnotation(t,e,s,i){if(this.save(),resetCtxToDefault(this.ctx),this.current=new CanvasExtraState,Array.isArray(e)&&4===e.length){const t=e[2]-e[0],s=e[3]-e[1];this.ctx.rect(e[0],e[1],t,s),this.clip(),this.endPath()}this.transform.apply(this,s),this.transform.apply(this,i)}endAnnotation(){this.restore()}paintImageMaskXObject(t){if(!this.contentVisible)return;const e=this.ctx,s=t.width,i=t.height,a=this.processingType3;if(COMPILE_TYPE3_GLYPHS&&a&&void 0===a.compiled&&(a.compiled=s<=MAX_SIZE_TO_COMPILE&&i<=MAX_SIZE_TO_COMPILE?compileType3Glyph({data:t.data,width:s,height:i}):null),a?.compiled)return void a.compiled(e);const n=this._createMaskCanvas(t),r=n.canvas;e.save(),e.setTransform(1,0,0,1,0,0),e.drawImage(r,n.offsetX,n.offsetY),e.restore()}paintImageMaskXObjectRepeat(t,e,s=0,i=0,a,n){if(!this.contentVisible)return;const r=this.ctx;r.save();const o=r.mozCurrentTransform;r.transform(e,s,i,a,0,0);const h=this._createMaskCanvas(t);r.setTransform(1,0,0,1,0,0);for(let c=0,l=n.length;c<l;c+=2){const t=_util.Util.transform(o,[e,s,i,a,n[c],n[c+1]]),[l,u]=_util.Util.applyTransform([0,0],t);r.drawImage(h.canvas,l,u)}r.restore()}paintImageMaskXObjectGroup(t){if(!this.contentVisible)return;const e=this.ctx,s=this.current.fillColor,i=this.current.patternFill;for(let a=0,n=t.length;a<n;a++){const n=t[a],r=n.width,o=n.height,h=this.cachedCanvases.getCanvas("maskCanvas",r,o),c=h.context;c.save(),putBinaryImageMask(c,n),c.globalCompositeOperation="source-in",c.fillStyle=i?s.getPattern(c,this,e.mozCurrentTransformInverse,!1):s,c.fillRect(0,0,r,o),c.restore(),e.save(),e.transform.apply(e,n.transform),e.scale(1,-1),e.drawImage(h.canvas,0,0,r,o,0,-1,1,1),e.restore()}}paintImageXObject(t){if(!this.contentVisible)return;const e=t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t);e?this.paintInlineImageXObject(e):(0,_util.warn)("Dependent image isn't ready yet")}paintImageXObjectRepeat(t,e,s,i){if(!this.contentVisible)return;const a=t.startsWith("g_")?this.commonObjs.get(t):this.objs.get(t);if(!a)return void(0,_util.warn)("Dependent image isn't ready yet");const n=a.width,r=a.height,o=[];for(let h=0,c=i.length;h<c;h+=2)o.push({transform:[e,0,0,s,i[h],i[h+1]],x:0,y:0,w:n,h:r});this.paintInlineImageXObjectGroup(a,o)}paintInlineImageXObject(t){if(!this.contentVisible)return;const e=t.width,s=t.height,i=this.ctx;let a;if(this.save(),i.scale(1/e,-1/s),"function"===typeof HTMLElement&&t instanceof HTMLElement||!t.data)a=t;else{const i=this.cachedCanvases.getCanvas("inlineImage",e,s),n=i.context;putBinaryImageData(n,t,this.current.transferMaps),a=i.canvas}const n=this._scaleImage(a,i.mozCurrentTransformInverse);if(i.imageSmoothingEnabled=getImageSmoothingEnabled(i.mozCurrentTransform,t.interpolate),i.drawImage(n.img,0,0,n.paintWidth,n.paintHeight,0,-s,e,s),this.imageLayer){const a=this.getCanvasPosition(0,-s);this.imageLayer.appendImage({imgData:t,left:a[0],top:a[1],width:e/i.mozCurrentTransformInverse[0],height:s/i.mozCurrentTransformInverse[3]})}this.restore()}paintInlineImageXObjectGroup(t,e){if(!this.contentVisible)return;const s=this.ctx,i=t.width,a=t.height,n=this.cachedCanvases.getCanvas("inlineImage",i,a),r=n.context;putBinaryImageData(r,t,this.current.transferMaps);for(let o=0,h=e.length;o<h;o++){const r=e[o];if(s.save(),s.transform.apply(s,r.transform),s.scale(1,-1),s.drawImage(n.canvas,r.x,r.y,r.w,r.h,0,-1,1,1),this.imageLayer){const e=this.getCanvasPosition(r.x,r.y);this.imageLayer.appendImage({imgData:t,left:e[0],top:e[1],width:i,height:a})}s.restore()}}paintSolidColorImageMask(){this.contentVisible&&this.ctx.fillRect(0,0,1,1)}markPoint(t){}markPointProps(t,e){}beginMarkedContent(t){this.markedContentStack.push({visible:!0})}beginMarkedContentProps(t,e){"OC"===t?this.markedContentStack.push({visible:this.optionalContentConfig.isVisible(e)}):this.markedContentStack.push({visible:!0}),this.contentVisible=this.isContentVisible()}endMarkedContent(){this.markedContentStack.pop(),this.contentVisible=this.isContentVisible()}beginCompat(){}endCompat(){}consumePath(){const t=this.ctx;this.pendingClip&&(this.pendingClip===EO_CLIP?t.clip("evenodd"):t.clip(),this.pendingClip=null),t.beginPath()}getSinglePixelWidth(){if(null===this._cachedGetSinglePixelWidth){const t=this.ctx.mozCurrentTransform,e=Math.abs(t[0]*t[3]-t[2]*t[1]),s=t[0]**2+t[2]**2,i=t[1]**2+t[3]**2,a=Math.sqrt(Math.max(s,i))/e;s!==i&&this._combinedScaleFactor*a>1?this._cachedGetSinglePixelWidth=-this._combinedScaleFactor*a:e>Number.EPSILON?this._cachedGetSinglePixelWidth=a:this._cachedGetSinglePixelWidth=1}return this._cachedGetSinglePixelWidth}getCanvasPosition(t,e){const s=this.ctx.mozCurrentTransform;return[s[0]*t+s[2]*e+s[4],s[1]*t+s[3]*e+s[5]]}isContentVisible(){for(let t=this.markedContentStack.length-1;t>=0;t--)if(!this.markedContentStack[t].visible)return!1;return!0}}exports.CanvasGraphics=CanvasGraphics;for(const t in _util.OPS)void 0!==CanvasGraphics.prototype[t]&&(CanvasGraphics.prototype[_util.OPS[t]]=CanvasGraphics.prototype[t]);