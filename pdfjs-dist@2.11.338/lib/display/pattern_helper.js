"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getShadingPattern=getShadingPattern,exports.TilingPattern=void 0;var _util=require("../shared/util.js");function applyBoundingBox(t,e){if(!e||"undefined"===typeof Path2D)return;const a=e[2]-e[0],s=e[3]-e[1],r=new Path2D;r.rect(e[0],e[1],a,s),t.clip(r)}class BaseShadingPattern{constructor(){this.constructor===BaseShadingPattern&&(0,_util.unreachable)("Cannot initialize BaseShadingPattern.")}getPattern(){(0,_util.unreachable)("Abstract method `getPattern` called.")}}class RadialAxialShadingPattern extends BaseShadingPattern{constructor(t,e){super(),this._type=t[1],this._bbox=t[2],this._colorStops=t[3],this._p0=t[4],this._p1=t[5],this._r0=t[6],this._r1=t[7],this.matrix=null,this.cachedCanvasPatterns=e}_createGradient(t){let e;"axial"===this._type?e=t.createLinearGradient(this._p0[0],this._p0[1],this._p1[0],this._p1[1]):"radial"===this._type&&(e=t.createRadialGradient(this._p0[0],this._p0[1],this._r0,this._p1[0],this._p1[1],this._r1));for(const a of this._colorStops)e.addColorStop(a[0],a[1]);return e}getPattern(t,e,a,s=!1){let r;if(s)applyBoundingBox(t,this._bbox),r=this._createGradient(t);else if(this.cachedCanvasPatterns.has(this))r=this.cachedCanvasPatterns.get(this);else{const a=e.cachedCanvases.getCanvas("pattern",e.ctx.canvas.width,e.ctx.canvas.height,!0),s=a.context;s.clearRect(0,0,s.canvas.width,s.canvas.height),s.beginPath(),s.rect(0,0,s.canvas.width,s.canvas.height),s.setTransform.apply(s,e.baseTransform),this.matrix&&s.transform.apply(s,this.matrix),applyBoundingBox(s,this._bbox),s.fillStyle=this._createGradient(s),s.fill(),r=t.createPattern(a.canvas,"repeat"),this.cachedCanvasPatterns.set(this,r)}if(!s){const t=new DOMMatrix(a);try{r.setTransform(t)}catch(i){(0,_util.warn)(`RadialAxialShadingPattern.getPattern: "${i?.message}".`)}}return r}}function drawTriangle(t,e,a,s,r,i,n,o){const l=e.coords,c=e.colors,h=t.data,d=4*t.width;let u;l[a+1]>l[s+1]&&(u=a,a=s,s=u,u=i,i=n,n=u),l[s+1]>l[r+1]&&(u=s,s=r,r=u,u=n,n=o,o=u),l[a+1]>l[s+1]&&(u=a,a=s,s=u,u=i,i=n,n=u);const f=(l[a]+e.offsetX)*e.scaleX,p=(l[a+1]+e.offsetY)*e.scaleY,g=(l[s]+e.offsetX)*e.scaleX,_=(l[s+1]+e.offsetY)*e.scaleY,x=(l[r]+e.offsetX)*e.scaleX,m=(l[r+1]+e.offsetY)*e.scaleY;if(p>=m)return;const P=c[i],S=c[i+1],b=c[i+2],y=c[n],T=c[n+1],v=c[n+2],M=c[o],w=c[o+1],C=c[o+2],D=Math.round(p),X=Math.round(m);let k,A,B,Y,R,E,O,U;for(let L=D;L<=X;L++){if(L<_){let t;t=L<p?0:(p-L)/(p-_),k=f-(f-g)*t,A=P-(P-y)*t,B=S-(S-T)*t,Y=b-(b-v)*t}else{let t;t=L>m?1:_===m?0:(_-L)/(_-m),k=g-(g-x)*t,A=y-(y-M)*t,B=T-(T-w)*t,Y=v-(v-C)*t}let t;t=L<p?0:L>m?1:(p-L)/(p-m),R=f-(f-x)*t,E=P-(P-M)*t,O=S-(S-w)*t,U=b-(b-C)*t;const e=Math.round(Math.min(k,R)),a=Math.round(Math.max(k,R));let s=d*L+4*e;for(let r=e;r<=a;r++)t=(k-r)/(k-R),t<0?t=0:t>1&&(t=1),h[s++]=A-(A-E)*t|0,h[s++]=B-(B-O)*t|0,h[s++]=Y-(Y-U)*t|0,h[s++]=255}}function drawFigure(t,e,a){const s=e.coords,r=e.colors;let i,n;switch(e.type){case"lattice":const o=e.verticesPerRow,l=Math.floor(s.length/o)-1,c=o-1;for(i=0;i<l;i++){let e=i*o;for(let i=0;i<c;i++,e++)drawTriangle(t,a,s[e],s[e+1],s[e+o],r[e],r[e+1],r[e+o]),drawTriangle(t,a,s[e+o+1],s[e+1],s[e+o],r[e+o+1],r[e+1],r[e+o])}break;case"triangles":for(i=0,n=s.length;i<n;i+=3)drawTriangle(t,a,s[i],s[i+1],s[i+2],r[i],r[i+1],r[i+2]);break;default:throw new Error("illegal figure")}}class MeshShadingPattern extends BaseShadingPattern{constructor(t){super(),this._coords=t[2],this._colors=t[3],this._figures=t[4],this._bounds=t[5],this._bbox=t[7],this._background=t[8],this.matrix=null}_createMeshCanvas(t,e,a){const s=1.1,r=3e3,i=2,n=Math.floor(this._bounds[0]),o=Math.floor(this._bounds[1]),l=Math.ceil(this._bounds[2])-n,c=Math.ceil(this._bounds[3])-o,h=Math.min(Math.ceil(Math.abs(l*t[0]*s)),r),d=Math.min(Math.ceil(Math.abs(c*t[1]*s)),r),u=l/h,f=c/d,p={coords:this._coords,colors:this._colors,offsetX:-n,offsetY:-o,scaleX:1/u,scaleY:1/f},g=h+2*i,_=d+2*i,x=a.getCanvas("mesh",g,_,!1),m=x.context,P=m.createImageData(h,d);if(e){const t=P.data;for(let a=0,s=t.length;a<s;a+=4)t[a]=e[0],t[a+1]=e[1],t[a+2]=e[2],t[a+3]=255}for(const b of this._figures)drawFigure(P,b,p);m.putImageData(P,i,i);const S=x.canvas;return{canvas:S,offsetX:n-i*u,offsetY:o-i*f,scaleX:u,scaleY:f}}getPattern(t,e,a,s=!1){let r;if(applyBoundingBox(t,this._bbox),s)r=_util.Util.singularValueDecompose2dScale(t.mozCurrentTransform);else if(r=_util.Util.singularValueDecompose2dScale(e.baseTransform),this.matrix){const t=_util.Util.singularValueDecompose2dScale(this.matrix);r=[r[0]*t[0],r[1]*t[1]]}const i=this._createMeshCanvas(r,s?null:this._background,e.cachedCanvases);return s||(t.setTransform.apply(t,e.baseTransform),this.matrix&&t.transform.apply(t,this.matrix)),t.translate(i.offsetX,i.offsetY),t.scale(i.scaleX,i.scaleY),t.createPattern(i.canvas,"no-repeat")}}class DummyShadingPattern extends BaseShadingPattern{getPattern(){return"hotpink"}}function getShadingPattern(t,e){switch(t[0]){case"RadialAxial":return new RadialAxialShadingPattern(t,e);case"Mesh":return new MeshShadingPattern(t);case"Dummy":return new DummyShadingPattern}throw new Error(`Unknown IR type: ${t[0]}`)}const PaintType={COLORED:1,UNCOLORED:2};class TilingPattern{static get MAX_PATTERN_SIZE(){return(0,_util.shadow)(this,"MAX_PATTERN_SIZE",3e3)}constructor(t,e,a,s,r){this.operatorList=t[2],this.matrix=t[3]||[1,0,0,1,0,0],this.bbox=t[4],this.xstep=t[5],this.ystep=t[6],this.paintType=t[7],this.tilingType=t[8],this.color=e,this.ctx=a,this.canvasGraphicsFactory=s,this.baseTransform=r}createPatternCanvas(t){const e=this.operatorList,a=this.bbox,s=this.xstep,r=this.ystep,i=this.paintType,n=this.tilingType,o=this.color,l=this.canvasGraphicsFactory;(0,_util.info)("TilingType: "+n);const c=a[0],h=a[1],d=a[2],u=a[3],f=_util.Util.singularValueDecompose2dScale(this.matrix),p=_util.Util.singularValueDecompose2dScale(this.baseTransform),g=[f[0]*p[0],f[1]*p[1]],_=this.getSizeAndScale(s,this.ctx.canvas.width,g[0]),x=this.getSizeAndScale(r,this.ctx.canvas.height,g[1]),m=t.cachedCanvases.getCanvas("pattern",_.size,x.size,!0),P=m.context,S=l.createCanvasGraphics(P);S.groupLevel=t.groupLevel,this.setFillAndStrokeStyleToContext(S,i,o);let b=c,y=h,T=d,v=u;return c<0&&(b=0,T+=Math.abs(c)),h<0&&(y=0,v+=Math.abs(h)),P.translate(-_.scale*b,-x.scale*y),S.transform(_.scale,0,0,x.scale,0,0),this.clipBbox(S,b,y,T,v),S.baseTransform=S.ctx.mozCurrentTransform.slice(),S.executeOperatorList(e),S.endDrawing(),{canvas:m.canvas,scaleX:_.scale,scaleY:x.scale,offsetX:b,offsetY:y}}getSizeAndScale(t,e,a){t=Math.abs(t);const s=Math.max(TilingPattern.MAX_PATTERN_SIZE,e);let r=Math.ceil(t*a);return r>=s?r=s:a=r/t,{scale:a,size:r}}clipBbox(t,e,a,s,r){const i=s-e,n=r-a;t.ctx.rect(e,a,i,n),t.clip(),t.endPath()}setFillAndStrokeStyleToContext(t,e,a){const s=t.ctx,r=t.current;switch(e){case PaintType.COLORED:const t=this.ctx;s.fillStyle=t.fillStyle,s.strokeStyle=t.strokeStyle,r.fillColor=t.fillStyle,r.strokeColor=t.strokeStyle;break;case PaintType.UNCOLORED:const i=_util.Util.makeHexColor(a[0],a[1],a[2]);s.fillStyle=i,s.strokeStyle=i,r.fillColor=i,r.strokeColor=i;break;default:throw new _util.FormatError(`Unsupported paint type: ${e}`)}}getPattern(t,e,a,s=!1){let r=a;s||(r=_util.Util.transform(r,e.baseTransform),this.matrix&&(r=_util.Util.transform(r,this.matrix)));const i=this.createPatternCanvas(e);let n=new DOMMatrix(r);n=n.translate(i.offsetX,i.offsetY),n=n.scale(1/i.scaleX,1/i.scaleY);const o=t.createPattern(i.canvas,"repeat");try{o.setTransform(n)}catch(l){(0,_util.warn)(`TilingPattern.getPattern: "${l?.message}".`)}return o}}exports.TilingPattern=TilingPattern;